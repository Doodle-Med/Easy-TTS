<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<style>
:root {
  /* Light theme (default) */
  --c1:#4285f4;
  --c2:#34a853;
  --c3:#ea4335;
  --c4:#fbbc04;
  --bg:#f8f9fa;
  --card-bg:#ffffff;
  --fg:#202124;
  --bd:#dadce0;
  --hover:#f1f3f4;
  --r:10px;
  --shadow: 0 4px 12px rgba(0,0,0,.05);
  --code-bg: #f5f5f5;
  --hover-bg: rgba(66,133,244,0.1);
  
  /* Animation and transition properties */
  --transition: all 0.3s ease;
}

/* Dark theme variables */
[data-theme="dark"] {
  --c1:#8ab4f8;
  --c2:#81c995;
  --c3:#f28b82;
  --c4:#fdd663;
  --bg:#202124;
  --card-bg:#292a2d;
  --fg:#e8eaed;
  --bd:#5f6368;
  --hover:#3c3c3c;
  --shadow: 0 4px 12px rgba(0,0,0,.2);
  --code-bg: #2d2d30;
  --hover-bg: rgba(138, 180, 248, 0.15);
}

* {
  box-sizing:border-box;
  margin:0;
  padding:0;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
  transition: var(--transition);
}

body {
  background:var(--bg);
  color:var(--fg);
  padding:1rem;
  max-width:1200px;
  margin:auto;
}

h1 {
  font-size:clamp(1.7rem,2.5vw,3rem);
  text-align:center;
  margin-bottom:1rem;
  background:linear-gradient(90deg,var(--c1),var(--c2),var(--c4),var(--c3));
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;
  font-weight:800;
}

.grid {
  display:grid;
  gap:1rem;
}

.two {
  grid-template-columns:1fr 1fr;
}

@media(max-width:800px) {
  .two {
    grid-template-columns:1fr;
  }
}

.card {
  background:var(--card-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  box-shadow:var(--shadow);
  padding:1.2rem;
  position:relative;
}

.card:hover {
  box-shadow: 0 6px 16px rgba(0,0,0, var(--shadow-opacity, 0.08));
}

.card-header {
  display:flex;
  align-items:center;
  margin-bottom:1rem;
}

.card-header h2 {
  flex:1;
  font-size:1.3rem;
}

label {
  font-weight:600;
  margin:.6rem 0 .3rem;
  display:block;
}

input, select, textarea, button {
  width:100%;
  padding:.55rem .65rem;
  border:1px solid var(--bd);
  border-radius:6px;
  font-size:1rem;
  margin-bottom:.8rem;
  background: var(--card-bg);
  color: var(--fg);
}

input:focus, select:focus, textarea:focus {
  border-color:var(--c1);
  outline:none;
  box-shadow: 0 0 0 3px rgba(66,133,244,0.2);
}

textarea {
  resize:vertical;
  min-height:140px;
}

button {
  cursor:pointer;
  background:var(--c1);
  color:#fff;
  border:none;
  font-weight:600;
}

button:not(:disabled):hover {
  background:#3367d6;
  transform: translateY(-1px);
}

button:disabled {
  background:var(--bd);
  cursor:not-allowed;
  opacity: 0.7;
}

.small-btn {
  width:auto;
}

.toggle {
  display:flex;
  gap:.5rem;
  margin:.6rem 0;
}

.toggle button {
  flex:1;
  background:var(--bg);
  border:1px solid var(--bd);
  color:var(--fg);
}

.toggle .active {
  background:var(--c2);
  color:#fff;
  border-color:var(--c2);
}

.status {
  min-height:1.4em;
  font-size:.95rem;
  margin:.5rem 0;
  padding: .5rem;
  border-radius: 6px;
}

.error {
  color:var(--c3);
  background: rgba(234,67,53,0.1);
  font-weight:700;
}

.success {
  color:var(--c2);
  background: rgba(52,168,83,0.1);
  font-weight:700;
}

.bar {
  height:12px;
  background:var(--bd);
  border-radius:6px;
  overflow:hidden;
  cursor:pointer;
  margin:.8rem 0;
}

.fill {
  height:100%;
  background:linear-gradient(90deg,var(--c1),var(--c2));
  width:0;
  transition: width 0.1s linear;
}

.audio {
  display:flex;
  align-items:center;
  gap:.6rem;
}

.audio button {
  width:44px;
  border-radius:50%;
  aspect-ratio:1/1;
  font-size:1.1rem;
  display:grid;
  place-items:center;
}

.time {
  font-family:monospace;
  margin-left:auto;
}

.text-box {
  background:var(--card-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  padding:1rem;
  max-height:340px;
  overflow:auto;
  line-height:1.6;
}

.word {
  display:inline-block;
  cursor:pointer;
  border-radius:3px;
  padding:1px 2px;
  transition: all 0.15s ease;
}

.word:hover {
  background:var(--hover-bg);
}

.word.active {
  background:rgba(66,133,244,.25);
  color:var(--c1);
  font-weight:700;
}

.word.loading {
  position: relative;
  background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
  background-size: 200% 100%;
  animation: shine 1.5s infinite;
  cursor:wait;
  opacity:0.6;
}

@keyframes shine {
  to { background-position: -200% 0; }
}

.spinner {
  display:inline-block;
  width:14px;
  height:14px;
  border:2px solid rgba(66,133,244,0.2);
  border-radius:50%;
  border-top-color:var(--c1);
  animation:spin 0.8s linear infinite;
  margin-right:5px;
}

@keyframes spin {
  to {transform:rotate(360deg)}
}

.controls {
  display:flex;
  align-items:center;
  gap:0.5rem;
  margin-bottom:0.8rem;
}

.controls button {
  margin-bottom:0;
}

.volume-control {
  display:flex;
  align-items:center;
  gap:0.5rem;
  flex:1;
}

.volume-control input {
  margin:0;
}

.download-btn {
  margin-left:auto;
}

.debug-panel {
  font-family:monospace;
  font-size:12px;
  background:var(--code-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  padding:0.8rem;
  margin-top:1rem;
  max-height:200px;
  overflow:auto;
}

.debug-entry {
  margin-bottom:0.3rem;
  border-bottom:1px solid var(--bd);
  padding-bottom:0.3rem;
}

.debug-time {
  color:var(--fg);
  opacity: 0.6;
  font-size:10px;
}

.debug-msg {
  font-weight:bold;
}

.debug-data {
  color:var(--fg);
  opacity: 0.8;
  margin-left:1rem;
}

.toggle-debug {
  text-align:center;
  font-size:0.9rem;
  margin-top:0.5rem;
  cursor:pointer;
  color:var(--c1);
}

.theme-toggle {
  position: absolute;
  top: 1rem;
  right: 1rem;
  z-index: 100;
}

.theme-toggle button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  background: transparent;
  color: var(--fg);
  border: 1px solid var(--bd);
}

.theme-toggle button:hover {
  background: var(--hover-bg);
  transform: none;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--bd);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--c1);
}

.hidden {
  display:none !important;
}
</style>
</head>
<body>
<h1>Google Cloud TTS Playground</h1>
<div class="theme-toggle">
  <button id="themeToggle" title="Toggle Theme">üåì</button>
</div>
<div class="grid two">
  <div class="card">
    <div class="card-header">
      <h2>üéõÔ∏è Configuration</h2>
    </div>
    <label>API Key</label>
    <div class="controls">
      <input id="k" type="password" placeholder="Enter your Google Cloud API Key"/>
      <button class="small-btn" id="ld">Load Voices</button>
    </div>
    <div id="loading" class="status hidden"><span class="spinner"></span>Loading voices...</div>
    
    <label>Text</label>
    <textarea id="txt" placeholder="Type or paste text here..."></textarea>
    
    <label>Voice</label>
    <select id="v" disabled></select>
    
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:.8rem">
      <div>
        <label>Pitch <span id="pitVal">0</span></label>
        <input id="pit" type="range" min="-20" max="20" value="0"/>
      </div>
      <div>
        <label>Rate <span id="ratVal">1</span></label>
        <input id="rat" type="range" min="0.25" max="4" step="0.05" value="1"/>
      </div>
    </div>
    
    <label>Chunk Size <span id="chkVal">1000</span></label>
    <input id="chk" type="range" min="500" max="4500" step="500" value="1000"/>
    
    <div class="toggle" id="method">
      <button data-m="sentence">Sentence</button>
      <button data-m="paragraph" class="active">Paragraph</button>
      <button data-m="exact">Exact</button>
    </div>
    
    <button id="gen" disabled>üé§ Generate & Play</button>
    <div id="stat" class="status"></div>
  </div>
  
  <div class="card">
    <div class="card-header">
      <h2>üîä Playback</h2>
    </div>
    <div id="text" class="text-box"><p style="opacity:.6;text-align:center;">Words will appear here...</p></div>
    <canvas id="visualizer" height="80" style="width:100%;margin:0.8rem 0;border:1px solid var(--bd);border-radius:var(--r);"></canvas>
    <div class="bar" id="prog">
      <div class="fill" id="fill"></div>
    </div>
    
    <div class="audio">
      <button class="small-btn" id="play" disabled title="Play">‚ñ∂</button>
      <button class="small-btn" id="pause" disabled title="Pause">‚è∏</button>
      <button class="small-btn" id="stop" disabled title="Stop">‚èπ</button>
      
      <div class="volume-control">
        <span>üîä</span>
        <input type="range" id="volume" min="0" max="1" step="0.1" value="1"/>
      </div>
      
      <span class="time" id="time">00:00 / 00:00</span>
    </div>
    
    <button id="download" class="download-btn" disabled>üíæ Download Audio</button>
    <div class="toggle-debug" id="toggleDebug">Show Debug Info</div>
    <div id="debugPanel" class="debug-panel hidden"></div>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  // API endpoints & DOM elements
  const VO = 'https://texttospeech.googleapis.com/v1/voices';
  const SY = 'https://texttospeech.googleapis.com/v1/text:synthesize';
  const Q = id => document.getElementById(id);
  const E = {
    key: Q('k'),
    load: Q('ld'),
    loading: Q('loading'),
    txt: Q('txt'),
    voice: Q('v'),
    pit: Q('pit'),
    rat: Q('rat'),
    pitVal: Q('pitVal'),
    ratVal: Q('ratVal'),
    chk: Q('chk'),
    chkVal: Q('chkVal'),
    gen: Q('gen'),
    stat: Q('stat'),
    methodBtns: [...Q('method').children],
    textBox: Q('text'),
    play: Q('play'),
    pause: Q('pause'),
    stop: Q('stop'),
    volume: Q('volume'),
    download: Q('download'),
    prog: Q('prog'),
    fill: Q('fill'),
    time: Q('time'),
    toggleDebug: Q('toggleDebug'),
    debugPanel: Q('debugPanel'),
    themeToggle: Q('themeToggle')
  };
  
  // Debug logging
  let debugEnabled = localStorage.getItem('debugEnabled') === 'true';
  const maxDebugEntries = 100;
  let debugEntries = [];
  
  // Theme toggle
  let isDarkMode = localStorage.getItem('darkMode') === 'true';
  if (isDarkMode) {
    document.documentElement.setAttribute('data-theme', 'dark');
  }
  
  E.themeToggle.addEventListener('click', () => {
    isDarkMode = !isDarkMode;
    document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
    localStorage.setItem('darkMode', isDarkMode);
    log(`Theme changed to ${isDarkMode ? 'dark' : 'light'} mode`);
  });
  
  // Toggle debug panel
  E.toggleDebug.addEventListener('click', () => {
    debugEnabled = !debugEnabled;
    localStorage.setItem('debugEnabled', debugEnabled);
    E.debugPanel.classList.toggle('hidden', !debugEnabled);
    E.toggleDebug.textContent = debugEnabled ? 'Hide Debug Info' : 'Show Debug Info';
    
    if (debugEnabled) {
      updateDebugPanel();
    }
  });
  
  // Initialize debug panel state
  if (debugEnabled) {
    E.debugPanel.classList.remove('hidden');
    E.toggleDebug.textContent = 'Hide Debug Info';
  }

  // Enhanced logging with debug panel support
  const log = (message, data = null, level = 'info') => {
    const timestamp = new Date().toISOString();
    const entry = {
      timestamp,
      message,
      data,
      level
    };
    
    // Add to debug entries
    debugEntries.unshift(entry);
    if (debugEntries.length > maxDebugEntries) {
      debugEntries.pop();
    }
    
    // Output to console with appropriate level
    switch(level) {
      case 'error':
        console.error(`[${timestamp}] ${message}`, data);
        break;
      case 'warn':
        console.warn(`[${timestamp}] ${message}`, data);
        break;
      default:
        console.log(`[${timestamp}] ${message}`, data);
    }
    
    // Update debug panel if visible
    if (debugEnabled) {
      updateDebugPanel();
    }
  };
  
  // Update debug panel with latest entries
  const updateDebugPanel = () => {
    E.debugPanel.innerHTML = debugEntries.map(entry => {
      const timeStr = new Date(entry.timestamp).toLocaleTimeString();
      let dataStr = '';
      
      if (entry.data !== null) {
        try {
          if (typeof entry.data === 'object') {
            dataStr = `<div class="debug-data">${JSON.stringify(entry.data)}</div>`;
          } else {
            dataStr = `<div class="debug-data">${entry.data}</div>`;
          }
        } catch (e) {
          dataStr = `<div class="debug-data">[Complex Object]</div>`;
        }
      }
      
      return `
        <div class="debug-entry ${entry.level}">
          <span class="debug-time">${timeStr}</span>
          <span class="debug-msg">${entry.message}</span>
          ${dataStr}
        </div>
      `;
    }).join('');
  };

  // App state
  let API = localStorage.getItem('apiKey') || '';
  let ctx;
  let gainNode;
  let voices = [];
  let buffers = [];
  let audioBlobs = []; // Store audio as blobs for download
  let audioSources = []; // Track all audio sources
  let wordElements = []; // Store word elements for efficient lookup
  let wordTimings = []; // NEW: More accurate timing data for words
  let totalDuration = 0; // Total final duration
  let loadedDuration = 0; // Duration of loaded chunks so far
  let startTime = 0; // When playback started
  let pausedAt = 0; // Where we paused
  let playbackId = 0; // Used to cancel stale playback
  let playing = false;
  let paused = false;
  let method = 'paragraph';
  let currentWordIndex = -1;
  let loadingComplete = false;
  let chunksReceived = 0;
  let totalChunks = 0;
  let chunksData = []; // NEW: Store detailed data about each chunk
  let visualizer;
  
  // Initialize API key if saved
  if (API) {
    E.key.value = API;
    // Auto-load voices if API key is saved
    log('API key found in localStorage, auto-loading voices');
    setTimeout(() => E.load.click(), 500);
  }

  // Utilities
  const fmt = s => `${String(Math.floor(s/60)).padStart(2, '0')}:${String(Math.floor(s%60)).padStart(2, '0')}`;
  
  const status = (m, isError) => {
    E.stat.textContent = m;
    E.stat.className = 'status' + (isError ? ' error' : isError === false ? ' success' : '');
    log(m, null, isError ? 'error' : 'info');
  };
  
  // JSON fetch helper with error handling
  const fetchJSON = async (url, opts) => {
    try {
      log(`Fetching ${url}`, opts);
      const r = await fetch(url, opts);
      
      if (!r.ok) {
        let m = `HTTP ${r.status}`;
        try {
          const errorData = await r.json();
          m = errorData.error?.message || m;
          log('API Error', errorData, 'error');
        } catch (e) {
          log('Failed to parse error response', e, 'error');
        }
        throw new Error(m);
      }
      
      const data = await r.json();
      log(`Fetch completed successfully`, { url });
      return data;
    } catch (e) {
      log('Fetch error', e, 'error');
      throw e;
    }
  };

  // UI event binding
  ['pit', 'rat', 'chk'].forEach(id => {
    E[id].addEventListener('input', e => {
      const span = E[`${id}Val`];
      if (span) {
        const val = id === 'rat' ? parseFloat(e.target.value).toFixed(2) : e.target.value;
        span.textContent = val;
      }
    });
  });
  
  // Initialize volume control
  E.volume.addEventListener('input', () => {
    if (gainNode) {
      gainNode.gain.value = E.volume.value;
      log(`Volume changed to ${E.volume.value}`);
    }
  });

  // Load voices from Google TTS API
  E.load.onclick = async () => {
    API = E.key.value.trim();
    if (!API) return status('API key required', true);
    
    // Save API key to localStorage
    localStorage.setItem('apiKey', API);
    
    E.loading.classList.remove('hidden');
    E.load.disabled = true;
    status('Loading voices...');
    
    try {
      log(`Requesting voices from ${VO}`);
      const d = await fetchJSON(`${VO}?key=${API}`);
      voices = d.voices || [];
      
      if (!voices.length) throw new Error('No voices returned');
      
      log(`Loaded ${voices.length} voices`);
      
      // Group voices by language
      const langMap = new Map();
      voices.forEach(v => {
        v.languageCodes.forEach(code => {
          let name;
          try {
            name = new Intl.DisplayNames(['en'], { type: 'language' }).of(code);
          } catch (e) {
            name = code;
          }
          
          if (!langMap.has(code)) {
            langMap.set(code, { name, voices: [] });
          }
          langMap.get(code).voices.push(v);
        });
      });
      
      // Sort languages by name
      const sortedLangs = [...langMap.entries()]
        .sort((a, b) => a[1].name.localeCompare(b[1].name));
      
      // Group options by language
      const html = sortedLangs.map(([code, { name, voices }]) => {
        const options = voices
          .sort((a, b) => a.name.localeCompare(b.name))
          .map(v => {
            const isNeural = v.name.includes('Neural') || v.name.includes('Wavenet');
            return `<option value="${v.name}" data-l="${code}">${v.name} ${isNeural ? '(Neural)' : ''}</option>`;
          })
          .join('');
        
        return `<optgroup label="${name}">${options}</optgroup>`;
      }).join('');
      
      E.voice.innerHTML = html;
      E.voice.disabled = false;
      E.gen.disabled = false;
      
      status('Voices loaded successfully', false);
    } catch (e) {
      status(`Failed to load voices: ${e.message}`, true);
    } finally {
      E.loading.classList.add('hidden');
      E.load.disabled = false;
    }
  };

  // Configure chunk splitting method
  E.methodBtns.forEach(b => b.onclick = () => {
    E.methodBtns.forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    method = b.dataset.m;
    log(`Splitting method changed to: ${method}`);
  });

  // Split text into chunks based on selected method
  const splitText = t => {
    const m = +E.chk.value;
    log(`Splitting text (${t.length} chars) with method: ${method}, chunk size: ${m}`);
    
    if (t.length <= m) return [t];
    
    if (method === 'exact') {
      const a = [];
      for (let i = 0; i < t.length; i += m) {
        a.push(t.slice(i, i + m));
      }
      log(`Split into ${a.length} chunks using exact method`);
      return a;
    }
    
    const re = method === 'paragraph' ? /\n\s*\n/ : /([.!?]+["']?\s+)/;
    const bits = t.split(re).filter(Boolean);
    log(`Split text into ${bits.length} initial segments`);
    
    const out = [];
    let cur = '';
    
    for (const p of bits) {
      if ((cur + p).length > m) {
        if (cur.trim()) out.push(cur.trim());
        cur = '';
        
        if (p.length > m) {
          let q = p;
          while (q.length > m) {
            out.push(q.slice(0, m));
            q = q.slice(m);
          }
          cur = q;
        } else {
          cur = p;
        }
      } else {
        cur += p;
      }
    }
    
    if (cur.trim()) out.push(cur.trim());
    
    log(`Final chunks: ${out.length}`, {
      chunkSizes: out.map(c => c.length)
    });
    
    return out;
  };

  // Decode audio buffer
  const decodeBuffer = a => {
    log(`Decoding audio buffer of size ${a.byteLength}`);
    return new Promise((res, rej) => {
      try {
        ctx.decodeAudioData(a, 
          (buffer) => {
            log(`Audio buffer decoded successfully: ${buffer.duration.toFixed(2)}s`);
            res(buffer);
          },
          (err) => {
            log(`Error decoding audio buffer`, err, 'error');
            rej(err);
          }
        );
      } catch (e) {
        log(`Exception in decodeBuffer`, e, 'error');
        rej(e);
      }
    });
  };

  // NEW: Prepare text display with clickable words and improved timing calculations
  const prepareTextDisplay = (text, chunks) => {
    log(`Preparing text display with ${text.length} chars and ${chunks.length} chunks`);
    
    E.textBox.innerHTML = '';
    wordElements = [];
    wordTimings = []; // Reset word timings
    chunksData = []; // Reset chunks data
    
    // Initialize chunks data
    for (let i = 0; i < chunks.length; i++) {
      chunksData[i] = {
        text: chunks[i],
        startTime: 0, // Will be calculated when audio is loaded
        endTime: 0,   // Will be calculated when audio is loaded
        wordCount: 0, // Will be calculated below
        duration: 0,  // Will be updated when audio is loaded
        loaded: false
      };
    }
    
    // Split text into words and spaces, tracking chunk boundaries
    let currentChunk = 0;
    let chunkWordCount = 0;
    let chunkStartPos = 0;
    let globalWordIndex = 0;
    
    // Pre-calculate how many words are in each chunk
    chunks.forEach((chunk, idx) => {
      const wordCount = chunk.split(/\s+/).filter(Boolean).length;
      chunksData[idx].wordCount = wordCount;
    });
    
    // Process words with knowledge of which chunk they belong to
    text.split(/(\s+)/).forEach((part) => {
      if (part.trim()) {
        // This is a word (not whitespace)
        const span = document.createElement('span');
        span.textContent = part;
        span.className = 'word loading'; // Start as loading
        span.dataset.index = globalWordIndex;
        
        // Find which chunk this word belongs to
        while (chunkStartPos + chunksData[currentChunk].text.length < text.indexOf(part, chunkStartPos) && 
               currentChunk < chunks.length - 1) {
          chunkStartPos += chunksData[currentChunk].text.length;
          currentChunk++;
          chunkWordCount = 0;
        }
        
        // Store chunk association
        span.dataset.chunk = currentChunk;
        
        // Store timing data (will be updated later)
        wordTimings[globalWordIndex] = {
          word: part,
          chunk: currentChunk,
          indexInChunk: chunkWordCount,
          startTime: 0, // Will be calculated when audio is loaded
          endTime: 0    // Will be calculated when audio is loaded
        };
        
        chunkWordCount++;
        
        // Add click handler
        span.addEventListener('click', (e) => {
          if (span.classList.contains('loading')) {
            status('That part is still loading...');
            return;
          }
          const clickedIndex = parseInt(e.currentTarget.dataset.index);
          log(`Word clicked: ${e.currentTarget.textContent} (index ${clickedIndex})`);
          seekToWord(clickedIndex);
        });
        
        wordElements.push(span);
        E.textBox.appendChild(span);
        globalWordIndex++;
      } else {
        // This is whitespace
        E.textBox.appendChild(document.createTextNode(part));
      }
    });
    
    log(`Text display prepared with ${globalWordIndex} words`);
  };
  
  // NEW: Update word timings when a chunk is loaded
  const updateWordTimings = (chunkIndex, duration) => {
    if (!chunksData[chunkIndex]) return;
    
    log(`Updating word timings for chunk ${chunkIndex}, duration ${duration.toFixed(2)}s`);
    
    // Update chunk data
    chunksData[chunkIndex].loaded = true;
    chunksData[chunkIndex].duration = duration;
    
    // Calculate chunk start time (sum of durations of all previous loaded chunks)
    let chunkStartTime = 0;
    for (let i = 0; i < chunkIndex; i++) {
      if (chunksData[i].loaded) {
        chunkStartTime += chunksData[i].duration;
      }
    }
    
    chunksData[chunkIndex].startTime = chunkStartTime;
    chunksData[chunkIndex].endTime = chunkStartTime + duration;
    
    // Find all words in this chunk
    const chunkWordCount = chunksData[chunkIndex].wordCount;
    
    // Update timings for all words in this chunk
    wordTimings.forEach((timing, i) => {
      if (timing.chunk === chunkIndex) {
        // Calculate word timing within the chunk
        // This uses a more sophisticated approach considering:
        // 1. Words near the beginning/end have more spacing
        // 2. The middle of the speech tends to be faster
        
        const relPos = timing.indexInChunk / chunkWordCount;
        let timeRatio;
        
        // Apply a curve to simulate natural speech rhythm
        // Words at beginning and end tend to have more time allocated
        if (relPos < 0.1) {
          // First 10% of words get a bit more time (slow start)
          timeRatio = relPos * 0.8; // Slightly compressed
        } else if (relPos > 0.9) {
          // Last 10% of words get a bit more time (slow ending)
          timeRatio = 0.8 + (relPos - 0.9) * 2; // Slightly expanded
        } else {
          // Middle words follow a more linear pattern
          timeRatio = 0.08 + (relPos - 0.1) * 0.84;
        }
        
        // Allocate time slices
        const wordStartTime = chunkStartTime + (timeRatio * duration);
        const nextWordTime = chunkStartTime + (((timing.indexInChunk + 1) / chunkWordCount) * duration);
        
        // Apply some smoothing to prevent unrealistic timing
        const minWordDuration = Math.min(0.2, duration / (chunkWordCount * 2));
        const wordEndTime = Math.min(nextWordTime, wordStartTime + minWordDuration + (0.5 * duration / chunkWordCount));
        
        timing.startTime = wordStartTime;
        timing.endTime = wordEndTime;
        
        // Remove loading state from the word element
        const el = wordElements[i];
        if (el) {
          el.classList.remove('loading');
        }
      }
    });
    
    log(`Updated timings for words in chunk ${chunkIndex}`);
  };

  // NEW: Find current time position with optimized approach
  const locateTimePosition = (time) => {
    // Throttle debug logging for this frequently called function
    const shouldLog = Math.random() < 0.01;
    
    if (shouldLog) {
      log(`Locating position for time ${time.toFixed(2)}s`);
    }
    
    // Handle case where time is beyond loaded duration
    if (time >= loadedDuration) {
      const lastIndex = buffers.findLastIndex(b => b);
      return { chunk: lastIndex === -1 ? 0 : lastIndex, offset: 0 };
    }
    
    // Find the chunk that contains this time using chunksData
    for (let i = 0; i < chunksData.length; i++) {
      if (chunksData[i].loaded && 
          time >= chunksData[i].startTime && 
          time < chunksData[i].endTime) {
        
        const offset = time - chunksData[i].startTime;
        if (shouldLog) {
          log(`Found time ${time.toFixed(2)}s in chunk ${i} at offset ${offset.toFixed(2)}s`);
        }
        return { chunk: i, offset: offset };
      }
    }
    
    // Fallback: linear search through buffers if chunksData lookup fails
    let currentTime = 0;
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      if (!buffer) continue; // Skip unloaded chunks
      
      const duration = buffer.duration;
      if (time < currentTime + duration) {
        const offset = time - currentTime;
        if (shouldLog) {
          log(`Fallback: found time ${time.toFixed(2)}s in chunk ${i} at offset ${offset.toFixed(2)}s`);
        }
        return { chunk: i, offset: offset };
      }
      
      currentTime += duration;
    }
    
    // Final fallback: use last loaded chunk
    const lastLoaded = buffers.findLastIndex(b => b);
    if (shouldLog) {
      log(`Could not locate time ${time.toFixed(2)}s, using last loaded chunk`);
    }
    return { chunk: lastLoaded === -1 ? 0 : lastLoaded, offset: 0 };
  };

  // Seek to a specific time
  const seekToTime = (time) => {
    if (!buffers.some(b => b)) {
      log(`Cannot seek: no buffers loaded`);
      return;
    }
    
    // Ensure time is within valid range
    time = Math.max(0, Math.min(time, loadedDuration));
    
    log(`Seeking to ${time.toFixed(2)}s`);
    
    // Find the chunk this time belongs to
    const { chunk, offset } = locateTimePosition(time);
    
    // Cancel any current playback
    cancelPlayback();
    
    if (paused) {
      // Just update the paused position
      pausedAt = time;
      updateUI(time);
      log(`Updated paused position to ${time.toFixed(2)}s`);
    } else {
      // Start playback from this position
      startPlayback(chunk, offset, time);
    }
  };

  // NEW: Completely revamped word navigation approach
  const seekToWord = (wordIndex) => {
    wordIndex = parseInt(wordIndex);
    
    if (isNaN(wordIndex) || wordIndex < 0 || wordIndex >= wordElements.length) {
      log(`Cannot seek to word ${wordIndex}: out of range`, {
        wordCount: wordElements.length,
        maxValidIndex: wordElements.length - 1
      });
      return;
    }
    
    // Get timing data for this word
    const timing = wordTimings[wordIndex];
    if (!timing) {
      log(`No timing data for word ${wordIndex}`, { wordIndex });
      return;
    }
    
    // Make sure the chunk is loaded
    const chunkIndex = timing.chunk;
    if (!chunksData[chunkIndex]?.loaded || !buffers[chunkIndex]) {
      log(`Word ${wordIndex} (${timing.word}) is in chunk ${chunkIndex} which is not loaded yet`);
      return;
    }
    
    // Get the calculated word start time
    const time = timing.startTime;
    log(`Seeking to word "${timing.word}" (index ${wordIndex}) at time ${time.toFixed(2)}s`);
    
    // Seek to this time
    seekToTime(time);
  };

  // Initialize audio context
  const initAudioContext = () => {
    if (!ctx) {
      log('Initializing AudioContext');
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create master gain node for volume control
      gainNode = ctx.createGain();
      gainNode.gain.value = E.volume.value;
      gainNode.connect(ctx.destination);
      
      visualizer = new VoiceVisualizer('visualizer', ctx, {
        mode: 'waveform',
        color: 'gradient'
      });
      
      log('AudioContext initialized', {
        sampleRate: ctx.sampleRate
      });
    }
    
    return ctx.resume(); // Ensure it's running
  };

  // Start playback from a specific position
  const startPlayback = (chunkIndex, offset = 0, absoluteTime = 0) => {
    // Ensure audio context is initialized
    initAudioContext();
    
    // Generate a new playback ID to track this session
    playbackId = Date.now();
    const currentPlayback = playbackId;
    
    // Update state
    playing = true;
    paused = false;
    startTime = ctx.currentTime - absoluteTime;
    
    log(`Starting playback: chunk ${chunkIndex}, offset ${offset.toFixed(2)}s, abs time ${absoluteTime.toFixed(2)}s`);
    
    // Update UI
    E.play.disabled = true;
    E.pause.disabled = false;
    E.stop.disabled = false;
    
    // Start playing from the specified position
    playChunk(chunkIndex, offset, currentPlayback);
    
    // Start the update loop
    requestAnimationFrame(updatePlayback);
  };

  // Play a specific chunk
  const playChunk = (index, offset = 0, id) => {
    // Check if this playback request is still valid
    if (id !== playbackId) {
      log(`Ignoring stale playback request: ${id} vs ${playbackId}`);
      return;
    }
    
    // Check if we've reached the end
    if (index >= buffers.length) {
      log('Reached end of audio');
      stopPlayback();
      return;
    }
    
    // Get the audio buffer for this chunk
    const buffer = buffers[index];
    
    // If the buffer isn't loaded yet, wait and retry
    if (!buffer) {
      log(`Chunk ${index} not loaded yet, waiting...`);
      setTimeout(() => {
        if (playing && id === playbackId) {
          playChunk(index, offset, id);
        }
      }, 300);
      return;
    }
    
    log(`Playing chunk ${index} from offset ${offset.toFixed(2)}s`);
    
    // Create a new audio source
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    
    // Connect to visualizer
    source.connect(visualizer.analyser);
    visualizer.analyser.connect(gainNode);
    
    // When this chunk ends, play the next one
    source.onended = () => {
      // Only proceed if this is still the active playback
      if (playing && id === playbackId) {
        log(`Chunk ${index} ended, playing next chunk`);
        playChunk(index + 1, 0, id);
      }
    };
    
    // Save the source so we can stop it later
    audioSources[index] = source;
    
    // Start playback with the specified offset
    source.start(0, Math.min(offset, buffer.duration));
  };

  // Cancel any current playback
  const cancelPlayback = () => {
    log('Canceling current playback');
    
    // Stop all audio sources
    audioSources.forEach((source, i) => {
      if (source) {
        log(`Stopping audio source for chunk ${i}`);
        source.onended = null; // Remove callback
        try { source.stop(); } catch (e) {
          log(`Error stopping source for chunk ${i}`, e, 'warn');
        }
      }
    });
    
    // Reset sources array
    audioSources = [];
    
    // Generate a new playback ID to invalidate any pending callbacks
    playbackId = Date.now();
  };

  // Pause playback
  const pausePlayback = () => {
    if (!playing) {
      log('Cannot pause: not playing');
      return;
    }
    
    pausedAt = ctx.currentTime - startTime;
    playing = false;
    paused = true;
    
    log(`Pausing at ${pausedAt.toFixed(2)}s`);
    
    // Cancel current playback
    cancelPlayback();
    
    // Update UI
    E.play.disabled = false;
    E.pause.disabled = true;
    
    status(`Paused at ${fmt(pausedAt)}`);
  };

  // Resume playback
  const resumePlayback = () => {
    if (!paused) {
      log('Cannot resume: not paused');
      return;
    }
    
    log(`Resuming from ${pausedAt.toFixed(2)}s`);
    
    // Find the chunk to resume from
    const { chunk, offset } = locateTimePosition(pausedAt);
    
    // Start playback from the pause position
    startPlayback(chunk, offset, pausedAt);
  };

  // Stop playback
  const stopPlayback = (silent = false) => {
    // Cancel current playback
    cancelPlayback();
    
    // Reset state
    playing = false;
    paused = false;
    pausedAt = 0;
    
    // Clear word highlighting
    if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
      wordElements[currentWordIndex].classList.remove('active');
    }
    currentWordIndex = -1;
    
    if (!silent) {
      log('Playback stopped');
      
      // Reset UI
      E.fill.style.width = '0%';
      E.time.textContent = `00:00 / ${fmt(totalDuration)}`;
      E.play.disabled = false;
      E.pause.disabled = true;
      E.stop.disabled = false;
    }
  };

  // Update playback UI (called on each animation frame)
  const updatePlayback = () => {
    if (!playing) return;
    
    // Calculate current time
    const currentTime = ctx.currentTime - startTime;
    
    // Check if we've reached the end
    if (currentTime >= totalDuration) {
      log(`Reached end of playback (${currentTime.toFixed(2)}s >= ${totalDuration.toFixed(2)}s)`);
      stopPlayback();
      return;
    }
    
    // Update UI
    updateUI(currentTime);
    
    // Continue updates
    requestAnimationFrame(updatePlayback);
  };

  // Update UI with current time
  const updateUI = (time) => {
    // Update progress bar
    const percentage = totalDuration > 0 ? (time / totalDuration) * 100 : 0;
    E.fill.style.width = `${percentage}%`;
    
    // Update time display
    E.time.textContent = `${fmt(time)} / ${fmt(totalDuration)}`;
    
    // Update word highlighting
    updateWordHighlight(time);
  };

  // NEW: Improved word highlighting based on actual word timings
  const updateWordHighlight = (time) => {
    // Find the word that should be highlighted at the current time
    // using the timing data we calculated
    let newWordIndex = -1;
    
    // Find the word whose timing range contains the current time
    for (let i = 0; i < wordTimings.length; i++) {
      const timing = wordTimings[i];
      if (timing.startTime <= time && time <= timing.endTime) {
        newWordIndex = i;
        break;
      }
    }
    
    // If no exact match, find the closest word
    if (newWordIndex === -1) {
      // Find the word that will be spoken next
      for (let i = 0; i < wordTimings.length; i++) {
        if (time < wordTimings[i].startTime) {
          newWordIndex = i;
          break;
        }
      }
      
      // If we're past all words, highlight the last one
      if (newWordIndex === -1 && wordTimings.length > 0) {
        newWordIndex = wordTimings.length - 1;
      }
    }
    
    // Only update if it's a different word
    if (newWordIndex !== currentWordIndex) {
      // Remove highlight from previous word
      if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
        wordElements[currentWordIndex].classList.remove('active');
      }
      
      // Add highlight to current word
      if (newWordIndex >= 0 && newWordIndex < wordElements.length) {
        const wordEl = wordElements[newWordIndex];
        wordEl.classList.add('active');
        
        // Ensure word is visible
        const container = E.textBox;
        const wordTop = wordEl.offsetTop;
        const wordBottom = wordTop + wordEl.offsetHeight;
        const containerTop = container.scrollTop;
        const containerBottom = containerTop + container.offsetHeight;
        
        if (wordTop < containerTop + 30) {
          container.scrollTop = wordTop - 30;
        } else if (wordBottom > containerBottom - 30) {
          container.scrollTop = wordBottom - container.offsetHeight + 30;
        }
      }
      
      currentWordIndex = newWordIndex;
    }
  };

  // Progress bar click handler
  E.prog.onclick = e => {
    if (!totalDuration) return;
    
    const rect = E.prog.getBoundingClientRect();
    const ratio = (e.clientX - rect.left) / rect.width;
    const targetTime = ratio * totalDuration;
    
    log(`Progress bar clicked at ${ratio.toFixed(2)} (${targetTime.toFixed(2)}s)`);
    seekToTime(targetTime);
  };

  // Playback control buttons
  E.play.onclick = () => {
    if (paused) {
      resumePlayback();
    } else {
      startPlayback(0, 0, 0);
    }
  };
  
  E.pause.onclick = pausePlayback;
  E.stop.onclick = stopPlayback;

  // Create download link
  const createDownloadLink = () => {
    log('Creating download link');
    
    if (!audioBlobs.length) {
      log('No audio blobs to download', null, 'error');
      status('No audio available for download', true);
      return;
    }
    
    try {
      log(`Creating combined blob from ${audioBlobs.length} chunks`);
      
      // Create a single blob from all chunks
      const combinedBlob = new Blob(audioBlobs, { type: 'audio/mp3' });
      
      log(`Combined blob created: ${(combinedBlob.size / 1024 / 1024).toFixed(2)} MB`);
      
      // Create download link
      const url = URL.createObjectURL(combinedBlob);
      
      // Trigger download
      const a = document.createElement('a');
      const fileName = 'speech_' + new Date().toISOString().replace(/[:.]/g, '-') + '.mp3';
      a.href = url;
      a.download = fileName;
      
      log(`Triggering download: ${fileName}`);
      document.body.appendChild(a);
      a.click();
      
      // Clean up
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log('Download cleanup complete');
      }, 100);
      
      status('Download started', false);
    } catch (err) {
      log('Error creating download', err, 'error');
      status('Failed to create download: ' + err.message, true);
    }
  };
  
  // Download button
  E.download.onclick = createDownloadLink;

  // Generate speech
  E.gen.onclick = async () => {
    if (!API) return status('Load voices first', true);
    if (!E.voice.value) return status('Select a voice', true);
    
    try {
      // Initialize audio context and ensure it's running
      await initAudioContext();
      
      const text = E.txt.value.trim();
      if (!text) return status('Enter text', true);
      
      // Reset state
      stopPlayback();
      buffers = [];
      audioBlobs = [];
      audioSources = [];
      totalDuration = 0;
      loadedDuration = 0;
      loadingComplete = false;
      E.download.disabled = true;
      
      // Split text into chunks
      const chunks = splitText(text);
      if (!chunks.length) return status('Failed to split text', true);
      
      totalChunks = chunks.length;
      chunksReceived = 0;
      
      // Prepare UI
      status(`Processing ${chunks.length} chunk(s)...`);
      prepareTextDisplay(text, chunks);
      E.gen.disabled = true;
      
      // Initialize buffers array
      buffers = new Array(chunks.length);
      audioBlobs = new Array(chunks.length);
      
      // Create request body template
      const createRequest = chunk => ({
        input: { text: chunk },
        voice: {
          languageCode: E.voice.selectedOptions[0].dataset.l,
          name: E.voice.value
        },
        audioConfig: {
          audioEncoding: 'MP3',
          pitch: +E.pit.value,
          speakingRate: +E.rat.value
        }
      });
      
      // Process chunks
      // Start processing all chunks in parallel
      const chunkPromises = chunks.map(async (chunk, index) => {
        try {
          log(`Generating chunk ${index + 1}/${chunks.length} (${chunk.length} chars)`);
          
          const response = await fetchJSON(`${SY}?key=${API}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(createRequest(chunk))
          });
          
          if (!response.audioContent) {
            throw new Error(`No audio content in response for chunk ${index + 1}`);
          }
          
          log(`Received audio content for chunk ${index + 1}`);
          
          // Convert base64 to ArrayBuffer
          const audioData = atob(response.audioContent);
          const arrayBuffer = new Uint8Array(audioData.length);
          for (let i = 0; i < audioData.length; i++) {
            arrayBuffer[i] = audioData.charCodeAt(i);
          }
          
          // Store the audio blob for downloading (prevent detached buffer issue)
          const blob = new Blob([arrayBuffer], { type: 'audio/mp3' });
          audioBlobs[index] = blob;
          
          log(`Created blob for chunk ${index + 1}: ${(blob.size / 1024).toFixed(2)} KB`);
          
          // Create a copy of the array buffer for decoding
          // This is important to prevent the "detached ArrayBuffer" issue
          const bufferCopy = arrayBuffer.slice(0).buffer;
          
          // Decode audio
          try {
            const audioBuffer = await decodeBuffer(bufferCopy);
            
            // Store the decoded buffer
            buffers[index] = audioBuffer;
            
            // Update word timings with actual audio duration
            updateWordTimings(index, audioBuffer.duration);
            
            // Update durations
            loadedDuration += audioBuffer.duration;
            totalDuration += audioBuffer.duration;
            
            log(`Chunk ${index + 1} decoded: ${audioBuffer.duration.toFixed(2)}s`);
            
            // Update progress
            chunksReceived++;
            
            // Autoplay first chunk when it's ready
            if (index === 0 && !playing && !paused) {
              startPlayback(0, 0, 0);
            }
            
            return index;
          } catch (decodeError) {
            log(`Error decoding chunk ${index + 1}`, decodeError, 'error');
            throw new Error(`Failed to decode audio for chunk ${index + 1}: ${decodeError.message}`);
          }
        } catch (error) {
          log(`Error processing chunk ${index + 1}`, error, 'error');
          status(`Chunk ${index + 1} failed: ${error.message}`, true);
          return null;
        }
      });
      
      // Wait for all chunks to complete
      await Promise.all(chunkPromises);
      
      // Check if all chunks were processed successfully
      const success = chunksReceived === totalChunks;
      loadingComplete = true;
      
      if (success) {
        log('All chunks processed successfully', { totalDuration });
        status(`All chunks processed. Duration: ${fmt(totalDuration)}`, false);
        E.download.disabled = false;
      } else {
        log(`Some chunks failed (${chunksReceived}/${totalChunks})`, null, 'warn');
        status(`Completed ${chunksReceived}/${totalChunks} chunks`, true);
      }
    } catch (e) {
      log('Generation failed', e, 'error');
      status(`Generation failed: ${e.message}`, true);
    } finally {
      E.gen.disabled = false;
    }
  };
  
  // Add keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Don't trigger shortcuts when typing in inputs
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // Space - Play/Pause
    if (e.code === 'Space') {
      e.preventDefault();
      if (playing) E.pause.click();
      else if (paused || loadingComplete) E.play.click();
    }
    
    // Escape - Stop
    if (e.code === 'Escape' && (playing || paused)) {
      e.preventDefault();
      E.stop.click();
    }
    
    // G - Generate
    if (e.code === 'KeyG' && !E.gen.disabled) {
      e.preventDefault();
      E.gen.click();
    }
    
    // D - Download
    if (e.code === 'KeyD' && !E.download.disabled) {
      e.preventDefault();
      E.download.click();
    }
    
    // T - Toggle theme
    if (e.code === 'KeyT') {
      e.preventDefault();
      E.themeToggle.click();
    }
    
    // Left/Right arrow - Skip 5 seconds
    if (e.code === 'ArrowLeft' && (playing || paused)) {
      e.preventDefault();
      const currentTime = playing ? ctx.currentTime - startTime : pausedAt;
      seekToTime(Math.max(0, currentTime - 5));
    }
    if (e.code === 'ArrowRight' && (playing || paused)) {
      e.preventDefault();
      const currentTime = playing ? ctx.currentTime - startTime : pausedAt;
      seekToTime(Math.min(totalDuration, currentTime + 5));
    }
    
    // Up/Down arrow - Adjust volume
    if (e.code === 'ArrowUp') {
      e.preventDefault();
      E.volume.value = Math.min(1, parseFloat(E.volume.value) + 0.1);
      if (gainNode) gainNode.gain.value = E.volume.value;
    }
    if (e.code === 'ArrowDown') {
      e.preventDefault();
      E.volume.value = Math.max(0, parseFloat(E.volume.value) - 0.1);
      if (gainNode) gainNode.gain.value = E.volume.value;
    }
  });
  
  // Log initial state
  log('Application initialized', {
    version: '1.2.0',
    date: '2025-04-25',
    user: 'Doodle-Med',
    debugEnabled: debugEnabled
  });
});
</script>
<script src="voice-visualizer.js"></script>
</body>
</html>
