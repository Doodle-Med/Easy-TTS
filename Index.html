<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<!-- Ensure the onload callbacks are on the script tags -->
<script src="https://accounts.google.com/gsi/client" async defer onload="gisLoaded"></script>
<script src="https://apis.google.com/js/api.js" async defer onload="gapiLoaded"></script>
<script src="voice-visualizer.js"></script>
<style>
  /* ... your existing CSS ... */
</style>
</head>
<!-- Remove onload from body tag -->
<body>
  <h1>Google Cloud TTS Playground</h1>
  <!-- ... rest of your body content ... -->

  <script>
    // ... your existing JavaScript ...

    // ── OAuth setup ───────────────────────────────────────────────────────────
    const CLIENT_ID     = '879295177554-m3j1d2pks6lukl3h9cl92r953ef2jd4e.apps.googleusercontent.com'; // Your Client ID
    const DISCOVERY_DOC = 'https://texttospeech.googleapis.com/$discovery/rest?version=v1';
    const SCOPES        = 'https://www.googleapis.com/auth/cloud-platform';
    let tokenClient;
    let gapiInited = false; // Flag for GAPI client init
    let gisInited = false;  // Flag for GIS client init
    let accessToken = null; // Store the access token here

    // Called by <script src="…/js/api.js" onload="gapiLoaded">
    function gapiLoaded() {
      gapi.load('client', initializeGapiClient);
    }

    async function initializeGapiClient() {
      try {
        await gapi.client.init({ discoveryDocs: [DISCOVERY_DOC] });
        gapiInited = true;
        // Attempt to enable Sign In button if both are ready
        tryEnableSignIn();
      } catch (error) {
        console.error("Error initializing GAPI client:", error);
        log("Error initializing GAPI client", error, 'error');
        status("Error initializing Google API Client.", true);
      }
    }

    // Called by <script src="…/gsi/client" onload="gisLoaded">
    function gisLoaded() {
      try {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: (resp) => { // Arrow function for 'this' safety
            if (resp.error) {
              console.error('OAuth error', resp);
              log(`OAuth Error: ${resp.error}`, resp, 'error');
              status(`OAuth failed: ${resp.error}`, true);
              accessToken = null;
              if (E && E.authStatus) E.authStatus.textContent = '❌ Sign-in failed';
              if (E && E.load) E.load.disabled = true; // Keep Load Voices disabled
              // Maybe disable generate too?
              if (E && E.gen) E.gen.disabled = true;
              return;
            }
            accessToken = resp.access_token;
            log('OAuth successful, access token obtained.');
             // Ensure E is defined before accessing its properties
            if (E && E.authStatus) E.authStatus.textContent = '✅ Signed in';
            if (E && E.load) {
              E.load.disabled = false; // Enable Load Voices button
              // Auto-load voices once signed in
              E.load.click();
            }
          },
        });
        gisInited = true;
        // Attempt to enable Sign In button if both are ready
        tryEnableSignIn();
      } catch (error) {
          console.error("Error initializing GIS client:", error);
          log("Error initializing Google Sign-In", error, 'error');
          status("Error initializing Google Sign-In.", true);
      }
    }

    // Helper function to enable Sign In button only when both libraries are ready
    function tryEnableSignIn() {
        // Ensure E and E.signInBtn are available before trying to enable
        if (gapiInited && gisInited && window.E && window.E.signInBtn) {
            log("Both GAPI and GIS initialized. Enabling Sign In button.");
            window.E.signInBtn.disabled = false;
        } else {
             log(`tryEnableSignIn check: gapiInited=${gapiInited}, gisInited=${gisInited}, E=${!!window.E}, E.signInBtn=${!!(window.E && window.E.signInBtn)}`);
        }
    }
    // ─────────────────────────────────────────────────────────────────────────────


    window.addEventListener('DOMContentLoaded', () => {
      // API endpoints & DOM elements
      const VO = 'https://texttospeech.googleapis.com/v1/voices';
      const SY = 'https://texttospeech.googleapis.com/v1/text:synthesize';
      const Q = id => document.getElementById(id);
      // Define E *inside* DOMContentLoaded
      window.E = { // Make E global or pass it around if needed by callbacks outside
        signInBtn: Q('signInBtn'),
        authStatus: Q('authStatus'),
        load: Q('ld'),
        loading: Q('loading'),
        txt: Q('txt'),
        voice: Q('v'),
        pit: Q('pit'),
        rat: Q('rat'),
        pitVal: Q('pitVal'),
        ratVal: Q('ratVal'),
        chk: Q('chk'),
        chkVal: Q('chkVal'),
        gen: Q('gen'),
        stat: Q('stat'),
        methodBtns: [...Q('method').children],
        textBox: Q('text'),
        play: Q('play'),
        pause: Q('pause'),
        stop: Q('stop'),
        volume: Q('volume'),
        download: Q('download'),
        prog: Q('prog'),
        fill: Q('fill'),
        time: Q('time'),
        toggleDebug: Q('toggleDebug'),
        debugPanel: Q('debugPanel'),
        themeToggle: Q('themeToggle')
      };

      // Disable sign-in button initially - it will be enabled by tryEnableSignIn
      E.signInBtn.disabled = true;
      // Initial UI state after setup
      E.play.disabled = true;
      E.pause.disabled = true;
      E.stop.disabled = true;
      E.download.disabled = true;
      E.gen.disabled = true; // Keep Generate disabled until voices loaded
      E.voice.disabled = true; // Keep voice disabled until loaded
      E.load.disabled = true; // Keep Load disabled until signed in

      // Debug logging setup...
      let debugEnabled = localStorage.getItem('debugEnabled') === 'true';
      const maxDebugEntries = 100;
      let debugEntries = [];

      // Theme toggle setup...
      let isDarkMode = localStorage.getItem('darkMode') === 'true';
      if (isDarkMode) {
        document.documentElement.setAttribute('data-theme', 'dark');
      }
      E.themeToggle.addEventListener('click', () => {
        isDarkMode = !isDarkMode;
        document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
        localStorage.setItem('darkMode', isDarkMode);
        log(`Theme changed to ${isDarkMode ? 'dark' : 'light'} mode`);
      });

      // Toggle debug panel setup...
       E.toggleDebug.addEventListener('click', () => {
         debugEnabled = !debugEnabled;
         localStorage.setItem('debugEnabled', debugEnabled);
         E.debugPanel.classList.toggle('hidden', !debugEnabled);
         E.toggleDebug.textContent = debugEnabled ? 'Hide Debug Info' : 'Show Debug Info';
         if (debugEnabled) {
           updateDebugPanel();
         }
       });
       if (debugEnabled) {
         E.debugPanel.classList.remove('hidden');
         E.toggleDebug.textContent = 'Hide Debug Info';
       }

      // Enhanced logging function...
       const log = (message, data = null, level = 'info') => {
         const timestamp = new Date().toISOString();
         const entry = { timestamp, message, data, level };
         debugEntries.unshift(entry);
         if (debugEntries.length > maxDebugEntries) debugEntries.pop();
         switch(level) {
           case 'error': console.error(`[${timestamp}] ${message}`, data); break;
           case 'warn': console.warn(`[${timestamp}] ${message}`, data); break;
           default: console.log(`[${timestamp}] ${message}`, data);
         }
         if (debugEnabled && E && E.debugPanel) { // Check if E.debugPanel exists
           updateDebugPanel();
         }
       };

      // Update debug panel function...
       const updateDebugPanel = () => {
         if (!E || !E.debugPanel) return; // Ensure elements are ready
         E.debugPanel.innerHTML = debugEntries.map(entry => {
           const timeStr = new Date(entry.timestamp).toLocaleTimeString();
           let dataStr = '';
           if (entry.data !== null) {
             try {
               dataStr = `<div class="debug-data">${JSON.stringify(entry.data)}</div>`;
             } catch (e) { dataStr = `<div class="debug-data">[Complex Object]</div>`; }
           }
           return `<div class="debug-entry ${entry.level}"><span class="debug-time">${timeStr}</span> <span class="debug-msg">${entry.message}</span>${dataStr}</div>`;
         }).join('');
       };

      // App state...
      let ctx;
      let gainNode;
      let voices = [];
      let buffers = [];
      let audioBlobs = [];
      let audioSources = [];
      let wordElements = [];
      let wordTimings = [];
      let totalDuration = 0;
      let loadedDuration = 0;
      let startTime = 0;
      let pausedAt = 0;
      let playbackId = 0;
      let playing = false;
      let paused = false;
      let method = 'paragraph';
      let currentWordIndex = -1;
      let loadingComplete = false;
      let chunksReceived = 0;
      let totalChunks = 0;
      let chunksData = [];
      let visualizer;

      // Utilities...
      const fmt = s => `${String(Math.floor(s/60)).padStart(2, '0')}:${String(Math.floor(s%60)).padStart(2, '0')}`;
      const status = (m, isError) => {
        if (!E || !E.stat) return; // Ensure element ready
        E.stat.textContent = m;
        E.stat.className = 'status' + (isError ? ' error' : isError === false ? ' success' : '');
        log(m, null, isError ? 'error' : 'info');
      };
       const fetchJSON = async (url, opts) => {
         try {
           log(`Fetching ${url}`, opts);
           // Ensure Authorization header is present if accessToken exists
           if (accessToken && opts && opts.headers && !opts.headers['Authorization']) {
               opts.headers['Authorization'] = 'Bearer ' + accessToken;
           } else if (accessToken && opts && !opts.headers) {
               opts.headers = { 'Authorization': 'Bearer ' + accessToken };
           } else if (accessToken && !opts) {
               opts = { headers: { 'Authorization': 'Bearer ' + accessToken } };
           }

           const r = await fetch(url, opts);
           if (!r.ok) {
             let m = `HTTP ${r.status}`;
             try {
               const errorData = await r.json();
               m = errorData.error?.message || m;
               log('API Error', errorData, 'error');
             } catch (e) { log('Failed to parse error response', e, 'error'); }
             throw new Error(m);
           }
           const data = await r.json();
           log(`Fetch completed successfully`, { url });
           return data;
         } catch (e) {
           log('Fetch error', e, 'error');
           throw e;
         }
       };


      // UI event binding...
      ['pit', 'rat', 'chk'].forEach(id => {
        if (E[id]) E[id].addEventListener('input', e => {
           const span = E[`${id}Val`];
           if (span) span.textContent = id === 'rat' ? parseFloat(e.target.value).toFixed(2) : e.target.value;
        });
      });
      if (E.volume) E.volume.addEventListener('input', () => { if (gainNode) gainNode.gain.value = E.volume.value; });

      // Sign in button click handler...
       if (E.signInBtn) E.signInBtn.onclick = () => {
         if (!tokenClient) {
           log('Token client not initialized yet.', null, 'warn');
           status('Initialization in progress, please wait...', true);
           return;
         }
         log('Requesting access token...');
         // Use 'consent' to ensure user sees the picker if multiple accounts or needs to re-consent
         tokenClient.requestAccessToken({ prompt: 'consent' });
       };

      // Load Voices button click handler...
       if (E.load) E.load.onclick = async () => {
         if (!accessToken) {
           status('Please sign in first to load voices.', true);
           if (tokenClient) tokenClient.requestAccessToken({ prompt: 'consent' });
           else status('Authentication system not ready.', true);
           return;
         }
         E.loading.classList.remove('hidden');
         E.load.disabled = true;
         E.gen.disabled = true;
         status('Loading voices...');
         try {
           log(`Requesting voices from ${VO} using OAuth token.`);
           const d = await fetchJSON(VO, { // fetchJSON adds the token header
               method: 'GET'
               // No need to manually add header here if fetchJSON handles it
           });
           voices = d.voices || [];
           if (!voices.length) throw new Error('No voices returned from API');
           log(`Loaded ${voices.length} voices`);
           // ... (rest of voice parsing logic is ok) ...
           const langMap = new Map();
           voices.forEach(v => v.languageCodes.forEach(code => {
             let name = code; try { name = new Intl.DisplayNames(['en'], { type: 'language' }).of(code); } catch (e) {}
             if (!langMap.has(code)) langMap.set(code, { name, voices: [] });
             langMap.get(code).voices.push(v);
           }));
           const sortedLangs = [...langMap.entries()].sort((a, b) => a[1].name.localeCompare(b[1].name));
           E.voice.innerHTML = sortedLangs.map(([code, { name, voices }]) => `<optgroup label="${name}">${voices.sort((a, b) => a.name.localeCompare(b.name)).map(v => `<option value="${v.name}" data-l="${code}">${v.name} ${v.name.includes('Neural') || v.name.includes('Wavenet') ? '(Neural)' : ''}</option>`).join('')}</optgroup>`).join('');
           E.voice.disabled = false;
           E.gen.disabled = false;
           status('Voices loaded successfully', false);
         } catch (e) {
           status(`Failed to load voices: ${e.message}`, true);
           log('Error loading voices', e, 'error');
           if (e.message.includes('401') || e.message.includes('403')) {
             accessToken = null; E.authStatus.textContent = '⚠️ Re-authentication needed'; E.load.disabled = true;
           }
         } finally {
           E.loading.classList.add('hidden');
           E.load.disabled = !accessToken; // Re-enable only if still signed in
         }
       };

      // Method toggle buttons...
      if (E.methodBtns) E.methodBtns.forEach(b => b.onclick = () => {
         E.methodBtns.forEach(x => x.classList.remove('active'));
         b.classList.add('active'); method = b.dataset.m;
         log(`Splitting method changed to: ${method}`);
      });

      // Split text function (unchanged)...
       const splitText = t => { /* ...unchanged... */ };

      // Decode buffer function (unchanged)...
       const decodeBuffer = a => { /* ...unchanged... */ };

      // Prepare text display function (unchanged, relies on E)...
       const prepareTextDisplay = (text, chunks) => { /* ...unchanged... */ };

      // Update word timings function (unchanged, relies on E)...
       const updateWordTimings = (chunkIndex, duration) => { /* ...unchanged... */ };

      // Locate time position function (unchanged)...
       const locateTimePosition = (time) => { /* ...unchanged... */ };

      // Seek to time function (unchanged)...
       const seekToTime = (time) => { /* ...unchanged... */ };

      // Seek to word function (unchanged, relies on E)...
       const seekToWord = (wordIndex) => { /* ...unchanged... */ };

      // Init audio context function (unchanged, relies on Q, E)...
       const initAudioContext = () => { /* ...unchanged... */ };

      // Start playback function (unchanged, relies on E)...
       const startPlayback = (chunkIndex, offset = 0, absoluteTime = 0) => { /* ...unchanged... */ };

      // Play chunk function (unchanged)...
       const playChunk = (index, offset = 0, id) => { /* ...unchanged... */ };

      // Cancel playback function (unchanged)...
       const cancelPlayback = () => { /* ...unchanged... */ };

      // Pause playback function (unchanged, relies on E)...
       const pausePlayback = () => { /* ...unchanged... */ };

      // Resume playback function (unchanged)...
       const resumePlayback = () => { /* ...unchanged... */ };

      // Stop playback function (unchanged, relies on E)...
       const stopPlayback = (silent = false) => { /* ...unchanged... */ };

      // Update playback UI function (unchanged, relies on E)...
       const updatePlayback = () => { /* ...unchanged... */ };

      // Update UI function (unchanged, relies on E)...
       const updateUI = (time) => { /* ...unchanged... */ };

      // Update word highlight function (unchanged, relies on E)...
       const updateWordHighlight = (time) => { /* ...unchanged... */ };

      // Progress bar click handler (unchanged, relies on E)...
      if (E.prog) E.prog.onclick = e => { /* ...unchanged... */ };

      // Playback control buttons (unchanged, rely on E)...
      if (E.play) E.play.onclick = () => { /* ...unchanged... */ };
      if (E.pause) E.pause.onclick = pausePlayback;
      if (E.stop) E.stop.onclick = () => stopPlayback(false);

      // Create download link function (unchanged)...
       const createDownloadLink = () => { /* ...unchanged... */ };
      if (E.download) E.download.onclick = createDownloadLink;


      // Generate speech button click handler...
       if (E.gen) E.gen.onclick = async () => {
         if (!accessToken) {
           status('Please sign in first to generate speech.', true);
           if (tokenClient) tokenClient.requestAccessToken({ prompt: 'consent' });
           else status('Authentication system not ready.', true);
           return;
         }
         if (!E.voice.value) return status('Select a voice first (Load Voices if needed).', true);
         try {
           await initAudioContext();
           const text = E.txt.value.trim();
           if (!text) return status('Enter text to synthesize.', true);
           stopPlayback(true);
           buffers = []; audioBlobs = []; audioSources = []; wordTimings = []; chunksData = [];
           totalDuration = 0; loadedDuration = 0; loadingComplete = false;
           E.download.disabled = true; E.play.disabled = true; E.pause.disabled = true; E.stop.disabled = true;
           const chunks = splitText(text);
           if (!chunks.length) return status('Failed to split text into processable chunks.', true);
           totalChunks = chunks.length; chunksReceived = 0;
           status(`Requesting synthesis for ${chunks.length} chunk(s)...`);
           prepareTextDisplay(text, chunks);
           E.gen.disabled = true; E.load.disabled = true;
           buffers = new Array(chunks.length).fill(null);
           audioBlobs = new Array(chunks.length).fill(null);
           const createRequest = chunk => ({
             input: { text: chunk },
             voice: { languageCode: E.voice.selectedOptions[0].dataset.l, name: E.voice.value },
             audioConfig: { audioEncoding: 'MP3', pitch: +E.pit.value, speakingRate: +E.rat.value }
           });

           const chunkPromises = chunks.map(async (chunk, index) => {
             try {
               log(`Generating chunk ${index + 1}/${chunks.length}`);
               // fetchJSON should add the token header automatically now
               const response = await fetchJSON(SY, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' }, // fetchJSON adds Auth
                 body: JSON.stringify(createRequest(chunk))
               });
               if (!response.audioContent) throw new Error(`No audio content in response for chunk ${index + 1}`);
               log(`Received audio content for chunk ${index + 1}`);
               const audioData = atob(response.audioContent);
               const arrayBuffer = new Uint8Array(audioData.length);
               for (let i = 0; i < audioData.length; i++) arrayBuffer[i] = audioData.charCodeAt(i);
               const blob = new Blob([arrayBuffer], { type: 'audio/mp3' });
               audioBlobs[index] = blob;
               log(`Created blob for chunk ${index + 1}: ${(blob.size / 1024).toFixed(2)} KB`);
               const bufferCopy = arrayBuffer.buffer.slice(0);
               try {
                 const audioBuffer = await decodeBuffer(bufferCopy);
                 buffers[index] = audioBuffer;
                 updateWordTimings(index, audioBuffer.duration);
                 loadedDuration = chunksData.reduce((sum, cd) => sum + (cd.loaded ? cd.duration : 0), 0);
                 totalDuration = loadedDuration; // Intermediate update
                 log(`Chunk ${index + 1} decoded: ${audioBuffer.duration.toFixed(2)}s. Loaded duration: ${loadedDuration.toFixed(2)}s`);
                 chunksReceived++;
                 status(`Processing... ${chunksReceived}/${totalChunks} chunks loaded. (${fmt(loadedDuration)} loaded)`);
                 if (index === 0 && !playing && !paused) {
                   E.play.disabled = false; E.stop.disabled = false; startPlayback(0, 0, 0);
                 } else if (index > 0 && !playing && !paused && buffers[0]) {
                   E.play.disabled = false; E.stop.disabled = false;
                 }
                 return index;
               } catch (decodeError) {
                 log(`Error decoding chunk ${index + 1}`, decodeError, 'error');
                 if (chunksData[index]) chunksData[index].loaded = false;
                 throw new Error(`Failed to decode audio for chunk ${index + 1}: ${decodeError.message}`);
               }
             } catch (error) {
               log(`Error processing chunk ${index + 1}`, error, 'error');
               if (error.message.includes('401') || error.message.includes('403')) {
                 accessToken = null; E.authStatus.textContent = '⚠️ Re-authentication needed'; E.load.disabled = true;
                 status(`Chunk ${index + 1} failed: Authentication error. Please sign in again.`, true);
               } else {
                 status(`Chunk ${index + 1} failed: ${error.message}`, true);
               }
               if (chunksData[index]) chunksData[index].loaded = false;
               return null;
             }
           });

           await Promise.allSettled(chunkPromises);
           loadingComplete = true;
           totalDuration = chunksData.reduce((sum, cd) => sum + (cd.loaded ? cd.duration : 0), 0);
           log(`All chunks settled. Final total duration: ${totalDuration.toFixed(2)}s`);
           updateUI(playing ? ctx.currentTime - startTime : pausedAt);
           const successCount = chunksData.filter(c => c.loaded).length;
           if (successCount === totalChunks) {
             status(`Synthesis complete. Total duration: ${fmt(totalDuration)}`, false);
             E.download.disabled = false;
           } else {
             status(`Completed ${successCount}/${totalChunks} chunks. Total duration: ${fmt(totalDuration)}`, successCount > 0);
             if (successCount > 0) E.download.disabled = false;
           }
         } catch (e) {
           log('Generation process failed', e, 'error');
           status(`Generation failed: ${e.message}`, true);
         } finally {
           E.gen.disabled = false;
           E.load.disabled = !accessToken;
           if (!playing && !paused) {
             E.play.disabled = !(totalDuration > 0); E.pause.disabled = true; E.stop.disabled = true;
           }
         }
       };


      // Keyboard shortcuts (unchanged, relies on E)...
       document.addEventListener('keydown', (e) => { /* ...unchanged... */ });

      // Log initial state...
      log('Application initialized - OAuth Version', { version: '1.3.1-oauth-fix', date: '2025-04-26', user: 'Doodle-Med', debugEnabled: debugEnabled });


    }); // End DOMContentLoaded
  </script>
</body>
</html>
