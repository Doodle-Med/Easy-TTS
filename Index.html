<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<style>
:root{--c1:#4285f4;--c2:#34a853;--c3:#ea4335;--c4:#fbbc04;--bg:#fdfdfd;--fg:#202124;--bd:#dadce0;--r:10px}
*{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif}
body{background:var(--bg);color:var(--fg);padding:1rem;max-width:1200px;margin:auto}
h1{font-size:clamp(1.7rem,2.5vw,3rem);text-align:center;margin-bottom:1rem;background:linear-gradient(90deg,var(--c1),var(--c2),var(--c4),var(--c3));-webkit-background-clip:text;color:transparent;font-weight:800}
.grid{display:grid;gap:1rem}.two{grid-template-columns:1fr 1fr}@media(max-width:800px){.two{grid-template-columns:1fr}}
.card{background:#fff;border:1px solid var(--bd);border-radius:var(--r);box-shadow:0 4px 12px rgba(0,0,0,.05);padding:1.2rem;position:relative}
.card:hover::after{box-shadow:inset 0 0 0 2px var(--c1)}
label{font-weight:600;margin:.6rem 0 .3rem;display:block}
input,select,textarea,button{width:100%;padding:.55rem .65rem;border:1px solid var(--bd);border-radius:6px;font-size:1rem;margin-bottom:.8rem}
input:focus,select:focus,textarea:focus{border-color:var(--c1);outline:none}
textarea{resize:vertical;min-height:140px}
button{cursor:pointer;background:var(--c1);color:#fff;border:none;font-weight:600}
button:not(:disabled):hover{background:#3367d6}
button:disabled{background:var(--bd)}
.small-btn{width:auto}
.toggle{display:flex;gap:.5rem;margin:.6rem 0}.toggle button{flex:1;background:var(--bg);border:1px solid var(--bd)}
.toggle .active{background:var(--c2);color:#fff;border-color:var(--c2)}
.status{min-height:1.4em;font-size:.95rem;margin:.5rem 0}.error{color:var(--c3);font-weight:700}
.bar{height:12px;background:var(--bd);border-radius:6px;overflow:hidden;cursor:pointer;margin:.8rem 0}
.fill{height:100%;background:linear-gradient(90deg,var(--c1),var(--c2));width:0}
.audio{display:flex;align-items:center;gap:.6rem}
.audio button{width:44px;border-radius:50%;aspect-ratio:1/1;font-size:1.1rem;display:grid;place-items:center}
.time{font-family:monospace;margin-left:auto}
.text-box{background:#fff;border:1px solid var(--bd);border-radius:var(--r);padding:1rem;max-height:340px;overflow:auto;line-height:1.6}
.word{display:inline-block;cursor:pointer;border-radius:3px;padding:1px 2px}
.word:hover{background:#f1f3f4}
.word.active{background:rgba(66,133,244,.25);color:var(--c1);font-weight:700}
.word.loading{background:#f1f3f4;cursor:wait;opacity:0.6}
.unloadable{opacity:0.5;cursor:not-allowed}
.debug{font-family:monospace;font-size:12px;background:#f5f5f5;border-radius:4px;padding:10px;margin-top:10px;max-height:100px;overflow:auto}
.spinner{display:inline-block;width:14px;height:14px;border:2px solid rgba(0,0,0,0.1);border-radius:50%;border-top-color:var(--c1);animation:spin 0.8s linear infinite;margin-right:5px}
@keyframes spin{to{transform:rotate(360deg)}}
.hidden{display:none}
</style>
</head>
<body>
<h1>Google Cloud TTS Playground</h1>
<div class="grid two">
  <div class="card">
    <h2>üéõÔ∏è Config</h2>
    <label>API Key</label>
    <input id="k" type="password"/>
    <button class="small-btn" id="ld">Load Voices</button>
    <div id="loading" class="status hidden"><span class="spinner"></span>Loading voices...</div>
    
    <label>Text</label>
    <textarea id="txt" placeholder="Type or paste‚Ä¶"></textarea>
    
    <label>Voice</label>
    <select id="v" disabled></select>
    
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:.8rem">
      <div>
        <label>Pitch <span id="pitVal">0</span></label>
        <input id="pit" type="range" min="-20" max="20" value="0"/>
      </div>
      <div>
        <label>Rate <span id="ratVal">1</span></label>
        <input id="rat" type="range" min="0.25" max="4" step="0.05" value="1"/>
      </div>
    </div>
    
    <label>Chunk Size <span id="chkVal">800</span></label>
    <input id="chk" type="range" min="500" max="4500" step="500" value="800"/>
    
    <div class="toggle" id="method">
      <button data-m="sentence">Sentence</button>
      <button data-m="paragraph" class="active">Paragraph</button>
      <button data-m="exact">Exact</button>
    </div>
    
    <button id="gen" disabled>üé§ Generate & Play</button>
    <div id="stat" class="status"></div>
    <div id="debug" class="debug hidden"></div>
  </div>
  
  <div class="card">
    <h2>üîä Playback</h2>
    <div id="text" class="text-box"><p style="opacity:.6">Words will appear here‚Ä¶</p></div>
    
    <div class="bar" id="prog">
      <div class="fill" id="fill"></div>
    </div>
    
    <div class="audio">
      <button class="small-btn" id="play" disabled title="Replay">‚ñ∂</button>
      <button class="small-btn" id="pause" disabled title="Pause">‚è∏</button>
      <button class="small-btn" id="stop" disabled title="Stop">‚èπ</button>
      <span class="time" id="time">00:00 / 00:00</span>
    </div>
    <label><input type="checkbox" id="showDebug"> Show Debug Info</label>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  // API endpoints & DOM elements
  const VO = 'https://texttospeech.googleapis.com/v1/voices';
  const SY = 'https://texttospeech.googleapis.com/v1/text:synthesize';
  const Q = id => document.getElementById(id);
  const E = {
    key: Q('k'),
    load: Q('ld'),
    loading: Q('loading'),
    txt: Q('txt'),
    voice: Q('v'),
    pit: Q('pit'),
    rat: Q('rat'),
    pitVal: Q('pitVal'),
    ratVal: Q('ratVal'),
    chk: Q('chk'),
    chkVal: Q('chkVal'),
    gen: Q('gen'),
    stat: Q('stat'),
    methodBtns: [...Q('method').children],
    textBox: Q('text'),
    play: Q('play'),
    pause: Q('pause'),
    stop: Q('stop'),
    prog: Q('prog'),
    fill: Q('fill'),
    time: Q('time'),
    debug: Q('debug'),
    showDebug: Q('showDebug')
  };

  // App state
  let API = '';
  let ctx;
  let voices = [];
  let buffers = [];
  let rawBuffers = []; // For downloading if added later
  let audioSources = []; // Track all audio sources
  let wordElements = []; // Store word elements for efficient lookup
  let wordOffsets = []; // Track which chunk each word belongs to
  let totalDuration = 0; // Total final duration
  let loadedDuration = 0; // Duration of loaded chunks so far
  let startTime = 0; // When playback started
  let pausedAt = 0; // Where we paused
  let playbackId = 0; // Used to cancel stale playback
  let playing = false;
  let paused = false;
  let method = 'paragraph';
  let currentWordIndex = -1;
  let loadingComplete = false;
  let chunksReceived = 0;
  let totalChunks = 0;

  // Utilities
  const fmt = s => `${String(Math.floor(s/60)).padStart(2, '0')}:${String(Math.floor(s%60)).padStart(2, '0')}`;
  
  const status = (m, e) => {
    E.stat.textContent = m;
    E.stat.className = 'status' + (e ? ' error' : '');
    log(e ? `Error: ${m}` : m);
  };
  
  const log = (message, data) => {
    console.log(message, data || '');
    
    if (E.showDebug.checked) {
      const time = new Date().toLocaleTimeString();
      const logLine = document.createElement('div');
      logLine.textContent = `[${time}] ${message}`;
      E.debug.appendChild(logLine);
      
      // Keep max 50 lines
      while (E.debug.childElementCount > 50) {
        E.debug.removeChild(E.debug.firstChild);
      }
      
      E.debug.scrollTop = E.debug.scrollHeight;
      E.debug.classList.remove('hidden');
    }
  };
  
  // JSON fetch helper with error handling
  const fetchJSON = async (url, opts) => {
    try {
      const r = await fetch(url, opts);
      if (!r.ok) {
        let m = `HTTP ${r.status}`;
        try {
          const errorData = await r.json();
          m = errorData.error?.message || m;
          log('API Error', errorData);
        } catch (e) {
          log('Failed to parse error response', e);
        }
        throw new Error(m);
      }
      return r.json();
    } catch (e) {
      log('Fetch error:', e);
      throw e;
    }
  };

  // UI event binding
  ['pit', 'rat', 'chk'].forEach(id => {
    E[id].addEventListener('input', e => {
      const span = E[`${id}Val`];
      if (span) {
        const val = id === 'rat' ? parseFloat(e.target.value).toFixed(2) : e.target.value;
        span.textContent = val;
      }
    });
  });

  // Load voices from Google TTS API
  E.load.onclick = async () => {
    API = E.key.value.trim();
    if (!API) return status('API key required', true);
    
    E.loading.classList.remove('hidden');
    E.load.disabled = true;
    status('Loading voices...');
    
    try {
      log(`Requesting voices from ${VO}`);
      const d = await fetchJSON(`${VO}?key=${API}`);
      voices = d.voices || [];
      
      if (!voices.length) throw new Error('No voices returned');
      
      log(`Loaded ${voices.length} voices`);
      
      // Group voices by language
      const langMap = new Map();
      voices.forEach(v => {
        v.languageCodes.forEach(code => {
          let name;
          try {
            name = new Intl.DisplayNames(['en'], { type: 'language' }).of(code);
          } catch (e) {
            name = code;
          }
          
          if (!langMap.has(code)) {
            langMap.set(code, { name, voices: [] });
          }
          langMap.get(code).voices.push(v);
        });
      });
      
      // Sort languages by name
      const sortedLangs = [...langMap.entries()]
        .sort((a, b) => a[1].name.localeCompare(b[1].name));
      
      // Group options by language
      const html = sortedLangs.map(([code, { name, voices }]) => {
        const options = voices
          .sort((a, b) => a.name.localeCompare(b.name))
          .map(v => `<option value="${v.name}" data-l="${code}">${v.name} (${v.ssmlGender})</option>`)
          .join('');
        
        return `<optgroup label="${name}">${options}</optgroup>`;
      }).join('');
      
      E.voice.innerHTML = html;
      E.voice.disabled = false;
      E.gen.disabled = false;
      
      status('Voices loaded successfully');
    } catch (e) {
      status(`Failed to load voices: ${e.message}`, true);
    } finally {
      E.loading.classList.add('hidden');
      E.load.disabled = false;
    }
  };

  // Configure chunk splitting method
  E.methodBtns.forEach(b => b.onclick = () => {
    E.methodBtns.forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    method = b.dataset.m;
    log(`Splitting method changed to: ${method}`);
  });

  // Split text into chunks based on selected method
  const splitText = t => {
    const m = +E.chk.value;
    if (t.length <= m) return [t];
    
    if (method === 'exact') {
      const a = [];
      for (let i = 0; i < t.length; i += m) {
        a.push(t.slice(i, i + m));
      }
      return a;
    }
    
    const re = method === 'paragraph' ? /\n\s*\n/ : /([.!?]+["']?\s+)/;
    const bits = t.split(re).filter(Boolean);
    const out = [];
    let cur = '';
    
    for (const p of bits) {
      if ((cur + p).length > m) {
        if (cur.trim()) out.push(cur.trim());
        cur = '';
        
        if (p.length > m) {
          let q = p;
          while (q.length > m) {
            out.push(q.slice(0, m));
            q = q.slice(m);
          }
          cur = q;
        } else {
          cur = p;
        }
      } else {
        cur += p;
      }
    }
    
    if (cur.trim()) out.push(cur.trim());
    
    log(`Split into ${out.length} chunks using ${method} method`, {
      chunkSizes: out.map(c => c.length)
    });
    
    return out;
  };

  // Decode audio buffer
  const decodeBuffer = a => new Promise((res, rej) => ctx.decodeAudioData(a, res, rej));

  // Prepare text display with clickable words
  const prepareTextDisplay = (text, chunks) => {
    E.textBox.innerHTML = '';
    wordElements = [];
    wordOffsets = [];
    
    let globalWordIndex = 0;
    let currentChunk = 0;
    let chunkStart = 0;
    let chunkEnd = chunks[0]?.length || 0;
    
    // Split text into words and spaces
    text.split(/(\s+)/).forEach((part, i) => {
      if (part.trim()) {
        // This is a word (not whitespace)
        const span = document.createElement('span');
        span.textContent = part;
        span.className = 'word loading'; // Start as loading
        span.dataset.index = globalWordIndex;
        
        // Track which chunk this word belongs to
        while (i > chunkEnd && currentChunk < chunks.length - 1) {
          currentChunk++;
          chunkStart = chunkEnd;
          chunkEnd += chunks[currentChunk].length;
        }
        
        span.dataset.chunk = currentChunk;
        wordOffsets[globalWordIndex] = currentChunk;
        
        span.addEventListener('click', () => {
          if (span.classList.contains('loading')) {
            status('That part is still loading...', false);
            return;
          }
          seekToWord(globalWordIndex);
        });
        
        wordElements.push(span);
        E.textBox.appendChild(span);
        globalWordIndex++;
      } else {
        // This is whitespace
        E.textBox.appendChild(document.createTextNode(part));
      }
    });
    
    log(`Prepared text display with ${globalWordIndex} words`);
  };

  // Find which chunk and offset to play for a given time
  const locateTimePosition = (time) => {
    let currentTime = 0;
    
    // Handle case where time is beyond loaded duration
    if (time >= loadedDuration) {
      const lastIndex = buffers.findLastIndex(b => b);
      return { chunk: lastIndex === -1 ? 0 : lastIndex, offset: 0 };
    }
    
    // Find the chunk that contains this time
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      if (!buffer) continue; // Skip unloaded chunks
      
      const duration = buffer.duration;
      if (time < currentTime + duration) {
        return { chunk: i, offset: time - currentTime };
      }
      
      currentTime += duration;
    }
    
    // Fallback to beginning of last loaded chunk
    const lastLoaded = buffers.findLastIndex(b => b);
    return { chunk: lastLoaded === -1 ? 0 : lastLoaded, offset: 0 };
  };

  // Seek to a specific time
  const seekToTime = (time) => {
    if (!buffers.some(b => b)) return;
    
    // Ensure time is within valid range
    time = Math.max(0, Math.min(time, loadedDuration));
    
    log(`Seeking to ${time.toFixed(2)}s`);
    
    // Find the chunk this time belongs to
    const { chunk, offset } = locateTimePosition(time);
    
    // Cancel any current playback
    cancelPlayback();
    
    if (paused) {
      // Just update the paused position
      pausedAt = time;
      updateUI(time);
    } else {
      // Start playback from this position
      startPlayback(chunk, offset, time);
    }
  };

  // Seek to a specific word
  const seekToWord = (wordIndex) => {
    if (!buffers.some(b => b) || wordIndex < 0 || wordIndex >= wordElements.length) return;
    
    // Make sure the corresponding chunk is loaded
    const chunkIndex = wordOffsets[wordIndex];
    if (chunkIndex === undefined || !buffers[chunkIndex]) {
      log(`Word ${wordIndex} is in chunk ${chunkIndex} which is not loaded yet`);
      return;
    }
    
    // Calculate time based on word position in text
    const time = estimateTimeForWord(wordIndex);
    log(`Seeking to word ${wordIndex} at estimated time ${time.toFixed(2)}s`);
    
    seekToTime(time);
  };

  // Estimate time for a word
  const estimateTimeForWord = (wordIndex) => {
    if (wordIndex < 0 || wordIndex >= wordElements.length) return 0;
    
    // Get the chunk this word belongs to
    const chunkIndex = wordOffsets[wordIndex];
    if (chunkIndex === undefined) return 0;
    
    // Find all words in this chunk
    const wordsInChunk = wordElements.filter((_, i) => wordOffsets[i] === chunkIndex);
    if (!wordsInChunk.length) return 0;
    
    // Get base time (start of chunk)
    let baseTime = 0;
    for (let i = 0; i < chunkIndex; i++) {
      if (buffers[i]) baseTime += buffers[i].duration;
    }
    
    // If we don't have this chunk loaded, estimate based on overall
    if (!buffers[chunkIndex]) {
      return baseTime;
    }
    
    // Find position of word within its chunk
    const chunkWords = wordElements.filter((_, i) => wordOffsets[i] === chunkIndex);
    const indexInChunk = chunkWords.findIndex(el => +el.dataset.index === wordIndex);
    
    if (indexInChunk === -1) return baseTime;
    
    // Calculate offset within chunk
    const chunkDuration = buffers[chunkIndex].duration;
    const offsetInChunk = chunkDuration * (indexInChunk / chunkWords.length);
    
    return baseTime + offsetInChunk;
  };

  // Start playback from a specific position
  const startPlayback = (chunkIndex, offset = 0, absoluteTime = 0) => {
    // Ensure audio context is initialized
    ctx = ctx || new AudioContext();
    
    // Generate a new playback ID to track this session
    playbackId = Date.now();
    const currentPlayback = playbackId;
    
    // Update state
    playing = true;
    paused = false;
    startTime = ctx.currentTime - absoluteTime;
    
    log(`Starting playback: chunk ${chunkIndex}, offset ${offset.toFixed(2)}s, abs time ${absoluteTime.toFixed(2)}s`);
    
    // Update UI
    E.play.disabled = true;
    E.pause.disabled = false;
    E.stop.disabled = false;
    
    // Start playing from the specified position
    playChunk(chunkIndex, offset, currentPlayback);
    
    // Start the update loop
    requestAnimationFrame(updatePlayback);
  };

  // Play a specific chunk
  const playChunk = (index, offset = 0, id) => {
    // Check if this playback request is still valid
    if (id !== playbackId) {
      log(`Ignoring stale playback request: ${id} vs ${playbackId}`);
      return;
    }
    
    // Check if we've reached the end
    if (index >= buffers.length) {
      log('Reached end of audio');
      stopPlayback();
      return;
    }
    
    // Get the audio buffer for this chunk
    const buffer = buffers[index];
    
    // If the buffer isn't loaded yet, wait and retry
    if (!buffer) {
      log(`Chunk ${index} not loaded yet, waiting...`);
      setTimeout(() => {
        if (playing && id === playbackId) {
          playChunk(index, offset, id);
        }
      }, 300);
      return;
    }
    
    log(`Playing chunk ${index} from offset ${offset.toFixed(2)}s`);
    
    // Create a new audio source
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(ctx.destination);
    
    // When this chunk ends, play the next one
    source.onended = () => {
      // Only proceed if this is still the active playback
      if (playing && id === playbackId) {
        log(`Chunk ${index} ended, playing next chunk`);
        playChunk(index + 1, 0, id);
      }
    };
    
    // Save the source so we can stop it later
    audioSources[index] = source;
    
    // Start playback with the specified offset
    source.start(0, Math.min(offset, buffer.duration));
  };

  // Cancel any current playback
  const cancelPlayback = () => {
    // Stop all audio sources
    audioSources.forEach(source => {
      if (source) {
        source.onended = null; // Remove callback
        try { source.stop(); } catch (e) {}
      }
    });
    
    // Reset sources array
    audioSources = [];
    
    // Generate a new playback ID to invalidate any pending callbacks
    playbackId = Date.now();
  };

  // Pause playback
  const pausePlayback = () => {
    if (!playing) return;
    
    pausedAt = ctx.currentTime - startTime;
    playing = false;
    paused = true;
    
    log(`Pausing at ${pausedAt.toFixed(2)}s`);
    
    // Cancel current playback
    cancelPlayback();
    
    // Update UI
    E.play.disabled = false;
    E.pause.disabled = true;
    
    status(`Paused at ${fmt(pausedAt)}`);
  };

  // Resume playback
  const resumePlayback = () => {
    if (!paused) return;
    
    log(`Resuming from ${pausedAt.toFixed(2)}s`);
    
    // Find the chunk to resume from
    const { chunk, offset } = locateTimePosition(pausedAt);
    
    // Start playback from the pause position
    startPlayback(chunk, offset, pausedAt);
  };

  // Stop playback
  const stopPlayback = (silent = false) => {
    // Cancel current playback
    cancelPlayback();
    
    // Reset state
    playing = false;
    paused = false;
    pausedAt = 0;
    
    // Clear word highlighting
    if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
      wordElements[currentWordIndex].classList.remove('active');
    }
    currentWordIndex = -1;
    
    if (!silent) {
      log('Playback stopped');
      
      // Reset UI
      E.fill.style.width = '0%';
      E.time.textContent = `00:00 / ${fmt(totalDuration)}`;
      E.play.disabled = false;
      E.pause.disabled = true;
      E.stop.disabled = false;
    }
  };

  // Update playback UI (called on each animation frame)
  const updatePlayback = () => {
    if (!playing) return;
    
    // Calculate current time
    const currentTime = ctx.currentTime - startTime;
    
    // Check if we've reached the end
    if (currentTime >= totalDuration) {
      stopPlayback();
      return;
    }
    
    // Update UI
    updateUI(currentTime);
    
    // Continue updates
    requestAnimationFrame(updatePlayback);
  };

  // Update UI with current time
  const updateUI = (time) => {
    // Update progress bar
    const percentage = totalDuration > 0 ? (time / totalDuration) * 100 : 0;
    E.fill.style.width = `${percentage}%`;
    
    // Update time display
    E.time.textContent = `${fmt(time)} / ${fmt(totalDuration)}`;
    
    // Update word highlighting
    updateWordHighlight(time);
  };

  // Update word highlighting
  const updateWordHighlight = (time) => {
    // Find the appropriate word based on time
    let wordIndex = -1;
    
    // First try to find the word by chunk
    const { chunk } = locateTimePosition(time);
    const chunkWords = wordElements.filter((_, i) => wordOffsets[i] === chunk);
    
    if (chunkWords.length) {
      // Find position within chunk
      let chunkStart = 0;
      for (let i = 0; i < chunk; i++) {
        if (buffers[i]) chunkStart += buffers[i].duration;
      }
      
      const chunkDuration = buffers[chunk]?.duration || 0;
      const relativePosition = (time - chunkStart) / chunkDuration;
      const indexInChunk = Math.floor(relativePosition * chunkWords.length);
      
      // Map back to global index
      if (indexInChunk >= 0 && indexInChunk < chunkWords.length) {
        wordIndex = parseInt(chunkWords[indexInChunk].dataset.index);
      }
    }
    
    // If no word found by chunk or it's invalid, use fallback
    if (wordIndex < 0 || wordIndex >= wordElements.length) {
      // Fallback to simple ratio
      wordIndex = Math.floor((time / totalDuration) * wordElements.length);
      wordIndex = Math.min(wordIndex, wordElements.length - 1);
    }
    
    // Only update if it's a different word
    if (wordIndex !== currentWordIndex) {
      // Remove highlight from previous word
      if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
        wordElements[currentWordIndex].classList.remove('active');
      }
      
      // Add highlight to current word
      if (wordIndex >= 0 && wordIndex < wordElements.length) {
        const wordEl = wordElements[wordIndex];
        wordEl.classList.add('active');
        
        // Ensure word is visible
        const container = E.textBox;
        const wordTop = wordEl.offsetTop;
        const wordBottom = wordTop + wordEl.offsetHeight;
        const containerTop = container.scrollTop;
        const containerBottom = containerTop + container.offsetHeight;
        
        if (wordTop < containerTop + 30) {
          container.scrollTop = wordTop - 30;
        } else if (wordBottom > containerBottom - 30) {
          container.scrollTop = wordBottom - container.offsetHeight + 30;
        }
      }
      
      currentWordIndex = wordIndex;
    }
  };

  // Progress bar click handler
  E.prog.onclick = e => {
    if (!totalDuration) return;
    
    const rect = E.prog.getBoundingClientRect();
    const ratio = (e.clientX - rect.left) / rect.width;
    const targetTime = ratio * totalDuration;
    
    log(`Progress bar clicked at ${ratio.toFixed(2)} (${targetTime.toFixed(2)}s)`);
    seekToTime(targetTime);
  };

  // Playback control buttons
  E.play.onclick = () => {
    if (paused) {
      resumePlayback();
    } else {
      startPlayback(0, 0, 0);
    }
  };
  
  E.pause.onclick = pausePlayback;
  E.stop.onclick = stopPlayback;
  
  // Debug toggle
  E.showDebug.addEventListener('change', e => {
    E.debug.classList.toggle('hidden', !e.target.checked);
  });

  // Generate speech
  E.gen.onclick = async () => {
    if (!API) return status('Load voices first', true);
    if (!E.voice.value) return status('Select a voice', true);
    
    // Initialize audio context and ensure it's running
    ctx = ctx || new AudioContext();
    await ctx.resume();
    
    const text = E.txt.value.trim();
    if (!text) return status('Enter text', true);
    
    // Reset state
    stopPlayback();
    buffers = [];
    audioSources = [];
    totalDuration = 0;
    loadedDuration = 0;
    loadingComplete = false;
    
    // Split text into chunks
    const chunks = splitText(text);
    if (!chunks.length) return status('Failed to split text', true);
    
    totalChunks = chunks.length;
    chunksReceived = 0;
    
    // Prepare UI
    status(`Processing ${chunks.length} chunk(s)...`);
    prepareTextDisplay(text, chunks);
    E.gen.disabled = true;
    
    // Initialize buffers array
    buffers = new Array(chunks.length);
    
    // Create request body template
    const createRequest = chunk => ({
      input: { text: chunk },
      voice: {
        languageCode: E.voice.selectedOptions[0].dataset.l,
        name: E.voice.value
      },
      audioConfig: {
        audioEncoding: 'MP3',
        pitch: +E.pit.value,
        speakingRate: +E.rat.value
      }
    });
    
    // Process chunks
    try {
      // Start processing all chunks in parallel
      const chunkPromises = chunks.map(async (chunk, index) => {
        try {
          log(`Generating chunk ${index + 1}/${chunks.length} (${chunk.length} chars)`);
          
          const response = await fetchJSON(`${SY}?key=${API}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(createRequest(chunk))
          });
          
          if (!response.audioContent) {
            throw new Error(`No audio content in response for chunk ${index + 1}`);
          }
          
          // Convert base64 to ArrayBuffer
          const audioData = atob(response.audioContent);
          const arrayBuffer = new Uint8Array(audioData.length);
          for (let i = 0; i < audioData.length; i++) {
            arrayBuffer[i] = audioData.charCodeAt(i);
          }
          
          // Decode audio
          const audioBuffer = await decodeBuffer(arrayBuffer.buffer);
          
          // Store the decoded buffer
          buffers[index] = audioBuffer;
          
          // Update durations
          loadedDuration += audioBuffer.duration;
          totalDuration += audioBuffer.duration;
          
          log(`Chunk ${index + 1} decoded: ${audioBuffer.duration.toFixed(2)}s`);
          
          // Update word elements to show they're ready
          wordElements.forEach(word => {
            if (+word.dataset.chunk === index) {
              word.classList.remove('loading');
            }
          });
          
          // Update progress
          chunksReceived++;
          
          // Autoplay first chunk when it's ready
          if (index === 0 && !playing) {
            startPlayback(0, 0, 0);
          }
          
          return index;
        } catch (error) {
          log(`Error processing chunk ${index + 1}:`, error);
          status(`Chunk ${index + 1} failed: ${error.message}`, true);
          return null;
        }
      });
      
      // Wait for all chunks to complete
      await Promise.all(chunkPromises);
      
      // Check if all chunks were processed successfully
      const success = chunksReceived === totalChunks;
      loadingComplete = true;
      
      if (success) {
        status(`All chunks processed. Duration: ${fmt(totalDuration)}`);
      } else {
        status(`Completed ${chunksReceived}/${totalChunks} chunks`, true);
      }
    } catch (e) {
      status(`Generation failed: ${e.message}`, true);
    } finally {
      E.gen.disabled = false;
    }
  };
});
</script>
</body>
</html>
