<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Text‑to‑Speech Synthesizer (Web Audio API - Enhanced)</title>
    <style>
        :root { --primary-color:#007bff;--secondary-color:#6c757d;--success-color:#28a745;--error-color:#dc3545;--warning-color:#ffc107;--info-bg:#e2e3e5;--info-text:#383d41;--light-bg:#f8f9fa;--dark-text:#212529;--light-text:#fff;--border-color:#dee2e6;--font-family:'Segoe UI',Arial,sans-serif;--shadow-color:rgba(0,0,0,.07); }
        body{font-family:var(--font-family);max-width:800px;margin:2rem auto;padding:1rem;background:var(--light-bg);color:var(--dark-text)}
        h1{text-align:center;color:var(--primary-color);font-weight:700;}
        .container{background:var(--light-text);border-radius:12px;padding:2rem;box-shadow:0 4px 12px var(--shadow-color)}
        .section{margin-bottom:1.5rem}
        .section-title{font-weight:600;margin-bottom:.5rem;color:var(--primary-color)}
        textarea{width:100%;min-height:150px;padding:.75rem;border:1px solid var(--border-color);border-radius:6px;font-size:1rem;line-height:1.5;resize:vertical;box-sizing:border-box}
        textarea:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 2px rgba(0,123,255,.25)}
        .options-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:1rem;margin-top:1rem}
        select,button{padding:.6rem 1rem;border-radius:6px;font-size:1rem;border:1px solid var(--border-color)}select{width:100%;appearance:none;background:var(--light-text) url("data:image/svg+xml,%3Csvg viewBox='0 0 4 5' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M2 0L0 2h4L2 0zm0 5l2-2H0l2 2z' fill='%236c757d'/%3E%3C/svg%3E%0A") no-repeat right 0.75rem center/12px 14px}
        #download-button{background:var(--success-color)}#download-button:hover:not(:disabled){background:#218838}
        #stop-button{background:var(--error-color);display:none;}#stop-button:hover:not(:disabled){background:#c82333}
        .char-counter{font-size:.85rem;color:var(--secondary-color);margin-left:auto}.char-counter.warning{color:var(--warning-color);font-weight:500}.char-counter.danger{color:var(--error-color);font-weight:600}
        .feedback-area{margin-top:1rem;padding:.75rem;border-radius:6px;font-size:.95rem;text-align:center}.status.info{background:var(--info-bg);color:var(--info-text)}.status.success{background:#d4edda;color:#1e4620}.status.error{background:#f8d7da;color:#842029}.status.warning{background:#fff3cd;color:#856404}
        .loading{display:flex;gap:.5rem;align-items:center;color:var(--secondary-color)}.loading-spinner{width:20px;height:20px;border:3px solid #f3f3f3;border-top:3px solid var(--primary-color);border-radius:50%;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
        .progress-container{width:100%;height:8px;background:#e9ecef;border-radius:4px;overflow:hidden;margin-top:.5rem}.progress-bar{height:100%;width:0;background:var(--primary-color);transition:width 0.3s}
        .progress-info{font-size:.85rem;text-align:center;margin-top:.5rem;color:var(--secondary-color)}
        #api-key-container{margin-bottom:1rem;padding:0.75rem;border-radius:6px;background-color:#f8f9fa;border:1px solid var(--border-color)}
        #api-key-input{width:calc(100% - 110px);padding:0.5rem;margin-right:0.5rem;border-radius:4px;border:1px solid var(--border-color)}
        #api-key-save{padding:0.5rem 1rem;background:var(--primary-color);color:white;border:none;border-radius:4px;cursor:pointer}
        #api-key-save:hover{background:#0056b3}
        .collapsed{height:0;overflow:hidden;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-width:0;transition:all 0.3s ease}
        .expanded{height:auto;overflow:visible;transition:all 0.3s ease; padding-top: 0.75rem; padding-bottom: 0.75rem; margin-bottom: 1rem;}
        #api-key-toggle{background:none;border:none;color:var(--primary-color);cursor:pointer;margin-bottom:0.5rem;padding:0;font-size:0.9rem;display:flex;align-items:center;gap:0.25rem}
        #api-key-toggle:hover{text-decoration:underline}
        .footnote{font-size:0.75rem;color:var(--secondary-color);margin-top:1rem}
        /* Playback controls */
        .audio-controls{display:flex;gap:.75rem;justify-content:center;align-items:center;margin:1rem 0;}
        .audio-controls button{padding:0.5rem 1rem;font-size:1.1rem;border-radius:50%;border:1px solid var(--border-color);background:var(--light-bg);cursor:pointer;transition:.2s;}
        .audio-controls button:disabled{color:#aaa;cursor:default;background:#eee;}
        .audio-controls .main{background:var(--primary-color);color:#fff;}
        .audio-controls .main:disabled{background:#9cc7f7;}
        .audio-timeline{width:100%;height:12px;background:#e9ecef;border-radius:5px;cursor:pointer;margin:.5rem 0;position:relative;}
        .audio-timeline .current{height:100%;background:var(--primary-color);border-radius:5px;}
        .audio-timeline .buffered{height:100%;background:#a4d1f4;position:absolute;left:0;top:0;z-index:0;border-radius:5px;}
        .audio-timeline .thumb{width:14px;height:14px;background:var(--primary-color);border-radius:50%;position:absolute;top:-1px;transform:translateX(-50%);z-index:2;}
        .tts-word{transition:background 0.15s;border-radius:3px;}
        .tts-word.active{background:var(--primary-color);color:#fff;}
        #highlight-area{margin:.5rem 0 1.2rem 0;padding:.5rem 0;font-size:1.25rem;line-height:1.8;border-radius:7px;min-height:2.5em;}
    </style>
</head>
<body>
    <h1>Live Text‑to‑Speech Synthesizer</h1>
    <div class="container">
        <div id="api-key-section" class="section">
            <button id="api-key-toggle">
                <span class="toggle-icon">▶</span>&nbsp;Show API Key Settings
            </button>
            <div id="api-key-container" class="collapsed">
                <p><strong>Google Cloud Text-to-Speech API Key:</strong></p>
                <input type="password" id="api-key-input" placeholder="Enter your Google Cloud API key">
                <button id="api-key-save">Save Key</button>
                <p class="footnote">Your API key is stored only in your browser's local storage and never transmitted to any server other than Google Cloud.</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title">Input</h2>
            <div class="char-counter-container" style="display:flex;align-items:center">
                <span id="char-counter" class="char-counter">0 chars</span>
            </div>
            <textarea id="text-input" placeholder="Enter text here …"></textarea>
        </div>

        <div class="section">
            <h2 class="section-title">Options</h2>
            <div class="options-grid">
                <div>
                    <label for="voice-select">Voice</label>
                    <select id="voice-select"><option value="">Loading voices …</option></select>
                </div>
                <div>
                    <label for="speed-select">Speed</label>
                    <select id="speed-select">
                        <option value="0.5">0.5×</option>
                        <option value="0.75">0.75×</option>
                        <option value="1" selected>1×</option>
                        <option value="1.25">1.25×</option>
                        <option value="1.5">1.5×</option>
                        <option value="2">2×</option>
                    </select>
                </div>
                <div>
                    <label for="pitch-select">Pitch</label>
                    <select id="pitch-select">
                        <option value="-10">-10</option>
                        <option value="-5">-5</option>
                        <option value="0" selected>0</option>
                        <option value="5">+5</option>
                        <option value="10">+10</option>
                        <option value="20">+20</option>
                    </select>
                </div>
                <div>
                    <label for="chunk-size-select">Chunk size</label>
                    <select id="chunk-size-select">
                        <option value="0">No chunking (Max 5k)</option>
                        <option value="1000">1000</option>
                        <option value="2000">2000</option>
                        <option value="3000">3000</option>
                        <option value="4500" selected>4500</option>
                    </select>
                </div>
                <div>
                    <label for="chunk-break-select">Split at</label>
                    <select id="chunk-break-select">
                        <option value="sentence" selected>Sentence</option>
                        <option value="paragraph">Paragraph</option>
                        <option value="exact">Exact</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title">Generate & Play</h2>
            <button id="speak-button" disabled>Generate & Play</button>
            <button id="stop-button">Stop</button>
            <button id="download-button" disabled>Download MP3</button>
            <div id="loading" class="loading" style="display:none">
                <div class="loading-spinner"></div>
                <span>Generating …</span>
            </div>
            <div id="progress-container" class="progress-container" style="display:none">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
            <div id="progress-info" class="progress-info" style="display:none"></div>
            <div id="generation-status" class="feedback-area status info" style="display:none"></div>
            <!-- Enhanced Audio Controls -->
            <div class="audio-controls" id="audio-controls" style="display:none">
                <button id="rewind10" title="Back 10s">&#8676;10s</button>
                <button id="rewind5" title="Back 5s">&#8676;5s</button>
                <button id="play" class="main" title="Play">&#9658;</button>
                <button id="pause" class="main" title="Pause">&#10073;&#10073;</button>
                <button id="stop" title="Stop">&#9632;</button>
                <button id="forward5" title="Forward 5s">5s&#8677;</button>
                <button id="forward10" title="Forward 10s">10s&#8677;</button>
            </div>
            <div class="audio-timeline" id="audio-timeline" style="display:none">
                <div class="buffered" id="audio-buffered" style="width:0"></div>
                <div class="current" id="audio-current" style="width:0"></div>
                <div class="thumb" id="audio-thumb" style="left:0"></div>
            </div>
            <div id="audio-time-info" style="text-align:center;font-size:.97rem;color:var(--secondary-color);display:none;">
                <span id="audio-current-time">0:00</span> / <span id="audio-total-time">0:00</span>
            </div>
            <div id="highlight-area"></div>
        </div>
    </div>

    <script>
    // --- Constants and DOM Elements (Unchanged) ---
    const API_URL = 'https://texttospeech.googleapis.com/v1';
    const API_LIMIT = 5000;
    const MIN_INTERVAL = 350;
    const PREFERRED_VOICE = 'en-US-Chirp3-HD-Charon';
    const API_KEY_STORAGE_KEY = 'tts_api_key';

    const el = id => document.getElementById(id);
    const textInput = el('text-input');
    const voiceSelect = el('voice-select');
    const speedSelect = el('speed-select');
    const pitchSelect = el('pitch-select');
    const chunkSizeSel = el('chunk-size-select');
    const chunkBreakSel = el('chunk-break-select');
    const speakBtn = el('speak-button');
    const stopBtn = el('stop-button');
    const downloadBtn = el('download-button');
    const loading = el('loading');
    const progCont = el('progress-container');
    const progBar = el('progress-bar');
    const progInfo = el('progress-info');
    const genStatus = el('generation-status');
    const charCounter = el('char-counter');
    const apiKeyInput = el('api-key-input');
    const apiKeySaveBtn = el('api-key-save');
    const apiKeyToggle = el('api-key-toggle');
    const apiKeyContainer = el('api-key-container');
    // Enhanced controls
    const audioControls = el('audio-controls');
    const rewind10Btn = el('rewind10');
    const rewind5Btn = el('rewind5');
    const playBtn = el('play');
    const pauseBtn = el('pause');
    const stopBtn2 = el('stop'); // new stop button
    const forward5Btn = el('forward5');
    const forward10Btn = el('forward10');
    const timeline = el('audio-timeline');
    const timelineCurrent = el('audio-current');
    const timelineBuffered = el('audio-buffered');
    const timelineThumb = el('audio-thumb');
    const timeInfo = el('audio-time-info');
    const currentTimeSpan = el('audio-current-time');
    const totalTimeSpan = el('audio-total-time');
    const highlightArea = el('highlight-area');

    // --- State ---
    let lastRequestTime = 0;
    let audioContext = null;
    let audioBufferQueue = [];
    let currentSourceNode = null;
    let nextStartTime = 0;
    let isPlaying = false;
    let isGenerating = false;
    let collectedRawBuffers = [];
    let apiKey = '';
    // Enhanced playback state
    let fullBuffer = null; // AudioBuffer holding the whole speech
    let audioStartTime = 0; // when playback started (audioContext.currentTime)
    let pausedAt = 0; // seconds offset
    let playbackTimer = null;
    let highlightWordMap = []; // Array of {start, end, word, idx}
    let wordsArray = [];
    let highlightActive = false;

    // --- API Key Management & Original Logic (omitted here for brevity, unchanged) ---
    // ... (all functions for API key and voice loading, chunk splitting, etc. remain as in your original)

    // --- AUDIO: Enhanced Logic Below ---

    function getTotalAudioDuration() {
        return fullBuffer ? fullBuffer.duration : 0;
    }
    function getCurrentAudioTime() {
        if (!fullBuffer) return 0;
        if (!isPlaying) return pausedAt;
        let elapsed = audioContext ? (audioContext.currentTime - audioStartTime) : 0;
        let t = pausedAt + elapsed;
        return Math.min(t, fullBuffer.duration);
    }
    function setCurrentAudioTime(secs) {
        if (!fullBuffer) return;
        // Clamp
        secs = Math.max(0, Math.min(secs, fullBuffer.duration));
        pausedAt = secs;
        if (isPlaying) {
            stopCurrentSource();
            playAudioFrom(pausedAt);
        } else {
            updateTimeline();
            highlightCurrentWord();
        }
    }
    function stopCurrentSource() {
        if (currentSourceNode) {
            try {
                currentSourceNode.onended = null;
                currentSourceNode.stop(0);
                currentSourceNode.disconnect();
            } catch (e) {}
            currentSourceNode = null;
        }
        isPlaying = false;
        clearInterval(playbackTimer);
        playbackTimer = null;
    }
    function playAudioFrom(offset = 0) {
        if (!audioContext || !fullBuffer) return;
        stopCurrentSource();
        currentSourceNode = audioContext.createBufferSource();
        currentSourceNode.buffer = fullBuffer;
        currentSourceNode.connect(audioContext.destination);
        currentSourceNode.onended = () => {
            isPlaying = false;
            clearInterval(playbackTimer);
            playbackTimer = null;
            updateControls();
            highlightCurrentWord();
            updateTimeline();
        };
        audioStartTime = audioContext.currentTime;
        isPlaying = true;
        currentSourceNode.start(0, offset);
        playbackTimer = setInterval(() => {
            updateTimeline();
            highlightCurrentWord();
            if (getCurrentAudioTime() >= fullBuffer.duration - 0.01) {
                stopCurrentSource();
                pausedAt = 0;
                updateControls();
                updateTimeline();
            }
        }, 50);
        updateControls();
        updateTimeline();
        highlightCurrentWord();
    }
    function pauseAudio() {
        if (!isPlaying) return;
        pausedAt = getCurrentAudioTime();
        stopCurrentSource();
        updateControls();
        updateTimeline();
        highlightCurrentWord();
    }
    function stopAudio() {
        stopCurrentSource();
        pausedAt = 0;
        updateControls();
        updateTimeline();
        highlightCurrentWord();
    }

    // --- Timeline/Progress UI ---
    function updateTimeline() {
        if (!fullBuffer) {
            timelineCurrent.style.width = '0';
            timelineBuffered.style.width = '0';
            timelineThumb.style.left = '0';
            currentTimeSpan.textContent = '0:00';
            totalTimeSpan.textContent = '0:00';
            return;
        }
        let t = getCurrentAudioTime();
        let duration = fullBuffer.duration || 1;
        let percent = 100 * t / duration;
        timelineCurrent.style.width = percent + '%';
        timelineBuffered.style.width = '100%';
        timelineThumb.style.left = percent + '%';
        currentTimeSpan.textContent = formatTime(t);
        totalTimeSpan.textContent = formatTime(duration);
    }
    function formatTime(secs) {
        let m = Math.floor(secs / 60);
        let s = Math.floor(secs % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    }

    // --- Generate Highlight Mapping for Word-by-Word Highlight ---
    function buildHighlightMap(text, sampleRate, duration) {
        // Very rough: map word times linearly across duration
        wordsArray = text.match(/\S+/g) || [];
        highlightWordMap = [];
        if (!wordsArray.length) return;
        let perWord = duration / wordsArray.length;
        let offset = 0;
        for (let i = 0; i < wordsArray.length; ++i) {
            let word = wordsArray[i];
            highlightWordMap.push({start: offset, end: offset + perWord, word, idx: i});
            offset += perWord;
        }
    }
    function renderHighlight() {
        let html = '';
        for (let i = 0; i < wordsArray.length; ++i) {
            html += `<span class="tts-word" id="tts-word-${i}">${wordsArray[i]}</span> `;
        }
        highlightArea.innerHTML = html;
    }
    function highlightCurrentWord() {
        if (!highlightWordMap.length) return;
        let t = getCurrentAudioTime();
        let idx = highlightWordMap.findIndex(({start, end}) => t >= start && t < end);
        if (idx === -1 && t >= (highlightWordMap.at(-1)?.start || 0)) idx = highlightWordMap.length - 1;
        for (let i = 0; i < highlightWordMap.length; ++i) {
            let elw = document.getElementById('tts-word-' + i);
            if (elw) elw.classList.toggle('active', i === idx);
        }
    }

    // --- Controls State ---
    function updateControls() {
        playBtn.disabled = !fullBuffer || isPlaying;
        pauseBtn.disabled = !fullBuffer || !isPlaying;
        stopBtn2.disabled = !fullBuffer || (!isPlaying && pausedAt === 0);
        rewind5Btn.disabled = !fullBuffer;
        rewind10Btn.disabled = !fullBuffer;
        forward5Btn.disabled = !fullBuffer;
        forward10Btn.disabled = !fullBuffer;
        timeline.style.display = fullBuffer ? 'block' : 'none';
        timeInfo.style.display = fullBuffer ? 'block' : 'none';
        audioControls.style.display = fullBuffer ? 'flex' : 'none';
        highlightArea.style.display = fullBuffer ? 'block' : 'none';
    }

    // --- Timeline Seek Handling ---
    timeline.addEventListener('click', function (e) {
        if (!fullBuffer) return;
        const rect = timeline.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percent = Math.max(0, Math.min(1, x / rect.width));
        setCurrentAudioTime(percent * fullBuffer.duration);
    });

    // --- Enhanced Event Listeners ---
    playBtn.addEventListener('click', () => playAudioFrom(pausedAt));
    pauseBtn.addEventListener('click', pauseAudio);
    stopBtn2.addEventListener('click', stopAudio);
    rewind5Btn.addEventListener('click', () => setCurrentAudioTime(getCurrentAudioTime() - 5));
    rewind10Btn.addEventListener('click', () => setCurrentAudioTime(getCurrentAudioTime() - 10));
    forward5Btn.addEventListener('click', () => setCurrentAudioTime(getCurrentAudioTime() + 5));
    forward10Btn.addEventListener('click', () => setCurrentAudioTime(getCurrentAudioTime() + 10));

    // --- PATCH: When new audio is generated, create fullBuffer and highlight map ---
    async function postProcessAfterGeneration(text, buffers) {
        // Decode all MP3 chunks and concatenate
        if (!audioContext) return;
        let audioParts = [];
        for (let buf of buffers) {
            let ab = buf.slice(0);
            let decoded = await audioContext.decodeAudioData(ab);
            audioParts.push(decoded);
        }
        // Concatenate all chunks into one buffer
        let totalLen = audioParts.reduce((s, b) => s + b.length, 0);
        let sampleRate = audioParts[0]?.sampleRate || 24000;
        let channels = audioParts[0]?.numberOfChannels || 1;
        let out = audioContext.createBuffer(channels, totalLen, sampleRate);
        let offset = 0;
        for (let part of audioParts) {
            for (let c = 0; c < channels; ++c) {
                out.getChannelData(c).set(part.getChannelData(c), offset);
            }
            offset += part.length;
        }
        fullBuffer = out;
        pausedAt = 0;
        buildHighlightMap(text, sampleRate, out.duration);
        renderHighlight();
        updateControls();
        updateTimeline();
        highlightCurrentWord();
    }

    // --- INTEGRATE WITH EXISTING GENERATION LOGIC ---

    // (The following is a patch to your original startGeneration logic)
    // Find the line after `collectedRawBuffers = []` and before `audioBufferQueue = []`, and insert:
    // fullBuffer = null; pausedAt = 0; highlightWordMap = []; highlightArea.innerHTML = '';
    // After generation completes and collectedRawBuffers is filled, call:
    // await postProcessAfterGeneration(text, collectedRawBuffers);

    // Below is the patched startGeneration function
    async function startGeneration() {
        if (isGenerating || speakBtn.disabled) return;
        if (!checkApiKeyAvailability()) return;
        const text = textInput.value.trim();
        if (!text) { showStatus("Please enter some text", 'warning'); return; }
        if (!voiceSelect.value) { showStatus("Please select a voice", 'warning'); return; }
        if (!initAudioContext()) return;

        stopPlaybackAndGeneration(true);
        isGenerating = true;
        collectedRawBuffers = [];
        audioBufferQueue = [];
        fullBuffer = null; pausedAt = 0; highlightWordMap = []; highlightArea.innerHTML = '';
        nextStartTime = audioContext.currentTime;

        hideStatus();
        loading.style.display = 'flex';
        progCont.style.display = 'none';
        progInfo.style.display = 'none';
        progBar.style.width = '0%';
        speakBtn.disabled = true;
        stopBtn.style.display = 'inline-block';
        downloadBtn.disabled = true;

        const selectedOption = voiceSelect.selectedOptions[0];
        const options = { name: selectedOption.value, lang: selectedOption.dataset.lang, speed: parseFloat(speedSelect.value), pitch: parseFloat(pitchSelect.value) };
        const chunkSize = parseInt(chunkSizeSel.value, 10);
        const chunkMethod = chunkBreakSel.value;
        const chunks = splitChunks(text, chunkSize || API_LIMIT, chunkMethod);
        if (chunks.length > 1) { progCont.style.display = 'block'; progInfo.style.display = 'block'; }

        let hasError = false;
        try {
            for (let i = 0; i < chunks.length; i++) {
                if (!isGenerating) { break; }
                const currentChunkText = chunks[i];
                if (currentChunkText.length > API_LIMIT) {
                    showStatus(`Error: Chunk ${i + 1} exceeds API limit of ${API_LIMIT} chars (${currentChunkText.length}).`, 'error');
                    hasError = true; break;
                }
                if (chunks.length > 1) {
                    progBar.style.width = `${Math.round((i + 1) / chunks.length * 100)}%`;
                    progInfo.textContent = `Processing chunk ${i + 1} / ${chunks.length}`;
                } else if (!progInfo.style.display || progInfo.style.display === 'none') {
                    progInfo.textContent = `Processing text...`; progInfo.style.display = 'block';
                }
                try {
                    const rawBuffer = await synthesizeChunk(currentChunkText, options);
                    collectedRawBuffers.push(rawBuffer);
                } catch (e) {
                    showStatus(`Error on chunk ${i + 1}: ${e.message}`, 'error');
                    hasError = true; break;
                }
            }
            if (!hasError) {
                await postProcessAfterGeneration(text, collectedRawBuffers);
                showStatus('Audio is ready! Use the controls below.', 'success');
                downloadBtn.disabled = collectedRawBuffers.length === 0;
            }
        } catch (e) {
            showStatus(`Unexpected generation error: ${e.message}`, 'error');
            hasError = true;
        } finally {
            isGenerating = false;
            loading.style.display = 'none';
            if (hasError) {
                progInfo.textContent = 'Generation stopped due to error';
                stopPlaybackAndGeneration();
            }
        }
    }

    // --- PATCH: Download works as soon as audio is generated ---
    function downloadAudio() {
        if (!collectedRawBuffers.length || downloadBtn.disabled) {
            showStatus("No audio data to download", "warning"); return;
        }
        try {
            const finalBlob = new Blob(collectedRawBuffers, { type: 'audio/mp3' });
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const textPreview = textInput.value.trim().substring(0, 25).replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_');
            const filename = `speech_${textPreview || 'audio'}_${timestamp}.mp3`;
            const url = URL.createObjectURL(finalBlob);
            const a = document.createElement('a');
            a.style.display = 'none'; a.href = url; a.download = filename;
            document.body.appendChild(a); a.click();
            setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
            showStatus(`Downloaded "${filename}"`, 'success');
        } catch (e) {
            showStatus(`Download failed: ${e.message}`, 'error');
        }
    }

    // --- PATCH: Stop/Reset disables enhanced controls ---
    function stopPlaybackAndGeneration(isInternalReset = false) {
        isGenerating = false;
        stopCurrentSource();
        audioBufferQueue = [];
        isPlaying = false;
        nextStartTime = audioContext ? audioContext.currentTime : 0;
        loading.style.display = 'none';
        updateCharCount();
        stopBtn.style.display = 'none';
        downloadBtn.disabled = collectedRawBuffers.length === 0;
        updateControls();
        if (!isInternalReset && !genStatus.classList.contains('error')) {
            showStatus('Stopped', 'warning');
        }
    }

    // --- Attach remaining event listeners (unchanged) ---
    textInput.addEventListener('input', updateCharCount);
    speakBtn.addEventListener('click', startGeneration);
    stopBtn.addEventListener('click', () => stopPlaybackAndGeneration(false));
    downloadBtn.addEventListener('click', downloadAudio);
    apiKeySaveBtn.addEventListener('click', saveApiKey);
    apiKeyToggle.addEventListener('click', toggleApiKeyContainer);
    voiceSelect.addEventListener('change', () => { updateCharCount(); stopPlaybackAndGeneration(false); });
    speedSelect.addEventListener('change', () => stopPlaybackAndGeneration(false));
    pitchSelect.addEventListener('change', () => stopPlaybackAndGeneration(false));
    chunkSizeSel.addEventListener('change', () => { updateCharCount(); stopPlaybackAndGeneration(false); });
    chunkBreakSel.addEventListener('change', () => stopPlaybackAndGeneration(false));

    // --- Global error handlers, cleanup, and initial load (unchanged) ---
    window.addEventListener('error', (event) => {
        if (isGenerating || isPlaying) {
            showStatus(`An unexpected error occurred: ${event.message || 'Unknown error'}. Stopping operation.`, 'error');
            stopPlaybackAndGeneration();
        }
    });
    window.addEventListener('unhandledrejection', (event) => {
        if (isGenerating || isPlaying) {
            showStatus(`An unexpected async error occurred: ${event.reason?.message || 'Unknown rejection'}. Stopping operation.`, 'error');
            stopPlaybackAndGeneration();
        }
    });
    window.addEventListener('beforeunload', () => {
        stopPlaybackAndGeneration(true);
        if (audioContext && audioContext.state !== 'closed') {
            try { audioContext.close(); }
            catch (e) {}
        }
    });

    // --- Initial setup ---
    loadApiKey();
    updateCharCount();
    if (apiKey) {
        loadVoices();
    } else {
        checkApiKeyAvailability();
    }
    updateControls();
    </script>
</body>
</html>
