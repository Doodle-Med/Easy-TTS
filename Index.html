<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="UTF-8"/>
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://accounts.google.com https://apis.google.com 'sha256-TXzjhYoTwNnwzkebzUHEwM9yhUprTP5e7EJxmWr4v2M='; connect-src 'self' https://texttospeech.googleapis.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; object-src 'none'; base-uri 'self'; frame-src 'self' https://content-texttospeech.googleapis.com;">
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js" async defer></script>
<script src="voice-visualizer.js"></script>
<style>
:root {
  /* Light theme (default) */
  --c1:#4285f4;
  --c2:#34a853;
  --c3:#ea4335;
  --c4:#fbbc04;
  --bg:#f8f9fa;
  --card-bg:#ffffff;
  --fg:#202124;
  --bd:#dadce0;
  --hover:#f1f3f4;
  --r:10px;
  --shadow: 0 4px 12px rgba(0,0,0,.05);
  --code-bg: #f5f5f5;
  --hover-bg: rgba(66,133,244,0.1);

  /* Animation and transition properties */
  --transition: all 0.3s ease;
}

/* Dark theme variables */
[data-theme="dark"] {
  --c1:#8ab4f8;
  --c2:#81c995;
  --c3:#f28b82;
  --c4:#fdd663;
  --bg:#202124;
  --card-bg:#292a2d;
  --fg:#e8eaed;
  --bd:#5f6368;
  --hover:#3c3c3c;
  --shadow: 0 4px 12px rgba(0,0,0,.2);
  --code-bg: #2d2d30;
  --hover-bg: rgba(138, 180, 248, 0.15);
}

* {
  box-sizing:border-box;
  margin:0;
  padding:0;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
  transition: var(--transition);
}

body {
  background:var(--bg);
  color:var(--fg);
  padding:1rem;
  max-width:1200px;
  margin:auto;
}

h1 {
  font-size:clamp(1.7rem,2.5vw,3rem);
  text-align:center;
  margin-bottom:1rem;
  background:linear-gradient(90deg,var(--c1),var(--c2),var(--c4),var(--c3));
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;
  font-weight:800;
}

.grid {
  display:grid;
  gap:1rem;
}

.two {
  grid-template-columns:1fr 1fr;
}

@media(max-width:800px) {
  .two {
    grid-template-columns:1fr;
  }
}

.card {
  background:var(--card-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  box-shadow:var(--shadow);
  padding:1.2rem;
  position:relative;
}

.card:hover {
  box-shadow: 0 6px 16px rgba(0,0,0, var(--shadow-opacity, 0.08));
}

.card-header {
  display:flex;
  align-items:center;
  margin-bottom:1rem;
}

.card-header h2 {
  flex:1;
  font-size:1.3rem;
}

label {
  font-weight:600;
  margin:.6rem 0 .3rem;
  display:block;
}

input, select, textarea, button {
  width:100%;
  padding:.55rem .65rem;
  border:1px solid var(--bd);
  border-radius:6px;
  font-size:1rem;
  margin-bottom:.8rem;
  background: var(--card-bg);
  color: var(--fg);
}

input:focus, select:focus, textarea:focus {
  border-color:var(--c1);
  outline:none;
  box-shadow: 0 0 0 3px rgba(66,133,244,0.2);
}

textarea {
  resize:vertical;
  min-height:140px;
}

button {
  cursor:pointer;
  background:var(--c1);
  color:#fff;
  border:none;
  font-weight:600;
}

button:not(:disabled):hover {
  background:#3367d6;
  transform: translateY(-1px);
}

button:disabled {
  background:var(--bd);
  cursor:not-allowed;
  opacity: 0.7;
}

.small-btn {
  width:auto;
}

.toggle {
  display:flex;
  gap:.5rem;
  margin:.6rem 0;
}

.toggle button {
  flex:1;
  background:var(--bg);
  border:1px solid var(--bd);
  color:var(--fg);
}

.toggle .active {
  background:var(--c2);
  color:#fff;
  border-color:var(--c2);
}

.status {
  min-height:1.4em;
  font-size:.95rem;
  margin:.5rem 0;
  padding: .5rem;
  border-radius: 6px;
}

.error {
  color:var(--c3);
  background: rgba(234,67,53,0.1);
  font-weight:700;
}

.success {
  color:var(--c2);
  background: rgba(52,168,83,0.1);
  font-weight:700;
}

.bar {
  height:12px;
  background:var(--bd);
  border-radius:6px;
  overflow:hidden;
  cursor:pointer;
  margin:.8rem 0;
}

.fill {
  height:100%;
  background:linear-gradient(90deg,var(--c1),var(--c2));
  width:0;
  transition: width 0.1s linear;
}

.audio {
  display:flex;
  align-items:center;
  gap:.6rem;
}

.audio button {
  width:44px;
  border-radius:50%;
  aspect-ratio:1/1;
  font-size:1.1rem;
  display:grid;
  place-items:center;
}

.time {
  font-family:monospace;
  margin-left:auto;
}

.text-box {
  background:var(--card-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  padding:1rem;
  max-height:340px;
  overflow:auto;
  line-height:1.6;
}

.word {
  display:inline-block;
  cursor:pointer;
  border-radius:3px;
  padding:1px 2px;
  transition: all 0.15s ease;
}

.word:hover {
  background:var(--hover-bg);
}

.word.active {
  background:rgba(66,133,244,.25);
  color:var(--c1);
  font-weight:700;
}

.word.loading {
  position: relative;
  background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
  background-size: 200% 100%;
  animation: shine 1.5s infinite;
  cursor:wait;
  opacity:0.6;
}

@keyframes shine {
  to { background-position: -200% 0; }
}

.spinner {
  display:inline-block;
  width:14px;
  height:14px;
  border:2px solid rgba(66,133,244,0.2);
  border-radius:50%;
  border-top-color:var(--c1);
  animation:spin 0.8s linear infinite;
  margin-right:5px;
}

@keyframes spin {
  to {transform:rotate(360deg)}
}

.controls {
  display:flex;
  align-items:center;
  gap:0.5rem;
  margin-bottom:0.8rem;
}

.controls button {
  margin-bottom:0;
}

.controls #authStatus { /* Style for the auth status span */
    flex-grow: 1;
    font-style: italic;
    opacity: 0.8;
    font-size: 0.9rem;
}

.volume-control {
  display:flex;
  align-items:center;
  gap:0.5rem;
  flex:1;
}

.volume-control input {
  margin:0;
}

.download-btn {
  margin-left:auto;
}

.debug-panel {
  font-family:monospace;
  font-size:12px;
  background:var(--code-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  padding:0.8rem;
  margin-top:1rem;
  max-height:200px;
  overflow:auto;
}

.debug-entry {
  margin-bottom:0.3rem;
  border-bottom:1px solid var(--bd);
  padding-bottom:0.3rem;
}

.debug-time {
  color:var(--fg);
  opacity: 0.6;
  font-size:10px;
}

.debug-msg {
  font-weight:bold;
}

.debug-data {
  color:var(--fg);
  opacity: 0.8;
  margin-left:1rem;
}

.toggle-debug {
  text-align:center;
  font-size:0.9rem;
  margin-top:0.5rem;
  cursor:pointer;
  color:var(--c1);
}

.theme-toggle {
  position: absolute;
  top: 1rem;
  right: 1rem;
  z-index: 100;
}

.theme-toggle button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  background: transparent;
  color: var(--fg);
  border: 1px solid var(--bd);
}

.theme-toggle button:hover {
  background: var(--hover-bg);
  transform: none;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--bd);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--c1);
}

.hidden {
  display:none !important;
}
</style>
</head>
<body>
<h1>Google Cloud TTS Playground</h1>
<div class="theme-toggle">
  <button id="themeToggle" title="Toggle Theme">üåì</button>
</div>
<div class="grid two">
  <div class="card">
    <div class="card-header">
      <h2>üéõÔ∏è Configuration</h2>
    </div>

    <label>Authentication</label>
    <div class="controls">
      <button class="small-btn" id="signInBtn" disabled>Sign in with Google</button>
      <span id="authStatus">Not signed in</span>
    </div>

    <button class="small-btn" id="ld" disabled>Load Voices</button>
    <div id="loading" class="status hidden"><span class="spinner"></span>Loading voices...</div>

    <label>Text</label>
    <textarea id="txt" placeholder="Type or paste text here..."></textarea>

    <label>Voice</label>
    <select id="v" disabled></select>

    <div class="grid" style="grid-template-columns:1fr 1fr;gap:.8rem">
      <div>
        <label>Pitch <span id="pitVal">0</span></label>
        <input id="pit" type="range" min="-20" max="20" value="0"/>
      </div>
      <div>
        <label>Rate <span id="ratVal">1</span></label>
        <input id="rat" type="range" min="0.25" max="4" step="0.05" value="1"/>
      </div>
    </div>

    <label>Chunk Size <span id="chkVal">1000</span></label>
    <input id="chk" type="range" min="500" max="4500" step="500" value="1000"/>

    <div class="toggle" id="method">
      <button data-m="sentence">Sentence</button>
      <button data-m="paragraph" class="active">Paragraph</button>
      <button data-m="exact">Exact</button>
    </div>

    <button id="gen" disabled>üé§ Generate & Play</button>
    <div id="stat" class="status"></div>
  </div>

  <div class="card">
    <div class="card-header">
      <h2>üîä Playback</h2>
    </div>
    <div id="text" class="text-box"><p style="opacity:.6;text-align:center;">Words will appear here...</p></div>
    <canvas id="visualizer" height="80" style="width:100%;margin:0.8rem 0;border:1px solid var(--bd);border-radius:var(--r);"></canvas>
    <div class="bar" id="prog">
      <div class="fill" id="fill"></div>
    </div>

    <div class="audio">
      <button class="small-btn" id="play" disabled title="Play">‚ñ∂</button>
      <button class="small-btn" id="pause" disabled title="Pause">‚è∏</button>
      <button class="small-btn" id="stop" disabled title="Stop">‚èπ</button>

      <div class="volume-control">
        <span>üîä</span>
        <input type="range" id="volume" min="0" max="1" step="0.1" value="1"/>
      </div>

      <span class="time" id="time">00:00 / 00:00</span>
    </div>

    <button id="download" class="download-btn" disabled>üíæ Download Audio</button>
    <div class="toggle-debug" id="toggleDebug">Show Debug Info</div>
    <div id="debugPanel" class="debug-panel hidden"></div>
  </div>
</div>

<script>
// Global variables for OAuth
const CLIENT_ID = '879295177554-m3j1d2pks6lukl3h9cl92r953ef2jd4e.apps.googleusercontent.com';
const DISCOVERY_DOC = 'https://texttospeech.googleapis.com/$discovery/rest?version=v1';
const SCOPES = 'https://www.googleapis.com/auth/cloud-platform';

// Global references to sign-in elements
let tokenClient = null;
let accessToken = null;
let gapiInited = false;
let gisInited = false;

// Store DOM elements early
const signInBtnElement = document.getElementById('signInBtn');
const authStatusElement = document.getElementById('authStatus');
const loadVoicesBtnElement = document.getElementById('ld');

function debugLog(message) {
  console.log(`[Auth] ${message}`);
}

// Called when Google API JS is loaded
function gapiLoaded() {
  debugLog("GAPI loaded, initializing client...");
  gapi.load('client', initializeGapiClient);
}

async function initializeGapiClient() {
  try {
    await gapi.client.init({
      discoveryDocs: [DISCOVERY_DOC]
    });
    gapiInited = true;
    debugLog("GAPI client initialized");
    maybeEnableButtons();
  } catch (err) {
    debugLog("GAPI client initialization failed: " + err.message);
    authStatusElement.textContent = '‚ùå API initialization failed';
  }
}

// Called when Google Identity Services JS is loaded
function gisLoaded() {
  debugLog("GIS loaded, initializing token client...");
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: handleTokenResponse
  });
  gisInited = true;
  debugLog("GIS token client initialized");
  maybeEnableButtons();
}

// Handle token response
function handleTokenResponse(resp) {
  if (resp.error) {
    debugLog(`OAuth error: ${resp.error}`);
    authStatusElement.textContent = '‚ùå Sign-in failed';
    loadVoicesBtnElement.disabled = true;
    accessToken = null;
    console.error('OAuth error', resp);
    return;
  }

  accessToken = resp.access_token;
  debugLog('OAuth successful, access token obtained');
  authStatusElement.textContent = '‚úÖ Signed in';
  loadVoicesBtnElement.disabled = false;

  // Auto-load voices if possible
  loadVoicesBtnElement.click();
}

// Enable buttons if both APIs have initialized
function maybeEnableButtons() {
  if (gapiInited && gisInited) {
    signInBtnElement.disabled = false;
    debugLog("Both GAPI and GIS ready, sign-in button enabled");
  }
}

// Sign-in handler
function handleSignIn() {
  if (!tokenClient) {
    debugLog('Token client not initialized yet');
    authStatusElement.textContent = '‚åõ Please wait...';
    return;
  }

  debugLog('Requesting access token...');
  tokenClient.requestAccessToken({ prompt: accessToken ? '' : 'consent' });
}

// Set up event listeners early
window.addEventListener('load', function() {
  // Initialize OAuth libraries
  gapiLoaded();
  gisLoaded();

  // Add click handler to sign-in button
  signInBtnElement.addEventListener('click', handleSignIn);
});

// Main application code
window.addEventListener('DOMContentLoaded', () => {
  // API endpoints & DOM elements
  const VO = 'https://texttospeech.googleapis.com/v1/voices';
  const SY = 'https://texttospeech.googleapis.com/v1/text:synthesize';
  const Q = id => document.getElementById(id);
  const E = {
    signInBtn: Q('signInBtn'),
    authStatus: Q('authStatus'),
    load: Q('ld'),
    loading: Q('loading'),
    txt: Q('txt'),
    voice: Q('v'),
    pit: Q('pit'),
    rat: Q('rat'),
    pitVal: Q('pitVal'),
    ratVal: Q('ratVal'),
    chk: Q('chk'),
    chkVal: Q('chkVal'),
    gen: Q('gen'),
    stat: Q('stat'),
    methodBtns: [...Q('method').children],
    textBox: Q('text'),
    play: Q('play'),
    pause: Q('pause'),
    stop: Q('stop'),
    volume: Q('volume'),
    download: Q('download'),
    prog: Q('prog'),
    fill: Q('fill'),
    time: Q('time'),
    toggleDebug: Q('toggleDebug'),
    debugPanel: Q('debugPanel'),
    themeToggle: Q('themeToggle')
  };

  // Debug logging
  let debugEnabled = localStorage.getItem('debugEnabled') === 'true';
  const maxDebugEntries = 100;
  let debugEntries = [];

  // Theme toggle
  let isDarkMode = localStorage.getItem('darkMode') === 'true';
  if (isDarkMode) {
    document.documentElement.setAttribute('data-theme', 'dark');
  }

  E.themeToggle.addEventListener('click', () => {
    isDarkMode = !isDarkMode;
    document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
    localStorage.setItem('darkMode', isDarkMode);
    log(`Theme changed to ${isDarkMode ? 'dark' : 'light'} mode`);
  });

  // Toggle debug panel
  E.toggleDebug.addEventListener('click', () => {
    debugEnabled = !debugEnabled;
    localStorage.setItem('debugEnabled', debugEnabled);
    E.debugPanel.classList.toggle('hidden', !debugEnabled);
    E.toggleDebug.textContent = debugEnabled ? 'Hide Debug Info' : 'Show Debug Info';

    if (debugEnabled) {
      updateDebugPanel();
    }
  });

  // Initialize debug panel state
  if (debugEnabled) {
    E.debugPanel.classList.remove('hidden');
    E.toggleDebug.textContent = 'Hide Debug Info';
  }

  // Enhanced logging with debug panel support
  const log = (message, data = null, level = 'info') => {
    const timestamp = new Date().toISOString();
    const entry = {
      timestamp,
      message,
      data,
      level
    };

    // Add to debug entries
    debugEntries.unshift(entry);
    if (debugEntries.length > maxDebugEntries) {
      debugEntries.pop();
    }

    // Output to console with appropriate level
    switch(level) {
      case 'error':
        console.error(`[${timestamp}] ${message}`, data);
        break;
      case 'warn':
        console.warn(`[${timestamp}] ${message}`, data);
        break;
      default:
        console.log(`[${timestamp}] ${message}`, data);
    }

    // Update debug panel if visible
    if (debugEnabled) {
      updateDebugPanel();
    }
  };

  // Update debug panel with latest entries
  const updateDebugPanel = () => {
    E.debugPanel.innerHTML = debugEntries.map(entry => {
      const timeStr = new Date(entry.timestamp).toLocaleTimeString();
      let dataStr = '';

      if (entry.data !== null) {
        try {
          if (typeof entry.data === 'object') {
            dataStr = `<div class="debug-data">${JSON.stringify(entry.data)}</div>`;
          } else {
            dataStr = `<div class="debug-data">${entry.data}</div>`;
          }
        } catch (e) {
          dataStr = `<div class="debug-data">[Complex Object]</div>`;
        }
      }

      return `
        <div class="debug-entry ${entry.level}">
          <span class="debug-time">${timeStr}</span>
          <span class="debug-msg">${entry.message}</span>
          ${dataStr}
        </div>
      `;
    }).join('');
  };

  // App state
  let ctx;
  let gainNode;
  let voices = [];
  let buffers = [];
  let audioBlobs = []; // Store audio as blobs for download
  let audioSources = []; // Track all audio sources
  let wordElements = []; // Store word elements for efficient lookup
  let wordTimings = []; // NEW: More accurate timing data for words
  let totalDuration = 0; // Total final duration
  let loadedDuration = 0; // Duration of loaded chunks so far
  let startTime = 0; // When playback started
  let pausedAt = 0; // Where we paused
  let playbackId = 0; // Used to cancel stale playback
  let playing = false;
  let paused = false;
  let method = 'paragraph';
  let currentWordIndex = -1;
  let loadingComplete = false;
  let chunksReceived = 0;
  let totalChunks = 0;
  let chunksData = []; // NEW: Store detailed data about each chunk
  let visualizer;

  // Utilities
  const fmt = s => `${String(Math.floor(s/60)).padStart(2, '0')}:${String(Math.floor(s%60)).padStart(2, '0')}`;

  const status = (m, isError) => {
    E.stat.textContent = m;
    E.stat.className = 'status' + (isError ? ' error' : isError === false ? ' success' : '');
    log(m, null, isError ? 'error' : 'info');
  };

  // JSON fetch helper with error handling
  const fetchJSON = async (url, opts) => {
    try {
      log(`Workspaceing ${url}`, opts);
      const r = await fetch(url, opts);

      if (!r.ok) {
        let m = `HTTP ${r.status}`;
        try {
          const errorData = await r.json();
          m = errorData.error?.message || m;
          log('API Error', errorData, 'error');
        } catch (e) {
          log('Failed to parse error response', e, 'error');
        }
        throw new Error(m);
      }

      const data = await r.json();
      log(`Workspace completed successfully`, { url });
      return data;
    } catch (e) {
      log('Fetch error', e, 'error');
      throw e;
    }
  };

  // UI event binding
  ['pit', 'rat', 'chk'].forEach(id => {
    E[id].addEventListener('input', e => {
      const span = E[`${id}Val`];
      if (span) {
        const val = id === 'rat' ? parseFloat(e.target.value).toFixed(2) : e.target.value;
        span.textContent = val;
      }
    });
  });

  // Initialize volume control
  E.volume.addEventListener('input', () => {
    if (gainNode) {
      gainNode.gain.value = E.volume.value;
      log(`Volume changed to ${E.volume.value}`);
    }
  });

  // Load Voices handler
  E.load.onclick = async () => {
    // Check if user is signed in (accessToken is present)
    if (!accessToken) {
      status('Please sign in first to load voices.', true);
      if (tokenClient) {
         tokenClient.requestAccessToken({ prompt: 'consent' });
      } else {
         log('Token client not ready for sign-in prompt.', null, 'warn');
         status('Authentication system not ready.', true);
      }
      return;
    }

    E.loading.classList.remove('hidden');
    E.load.disabled = true;
    E.gen.disabled = true; // Also disable generate while loading voices
    status('Loading voices...');

    try {
      log(`Requesting voices from ${VO} using OAuth token.`);
      // fetch voices with Bearer token
      const d = await fetchJSON(VO, {
          method: 'GET',
          headers: { 'Authorization': 'Bearer ' + accessToken }
      });
      voices = d.voices || [];

      if (!voices.length) throw new Error('No voices returned from API');

      log(`Loaded ${voices.length} voices`);

      const langMap = new Map();
      voices.forEach(v => {
        v.languageCodes.forEach(code => {
          let name;
          try {
            name = new Intl.DisplayNames(['en'], { type: 'language' }).of(code);
          } catch (e) {
            name = code;
          }

          if (!langMap.has(code)) {
            langMap.set(code, { name, voices: [] });
          }
          langMap.get(code).voices.push(v);
        });
      });

      const sortedLangs = [...langMap.entries()]
        .sort((a, b) => a[1].name.localeCompare(b[1].name));

      const html = sortedLangs.map(([code, { name, voices }]) => {
        const options = voices
          .sort((a, b) => a.name.localeCompare(b.name))
          .map(v => {
            const isNeural = v.name.includes('Neural') || v.name.includes('Wavenet');
            return `<option value="${v.name}" data-l="${code}">${v.name} ${isNeural ? '(Neural)' : ''}</option>`;
          })
          .join('');

        return `<optgroup label="${name}">${options}</optgroup>`;
      }).join('');

      E.voice.innerHTML = html;
      E.voice.disabled = false;
      E.gen.disabled = false; // Enable generate button now

      status('Voices loaded successfully', false);
    } catch (e) {
      status(`Failed to load voices: ${e.message}`, true);
      log('Error loading voices', e, 'error');
       // If the error might be auth-related (e.g., 401, 403), maybe reset token
       if (e.message.includes('401') || e.message.includes('403')) {
            accessToken = null; // Clear potentially invalid token
            E.authStatus.textContent = '‚ö†Ô∏è Re-authentication needed';
            E.load.disabled = true; // Disable load again
       }
    } finally {
      E.loading.classList.add('hidden');
      // Keep E.load enabled if accessToken exists, disable otherwise
      E.load.disabled = !accessToken;
    }
  };

  // Configure chunk splitting method
  E.methodBtns.forEach(b => b.onclick = () => {
    E.methodBtns.forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    method = b.dataset.m;
    log(`Splitting method changed to: ${method}`);
  });

  // Split text into chunks based on selected method
  const splitText = t => {
    const m = +E.chk.value;
    log(`Splitting text (${t.length} chars) with method: ${method}, chunk size: ${m}`);

    if (t.length <= m) return [t];

    if (method === 'exact') {
      const a = [];
      for (let i = 0; i < t.length; i += m) {
        a.push(t.slice(i, i + m));
      }
      log(`Split into ${a.length} chunks using exact method`);
      return a;
    }

    const re = method === 'paragraph' ? /\n\s*\n/ : /([.!?]+["']?\s+)/;
    const bits = t.split(re).filter(Boolean);
    log(`Split text into ${bits.length} initial segments`);

    const out = [];
    let cur = '';

    for (const p of bits) {
      if ((cur + p).length > m) {
        if (cur.trim()) out.push(cur.trim());
        cur = '';

        if (p.length > m) {
          let q = p;
          while (q.length > m) {
            out.push(q.slice(0, m));
            q = q.slice(m);
          }
          cur = q;
        } else {
          cur = p;
        }
      } else {
        cur += p;
      }
    }

    if (cur.trim()) out.push(cur.trim());

    log(`Final chunks: ${out.length}`, {
      chunkSizes: out.map(c => c.length)
    });

    return out;
  };

  // Decode audio buffer
  const decodeBuffer = a => {
    log(`Decoding audio buffer of size ${a.byteLength}`);
    return new Promise((res, rej) => {
      try {
        ctx.decodeAudioData(a,
          (buffer) => {
            log(`Audio buffer decoded successfully: ${buffer.duration.toFixed(2)}s`);
            res(buffer);
          },
          (err) => {
            log(`Error decoding audio buffer`, err, 'error');
            rej(err);
          }
        );
      } catch (e) {
        log(`Exception in decodeBuffer`, e, 'error');
        rej(e);
      }
    });
  };

  // Prepare text display with clickable words
  const prepareTextDisplay = (text, chunks) => {
    log(`Preparing text display with ${text.length} chars and ${chunks.length} chunks`);

    E.textBox.innerHTML = '';
    wordElements = [];
    wordTimings = []; // Reset word timings
    chunksData = []; // Reset chunks data

    // Initialize chunks data
    for (let i = 0; i < chunks.length; i++) {
      chunksData[i] = {
        text: chunks[i],
        startTime: 0, // Will be calculated when audio is loaded
        endTime: 0,   // Will be calculated when audio is loaded
        wordCount: 0, // Will be calculated below
        duration: 0,  // Will be updated when audio is loaded
        loaded: false
      };
    }

    // Pre-calculate how many words are in each chunk
    chunks.forEach((chunk, idx) => {
      const wordCount = chunk.split(/\s+/).filter(Boolean).length;
      chunksData[idx].wordCount = wordCount;
    });

    // Process words with knowledge of which chunk they belong to
    let currentChunk = 0;
    let chunkWordCount = 0;
    let chunkStartPos = 0;
    let globalWordIndex = 0;

    text.split(/(\s+)/).forEach((part) => {
      if (part.trim()) {
        // This is a word (not whitespace)
        const span = document.createElement('span');
        span.textContent = part;
        span.className = 'word loading'; // Start as loading
        span.dataset.index = globalWordIndex;

        // Find which chunk this word belongs to
        let currentTextPosition = text.indexOf(part, chunkStartPos);
        while (chunkStartPos + chunksData[currentChunk].text.length <= currentTextPosition &&
               currentChunk < chunks.length - 1) {
            chunkStartPos += chunksData[currentChunk].text.length;
            currentChunk++;
            chunkWordCount = 0; // Reset word count for the new chunk
        }

        // Store chunk association
        span.dataset.chunk = currentChunk;

        // Store timing data (will be updated later)
        wordTimings[globalWordIndex] = {
          word: part,
          chunk: currentChunk,
          indexInChunk: chunkWordCount,
          startTime: 0, // Will be calculated when audio is loaded
          endTime: 0    // Will be calculated when audio is loaded
        };

        chunkWordCount++;

        // Add click handler
        span.addEventListener('click', (e) => {
          if (span.classList.contains('loading')) {
            status('That part is still loading...');
            return;
          }
          const clickedIndex = parseInt(e.currentTarget.dataset.index);
          log(`Word clicked: ${e.currentTarget.textContent} (index ${clickedIndex})`);
          seekToWord(clickedIndex);
        });

        wordElements.push(span);
        E.textBox.appendChild(span);
        globalWordIndex++;
      } else {
        // This is whitespace
        E.textBox.appendChild(document.createTextNode(part));
      }
    });

    log(`Text display prepared with ${globalWordIndex} words`);
  };

  // Update word timings when a chunk is loaded
  const updateWordTimings = (chunkIndex, duration) => {
    if (!chunksData[chunkIndex]) return;

    log(`Updating word timings for chunk ${chunkIndex}, duration ${duration.toFixed(2)}s`);

    // Update chunk data
    chunksData[chunkIndex].loaded = true;
    chunksData[chunkIndex].duration = duration;

    // Calculate chunk start time (sum of durations of all previous loaded chunks)
    let chunkStartTime = 0;
    for (let i = 0; i < chunkIndex; i++) {
      // Ensure previous chunks are loaded and have duration before adding
      if (chunksData[i]?.loaded && chunksData[i].duration > 0) {
        chunkStartTime += chunksData[i].duration;
      } else {
         log(`Warning: Chunk ${i} needed for timing calculation of chunk ${chunkIndex} is not loaded or has zero duration. Timing may be inaccurate.`, chunksData[i], 'warn');
      }
    }

    chunksData[chunkIndex].startTime = chunkStartTime;
    chunksData[chunkIndex].endTime = chunkStartTime + duration;

    // Find all words in this chunk
    const chunkWordCount = chunksData[chunkIndex].wordCount;

    // Update timings for all words in this chunk
    wordTimings.forEach((timing, i) => {
      if (timing.chunk === chunkIndex) {
        // Calculate word timing within the chunk
        // Using a simplified linear approach for timing within chunk for now
        const wordStartTime = chunkStartTime + (timing.indexInChunk / chunkWordCount) * duration;
        const nextWordStartTime = chunkStartTime + ((timing.indexInChunk + 1) / chunkWordCount) * duration;
        // Assign end time slightly before the next word starts, or at chunk end for the last word
        const wordEndTime = Math.min(chunkStartTime + duration, nextWordStartTime - 0.01); // Tiny gap

        timing.startTime = wordStartTime;
        timing.endTime = Math.max(wordStartTime + 0.05, wordEndTime); // Ensure minimum duration

        // Remove loading state from the word element
        const el = wordElements[i];
        if (el) {
          el.classList.remove('loading');
        }
      }
    });

    log(`Updated timings for words in chunk ${chunkIndex}`);
  };

  // Find current time position
  const locateTimePosition = (time) => {
    const shouldLog = Math.random() < 0.01;

    if (shouldLog) {
      log(`Locating position for time ${time.toFixed(2)}s`);
    }

    // Use loadedDuration which is sum of durations of *loaded* chunks
    if (time >= loadedDuration && loadingComplete) {
         // If loading is complete and time is past loaded duration, cap at end
         time = totalDuration;
    } else if (time >= loadedDuration && !loadingComplete) {
         // If time is past what's loaded *so far*, use the last loaded chunk
         const lastIndex = chunksData.findLastIndex(c => c.loaded && c.duration > 0);
         if (lastIndex !== -1) {
             return { chunk: lastIndex, offset: chunksData[lastIndex].duration }; // Go to end of last loaded chunk
         } else {
             return { chunk: 0, offset: 0 }; // Fallback to beginning
         }
    }

    // Find the chunk that contains this time using chunksData
    for (let i = 0; i < chunksData.length; i++) {
      if (chunksData[i].loaded &&
          time >= chunksData[i].startTime &&
          time < chunksData[i].endTime) {

        const offset = time - chunksData[i].startTime;
        if (shouldLog) {
          log(`Found time ${time.toFixed(2)}s in chunk ${i} at offset ${offset.toFixed(2)}s`);
        }
        return { chunk: i, offset: offset };
      }
    }

    // Fallback if time is outside known ranges
     let fallbackChunk = 0;
     let fallbackOffset = 0;
     for (let i = 0; i < chunksData.length; i++) {
         if (chunksData[i].loaded && chunksData[i].startTime <= time) {
             fallbackChunk = i;
             fallbackOffset = Math.min(chunksData[i].duration, time - chunksData[i].startTime);
         } else {
             break; // Stop once we pass the target time
         }
     }
     if (shouldLog) {
       log(`Fallback: placing time ${time.toFixed(2)}s in chunk ${fallbackChunk} at offset ${fallbackOffset.toFixed(2)}s`);
     }
     return { chunk: fallbackChunk, offset: fallbackOffset };
  };

  // Seek to a specific time
  const seekToTime = (time) => {
    // Check if *any* chunks are loaded and have duration
    if (!chunksData.some(c => c.loaded && c.duration > 0)) {
      log(`Cannot seek: no audio loaded yet`);
      return;
    }

    // Ensure time is within valid range (0 to total *loaded* duration)
    const maxSeekTime = loadingComplete ? totalDuration : loadedDuration;
    time = Math.max(0, Math.min(time, maxSeekTime));

    log(`Seeking to ${time.toFixed(2)}s`);

    // Find the chunk this time belongs to
    const { chunk, offset } = locateTimePosition(time);

    // Cancel any current playback
    cancelPlayback();

    if (paused) {
      // Just update the paused position
      pausedAt = time;
      updateUI(time);
      log(`Updated paused position to ${time.toFixed(2)}s`);
    } else {
      // Start playback from this position
      // The absoluteTime passed to startPlayback should be the target seek time
      startPlayback(chunk, offset, time);
    }
  };

  // Seek to a specific word
  const seekToWord = (wordIndex) => {
    wordIndex = parseInt(wordIndex);

    if (isNaN(wordIndex) || wordIndex < 0 || wordIndex >= wordElements.length) {
      log(`Cannot seek to word ${wordIndex}: out of range`, {
        wordCount: wordElements.length,
        maxValidIndex: wordElements.length - 1
      });
      return;
    }

    // Get timing data for this word
    const timing = wordTimings[wordIndex];
    if (!timing) {
      log(`No timing data for word ${wordIndex}`, { wordIndex });
      return;
    }

    // Make sure the chunk is loaded
    const chunkIndex = timing.chunk;
    if (!chunksData[chunkIndex]?.loaded || !buffers[chunkIndex]) {
      log(`Word ${wordIndex} (${timing.word}) is in chunk ${chunkIndex} which is not loaded yet`);
      status('Please wait for audio to load.', true); // User feedback
      return;
    }

    // Get the calculated word start time
    const time = timing.startTime;
    log(`Seeking to word "${timing.word}" (index ${wordIndex}) at time ${time.toFixed(2)}s`);

    // Seek to this time
    seekToTime(time);
  };

  // Initialize audio context
  const initAudioContext = () => {
    if (!ctx) {
      log('Initializing AudioContext');
      try {
          ctx = new (window.AudioContext || window.webkitAudioContext)();

          // Create master gain node for volume control
          gainNode = ctx.createGain();
          gainNode.gain.value = E.volume.value;
          gainNode.connect(ctx.destination);

          // Ensure visualizer class is available from voice-visualizer.js
          if (typeof VoiceVisualizer !== 'undefined') {
              visualizer = new VoiceVisualizer('visualizer', ctx, {
                 mode: 'waveform', // or 'frequencybars'
                 color: isDarkMode ? '#8ab4f8' : '#4285f4', // Use theme color
                 stroke: 2
              });
              log('Visualizer initialized.');
          } else {
             log('VoiceVisualizer class not found. Skipping visualizer setup.', null, 'warn');
             // Hide canvas if visualizer fails
             Q('visualizer').style.display = 'none';
          }

          log('AudioContext initialized', {
              sampleRate: ctx.sampleRate,
              state: ctx.state
          });

          // Handle state changes (e.g., interrupted context)
          ctx.onstatechange = () => {
              log(`AudioContext state changed to: ${ctx.state}`);
              if (ctx.state === 'interrupted') {
                  stopPlayback();
                  status('Audio context interrupted.', true);
              } else if (ctx.state === 'suspended') {
                  // Attempt to resume if suspended (e.g., after page backgrounding)
                  ctx.resume().then(() => log('AudioContext resumed successfully.')).catch(e => log('Failed to resume AudioContext', e, 'error'));
              }
          };

      } catch (e) {
          log('Error initializing AudioContext', e, 'error');
          status('Could not initialize audio playback: ' + e.message, true);
          // Disable relevant buttons if context fails
          [E.play, E.pause, E.stop, E.gen].forEach(btn => btn.disabled = true);
          return Promise.reject(e); // Propagate error
      }
    }

    // Resume context if it's suspended (required after user interaction)
    if (ctx.state === 'suspended') {
       log('AudioContext is suspended, attempting to resume...');
       return ctx.resume().then(() => {
           log('AudioContext resumed successfully.');
           return ctx;
       }).catch(e => {
           log('Failed to resume AudioContext', e, 'error');
           status('Could not resume audio. Please interact with the page.', true);
           throw e; // Propagate error
       });
    }

    return Promise.resolve(ctx); // Already running or initialized
  };

  // Start playback from a specific position
  const startPlayback = (chunkIndex, offset = 0, absoluteTime = 0) => {
    initAudioContext().then(() => { // Ensure context is running
        playbackId = Date.now();
        const currentPlayback = playbackId;

        playing = true;
        paused = false;
        // Make sure startTime reflects the *actual* start time in the context's clock
        startTime = ctx.currentTime - absoluteTime;

        log(`Starting playback: chunk ${chunkIndex}, offset ${offset.toFixed(2)}s, abs time ${absoluteTime.toFixed(2)}s, ctxTime: ${ctx.currentTime.toFixed(2)}`);

        E.play.disabled = true;
        E.pause.disabled = false;
        E.stop.disabled = false;
        status(`Playing... ${fmt(absoluteTime)} / ${fmt(totalDuration)}`);

        playChunk(chunkIndex, offset, currentPlayback);
        requestAnimationFrame(updatePlayback);
    }).catch(e => {
        // Error handled in initAudioContext
    });
  };

  // Play a specific chunk
  const playChunk = (index, offset = 0, id) => {
    if (id !== playbackId) {
      log(`Ignoring stale playback request: ${id} vs ${playbackId}`);
      return;
    }

    if (index >= buffers.length || !buffers[index]) { // Also check if buffer exists
      // Check if loading is complete
      if (loadingComplete) {
        log(`Reached end of available audio at chunk ${index}`);
        stopPlayback();
      } else {
         // Buffer not loaded yet, wait and retry
         log(`Chunk ${index} not loaded yet, waiting...`);
         status(`Buffering... (${fmt(chunksData[index-1]?.endTime || 0)} / ${fmt(totalDuration)})`);
         setTimeout(() => {
           if (playing && id === playbackId) {
             playChunk(index, offset, id);
           }
         }, 300); // Wait a bit longer
      }
      return;
    }

    const buffer = buffers[index];
    log(`Playing chunk ${index} from offset ${offset.toFixed(2)}s (duration: ${buffer.duration.toFixed(2)}s)`);

    const source = ctx.createBufferSource();
    source.buffer = buffer;

    // Connect to visualizer only if it exists
    if (visualizer?.analyser) {
        source.connect(visualizer.analyser);
        visualizer.analyser.connect(gainNode);
    } else {
        source.connect(gainNode); // Connect directly to gain if no visualizer
    }

    source.onended = () => {
        // Clean up the reference to the source now that it's ended
        if (audioSources[index] === source) {
             audioSources[index] = null;
        }

        // Only proceed if this is still the active playback and not paused
      if (playing && id === playbackId) {
        log(`Chunk ${index} ended naturally.`);
        // Calculate time elapsed in this chunk to adjust start time for next
        const chunkElapsedTime = buffer.duration - offset;
        // Ensure the next chunk starts immediately without gap/overlap issues
        // The absolute time should have advanced by chunkElapsedTime
        const nextAbsoluteTime = (ctx.currentTime - startTime); // Use context time for accuracy
        log(`Advancing to next chunk. Elapsed in chunk: ${chunkElapsedTime.toFixed(2)}. Next abs time: ${nextAbsoluteTime.toFixed(2)}`);
        playChunk(index + 1, 0, id);
      } else {
         log(`Chunk ${index} ended, but playback stopped or paused (id: ${id}, current: ${playbackId}, playing: ${playing})`);
      }
    };

    audioSources[index] = source;

    // Start playback with the specified offset, ensuring offset is valid
    const validOffset = Math.max(0, Math.min(offset, buffer.duration - 0.001)); // Prevent starting exactly at the end
     if (offset > validOffset) {
         log(`Corrected invalid offset ${offset.toFixed(2)} to ${validOffset.toFixed(2)} for chunk ${index}`, null, 'warn');
     }
    try {
        source.start(0, validOffset);
        // --- MODIFIED LINE ---
        if (visualizer && typeof visualizer.start === 'function') visualizer.start(); // Start visualizer drawing loop
    } catch (e) {
        log(`Error starting source for chunk ${index} at offset ${validOffset}`, e, 'error');
        // Attempt to play next chunk if this one fails immediately
        if (playing && id === playbackId) {
            playChunk(index + 1, 0, id);
        }
    }
  };

  // Cancel any current playback
  const cancelPlayback = () => {
    log('Canceling current playback');
    // --- MODIFIED LINE ---
    if (visualizer && typeof visualizer.stop === 'function') visualizer.stop(); // Stop visualizer drawing loop

    audioSources.forEach((source, i) => {
      if (source) {
        log(`Stopping audio source for chunk ${i}`);
        source.onended = null; // Remove callback
        try { source.stop(); } catch (e) {
          // Ignore errors often caused by stopping already stopped sources
        }
      }
    });

    audioSources = []; // Reset sources array immediately
  };

  // Pause playback
  const pausePlayback = () => {
    if (!playing) {
      log('Cannot pause: not playing');
      return;
    }

    // Calculate pausedAt based on AudioContext time for accuracy
    pausedAt = ctx.currentTime - startTime;
    playing = false;
    paused = true;

    log(`Pausing at ${pausedAt.toFixed(2)}s (ctxTime: ${ctx.currentTime.toFixed(2)})`);

    cancelPlayback(); // Stop the audio nodes

    E.play.disabled = false;
    E.pause.disabled = true;

    status(`Paused at ${fmt(pausedAt)}`);
  };

  // Resume playback
  const resumePlayback = () => {
    if (!paused) {
      log('Cannot resume: not paused');
      return;
    }

    log(`Resuming from ${pausedAt.toFixed(2)}s`);

    // Find the chunk and offset to resume from
    const { chunk, offset } = locateTimePosition(pausedAt);

    // Start playback from the calculated position
    // Pass the pausedAt time as the absolute time reference
    startPlayback(chunk, offset, pausedAt);
  };

  // Stop playback
  const stopPlayback = (silent = false) => {
    cancelPlayback(); // Stop audio nodes

    const wasPlaying = playing;
    const wasPaused = paused;

    playing = false;
    paused = false;
    pausedAt = 0;
    startTime = 0; // Reset start time reference

    // Clear word highlighting
    if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
        if (wordElements[currentWordIndex]) { // Check element exists
            wordElements[currentWordIndex].classList.remove('active');
        }
    }
    currentWordIndex = -1;

    if (!silent && (wasPlaying || wasPaused)) { // Only log/update UI if something was actually stopped
      log('Playback stopped');

      // Reset UI only if audio has been loaded
        if (totalDuration > 0) {
           E.fill.style.width = '0%';
           E.time.textContent = `00:00 / ${fmt(totalDuration)}`;
           E.play.disabled = false; // Enable play if audio is loaded
       } else {
           E.play.disabled = true; // Keep play disabled if no audio loaded
       }
      E.pause.disabled = true;
      E.stop.disabled = true; // Disable stop when not playing/paused
      status('Playback stopped.');
    } else if (!silent) {
       // If stop is called when already stopped, just ensure UI is correct
       E.play.disabled = !(totalDuration > 0);
       E.pause.disabled = true;
       E.stop.disabled = true;
    }
  };

  // Update playback UI
  const updatePlayback = () => {
    if (!playing) return;

    const currentTime = ctx.currentTime - startTime;

    // Use a small buffer to prevent stopping slightly too early due to float precision
    if (currentTime >= totalDuration - 0.05) {
      log(`Reached end of playback (${currentTime.toFixed(2)}s >= ${totalDuration.toFixed(2)}s)`);
      // Ensure UI updates fully before stopping
      updateUI(totalDuration);
      stopPlayback();
      return;
    }

    updateUI(currentTime);
    requestAnimationFrame(updatePlayback);
  };

  // Update UI with current time
  const updateUI = (time) => {
    // Ensure time doesn't exceed total duration for UI display
     const displayTime = Math.min(time, totalDuration);

    // Update progress bar, prevent NaN if totalDuration is 0
    const percentage = totalDuration > 0 ? (displayTime / totalDuration) * 100 : 0;
    E.fill.style.width = `${Math.max(0, Math.min(100, percentage))}%`; // Clamp between 0 and 100

    // Update time display
    E.time.textContent = `${fmt(displayTime)} / ${fmt(totalDuration)}`;

    // Update word highlighting
    updateWordHighlight(displayTime);

     // Update status message during playback
     if (playing) {
       status(`Playing... ${fmt(displayTime)} / ${fmt(totalDuration)}`);
     }
  };

  // Update word highlighting based on actual word timings
  const updateWordHighlight = (time) => {
    let newWordIndex = -1;

    // Find the word whose timing range contains the current time
    for (let i = 0; i < wordTimings.length; i++) {
      const timing = wordTimings[i];
      // Check if timing data exists and is valid before using
      if (timing && typeof timing.startTime === 'number' && typeof timing.endTime === 'number') {
         if (timing.startTime <= time && time <= timing.endTime) {
            newWordIndex = i;
            break;
         }
      }
    }

    // If no exact match, find the *last* word whose start time is *before* the current time
    if (newWordIndex === -1) {
        for (let i = wordTimings.length - 1; i >= 0; i--) {
            const timing = wordTimings[i];
             if (timing && typeof timing.startTime === 'number' && time >= timing.startTime) {
                 newWordIndex = i;
                 break;
             }
        }
    }

    // Only update if it's a different word
    if (newWordIndex !== currentWordIndex && newWordIndex !== -1) {
        // Remove highlight from previous word
        if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
            if (wordElements[currentWordIndex]) { // Check element exists
                wordElements[currentWordIndex].classList.remove('active');
            }
        }

        // Add highlight to current word
        if (newWordIndex >= 0 && newWordIndex < wordElements.length) {
            const wordEl = wordElements[newWordIndex];
            if (wordEl) { // Check element exists
                wordEl.classList.add('active');

                // Ensure word is visible (scroll into view logic)
                 const container = E.textBox;
                 const wordTop = wordEl.offsetTop - container.offsetTop; // Position relative to container
                 const wordBottom = wordTop + wordEl.offsetHeight;
                 const containerScrollTop = container.scrollTop;
                 const containerHeight = container.clientHeight;
                 const scrollBuffer = 30; // Pixels buffer from top/bottom

                 if (wordTop < containerScrollTop + scrollBuffer) {
                     // Word is above viewport
                     container.scrollTop = Math.max(0, wordTop - scrollBuffer);
                 } else if (wordBottom > containerScrollTop + containerHeight - scrollBuffer) {
                     // Word is below viewport
                     container.scrollTop = wordBottom - containerHeight + scrollBuffer;
                 }
            }
        }

        currentWordIndex = newWordIndex;
    }
  };

  // Progress bar click handler
  E.prog.onclick = e => {
    if (!totalDuration) return; // Don't allow seeking if no audio loaded

    const rect = E.prog.getBoundingClientRect();
    const ratio = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)); // Clamp ratio 0-1
    const targetTime = ratio * (loadingComplete ? totalDuration : loadedDuration); // Seek within loaded duration if not complete

    log(`Progress bar clicked at ${ratio.toFixed(2)} (${targetTime.toFixed(2)}s)`);
    seekToTime(targetTime);
  };

  // Playback control buttons
  E.play.onclick = () => {
    if (paused) {
      resumePlayback();
    } else {
      startPlayback(0, 0, 0); // Start from beginning if not paused
    }
  };

  E.pause.onclick = pausePlayback;
  E.stop.onclick = () => stopPlayback(false); // Pass false to ensure UI updates

  // Create download link
  const createDownloadLink = () => {
    log('Creating download link');

    // Check if there are actually blobs to download
    const validBlobs = audioBlobs.filter(blob => blob instanceof Blob && blob.size > 0);

    if (!validBlobs.length) {
      log('No valid audio blobs to download', null, 'error');
      status('No audio available for download', true);
      return;
    }

    try {
      log(`Creating combined blob from ${validBlobs.length} chunks`);

      // Create a single blob from all valid chunks
      const combinedBlob = new Blob(validBlobs,
      { type: 'audio/mp3' });

      log(`Combined blob created: ${(combinedBlob.size / 1024 / 1024).toFixed(2)} MB`);

      // Create download link
      const url = URL.createObjectURL(combinedBlob);

      // Trigger download
      const a = document.createElement('a');
      const fileName = 'speech_' + new Date().toISOString().replace(/[:.]/g, '-') + '.mp3';
      a.href = url;
      a.download = fileName;

      log(`Triggering download: ${fileName}`);
      document.body.appendChild(a);
      a.click();

      // Clean up
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log('Download cleanup complete');
      }, 100);

      status('Download started', false);
    } catch (err) {
      log('Error creating download', err, 'error');
      status('Failed to create download: ' + err.message, true);
    }
  };

  // Download button
  E.download.onclick = createDownloadLink;

  // Generate speech
  E.gen.onclick = async () => {
    // Check for access token instead of API key
    if (!accessToken) {
         status('Please sign in first to generate speech.', true);
         if (tokenClient) {
            tokenClient.requestAccessToken({ prompt: 'consent' });
         } else {
            log('Token client not ready for sign-in prompt.', null, 'warn');
            status('Authentication system not ready.', true);
         }
         return;
    }
    if (!E.voice.value) return status('Select a voice first (Load Voices if needed).', true);

    try {
      // Initialize audio context and ensure it's running
      await initAudioContext();

      const text = E.txt.value.trim();
      if (!text) return status('Enter text to synthesize.', true);

      // Reset state
      stopPlayback(true); // Stop silently
      buffers = [];
      audioBlobs = [];
      audioSources = [];
      wordTimings = []; // Reset timings
      chunksData = []; // Reset chunk details
      totalDuration = 0;
      loadedDuration = 0; // Reset loaded duration
      loadingComplete = false;
      E.download.disabled = true;
      E.play.disabled = true; // Disable playback buttons until first chunk loads
      E.pause.disabled = true;
      E.stop.disabled = true;

      // Split text into chunks
      const chunks = splitText(text);
      if (!chunks.length) return status('Failed to split text into processable chunks.', true);

      totalChunks = chunks.length;
      chunksReceived = 0;

      // Prepare UI
      status(`Requesting synthesis for ${chunks.length} chunk(s)...`);
      prepareTextDisplay(text, chunks); // Prepare text display with loading words
      E.gen.disabled = true; // Disable generate button during processing
      E.load.disabled = true; // Disable load voices during processing

      // Initialize buffers array
      buffers = new Array(chunks.length).fill(null); // Use null as placeholder
      audioBlobs = new Array(chunks.length).fill(null);

      // Create request body template
      const createRequest = chunk => ({
        input: { text: chunk },
        voice: {
          languageCode: E.voice.selectedOptions[0].dataset.l,
          name: E.voice.value
        },
        audioConfig: {
          audioEncoding: 'MP3',
          pitch: +E.pit.value,
          speakingRate: +E.rat.value
        }
      });

      // Process chunks in parallel
      const chunkPromises = chunks.map(async (chunk, index) => {
        try {
          log(`Generating chunk ${index + 1}/${chunks.length} (${chunk.length} chars)`);

          // Use Authorization header with Bearer token
          const response = await fetchJSON(SY, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ' + accessToken
            },
            body: JSON.stringify(createRequest(chunk))
          });

          if (!response.audioContent) {
            throw new Error(`No audio content in response for chunk ${index + 1}`);
          }

          log(`Received audio content for chunk ${index + 1}`);

          // Convert base64 to ArrayBuffer
          const audioData = atob(response.audioContent);
          const arrayBuffer = new Uint8Array(audioData.length);
          for (let i = 0; i < audioData.length; i++) {
            arrayBuffer[i] = audioData.charCodeAt(i);
          }

          // Store the audio blob for downloading
          const blob = new Blob([arrayBuffer], { type: 'audio/mp3' });
          audioBlobs[index] = blob;

          log(`Created blob for chunk ${index + 1}: ${(blob.size / 1024).toFixed(2)} KB`);

          // Create a copy of the array buffer for decoding
          const bufferCopy = arrayBuffer.buffer.slice(0);

          // Decode audio
          try {
            const audioBuffer = await decodeBuffer(bufferCopy);

            // Store the decoded buffer
            buffers[index] = audioBuffer;

            // Update word timings with actual audio duration for this chunk
            updateWordTimings(index, audioBuffer.duration);

            // Update cumulative loaded duration
            loadedDuration = chunksData.reduce((sum, chunkData) => {
                return sum + (chunkData.loaded ? chunkData.duration : 0);
            }, 0);

            // Update overall total duration for UI
            totalDuration = loadedDuration;

            log(`Chunk ${index + 1} decoded: ${audioBuffer.duration.toFixed(2)}s. Loaded duration: ${loadedDuration.toFixed(2)}s`);

            // Update progress
            chunksReceived++;
            status(`Processing... ${chunksReceived}/${totalChunks} chunks loaded. (${fmt(loadedDuration)} loaded)`);

            // Autoplay first chunk when it's ready and enable playback controls
            if (index === 0 && !playing && !paused) {
                E.play.disabled = false;
                E.stop.disabled = false;
                startPlayback(0, 0, 0);
            } else if (index > 0 && !playing && !paused && buffers[0]) {
                E.play.disabled = false;
                E.stop.disabled = false;
            }

            return index; // Indicate success for this chunk
          } catch (decodeError) {
            log(`Error decoding chunk ${index + 1}`, decodeError, 'error');
            if (chunksData[index]) chunksData[index].loaded = false;
            throw new Error(`Failed to decode audio for chunk ${index + 1}: ${decodeError.message}`);
          }
        } catch (error) {
          log(`Error processing chunk ${index + 1}`, error, 'error');
          if (error.message.includes('401') || error.message.includes('403')) {
               accessToken = null;
               E.authStatus.textContent = '‚ö†Ô∏è Re-authentication needed';
               E.load.disabled = true;
               status(`Chunk ${index + 1} failed: Authentication error. Please sign in again.`, true);
          } else {
               status(`Chunk ${index + 1} failed: ${error.message}`, true);
          }
          if (chunksData[index]) chunksData[index].loaded = false;
          return null; // Indicate failure for this chunk
        }
      });

      // Wait for all chunk processing promises to settle
      await Promise.allSettled(chunkPromises);

      loadingComplete = true;

      // Final calculation of total duration
      totalDuration = chunksData.reduce((sum, chunkData) => {
         return sum + (chunkData.loaded ? chunkData.duration : 0);
      }, 0);
      log(`All chunks settled. Final total duration: ${totalDuration.toFixed(2)}s`);

      // Update UI based on final state
      updateUI(playing ? ctx.currentTime - startTime : pausedAt);

      const successCount = chunksData.filter(c => c.loaded).length;
      if (successCount === totalChunks) {
        log('All chunks processed successfully', { totalDuration });
        status(`Synthesis complete. Total duration: ${fmt(totalDuration)}`, false);
        E.download.disabled = false;
      } else {
        log(`Some chunks failed (${successCount}/${totalChunks})`, null, 'warn');
        status(`Completed ${successCount}/${totalChunks} chunks. Total duration: ${fmt(totalDuration)}`, successCount > 0);
        if (successCount > 0) E.download.disabled = false;
      }

    } catch (e) {
      log('Generation process failed', e, 'error');
      status(`Generation failed: ${e.message}`, true);
    } finally {
      E.gen.disabled = false;
      E.load.disabled = !accessToken;
      if (!playing && !paused) {
          E.play.disabled = !(totalDuration > 0);
          E.pause.disabled = true;
          E.stop.disabled = true;
      }
    }
  };

  // Add keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Don't trigger shortcuts when typing in inputs/textareas or contenteditable elements
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

    // Space - Play/Pause
    if (e.code === 'Space') {
      e.preventDefault();
      if (playing && !E.pause.disabled) E.pause.click();
      else if ((paused || (loadingComplete && totalDuration > 0)) && !E.play.disabled) E.play.click();
    }

    // Escape - Stop
    if (e.code === 'Escape' && (playing || paused) && !E.stop.disabled) {
      e.preventDefault();
      E.stop.click();
    }

    // G - Generate
    if (e.code === 'KeyG' && !E.gen.disabled) {
      e.preventDefault();
      E.gen.click();
    }

    // D - Download
    if (e.code === 'KeyD' && !E.download.disabled) {
      e.preventDefault();
      E.download.click();
    }

    // T - Toggle theme
    if (e.code === 'KeyT') {
      e.preventDefault();
      E.themeToggle.click();
    }

    // Left/Right arrow - Skip 5 seconds
    if (e.code === 'ArrowLeft' && (playing || paused)) {
      e.preventDefault();
      const currentTime = playing ? ctx.currentTime - startTime : pausedAt;
      seekToTime(currentTime - 5);
    }
    if (e.code === 'ArrowRight' && (playing || paused)) {
      e.preventDefault();
      const currentTime = playing ? ctx.currentTime - startTime : pausedAt;
      seekToTime(currentTime + 5);
    }

    // Up/Down arrow - Adjust volume
    if (e.code === 'ArrowUp') {
      e.preventDefault();
      const currentVolume = parseFloat(E.volume.value);
      E.volume.value = Math.min(1, currentVolume + 0.1);
      if (gainNode) gainNode.gain.value = E.volume.value;
      log(`Volume up: ${E.volume.value}`);
    }
    if (e.code === 'ArrowDown') {
      e.preventDefault();
      const currentVolume = parseFloat(E.volume.value);
      E.volume.value = Math.max(0, currentVolume - 0.1);
      if (gainNode) gainNode.gain.value = E.volume.value;
      log(`Volume down: ${E.volume.value}`);
    }
  });

  // Log initial state
  log('Application initialized - OAuth Version', {
    version: '1.3.0-oauth',
    date: '2025-04-26',
    user: 'Doodle-Med',
    debugEnabled: debugEnabled
  });

  // Initial UI state after setup
  E.play.disabled = true;
  E.pause.disabled = true;
  E.stop.disabled = true;
  E.download.disabled = true;
  E.gen.disabled = true;
  E.voice.disabled = true;

  // E.load.disabled = true is now handled by the OAuth system itself

}); // End DOMContentLoaded
</script>
</body>
</html>
