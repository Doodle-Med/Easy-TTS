<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<style>
:root{
  --c1:#4285f4;
  --c2:#34a853;
  --c3:#ea4335;
  --c4:#fbbc04;
  --bg:#fdfdfd;
  --fg:#202124;
  --bd:#dadce0;
  --r:10px;
  --shadow: 0 4px 12px rgba(0,0,0,.05);
  --hover: rgba(66,133,244,0.1);
}
*{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif}
body{background:var(--bg);color:var(--fg);padding:1rem;max-width:1200px;margin:auto}
h1{font-size:clamp(1.7rem,2.5vw,3rem);text-align:center;margin-bottom:1rem;background:linear-gradient(90deg,var(--c1),var(--c2),var(--c4),var(--c3));-webkit-background-clip:text;color:transparent;font-weight:800}
.grid{display:grid;gap:1rem}.two{grid-template-columns:1fr 1fr}@media(max-width:800px){.two{grid-template-columns:1fr}}
.card{background:#fff;border:1px solid var(--bd);border-radius:var(--r);box-shadow:var(--shadow);padding:1.2rem;position:relative}
.card-header{display:flex;align-items:center;margin-bottom:1rem;}
.card-header h2{flex:1;font-size:1.3rem;}
label{font-weight:600;margin:.6rem 0 .3rem;display:block}
input,select,textarea,button{width:100%;padding:.55rem .65rem;border:1px solid var(--bd);border-radius:6px;font-size:1rem;margin-bottom:.8rem}
input:focus,select:focus,textarea:focus{border-color:var(--c1);outline:none}
textarea{resize:vertical;min-height:140px}
button{cursor:pointer;background:var(--c1);color:#fff;border:none;font-weight:600}
button:not(:disabled):hover{background:#3367d6}
button:disabled{background:var(--bd);cursor:not-allowed;}
.small-btn{width:auto}
.toggle{display:flex;gap:.5rem;margin:.6rem 0}.toggle button{flex:1;background:var(--bg);border:1px solid var(--bd);color:var(--fg)}
.toggle .active{background:var(--c2);color:#fff;border-color:var(--c2)}
.status{min-height:1.4em;font-size:.95rem;margin:.5rem 0}.error{color:var(--c3);font-weight:700}
.success{color:var(--c2);font-weight:700}
.bar{height:12px;background:var(--bd);border-radius:6px;overflow:hidden;cursor:pointer;margin:.8rem 0}
.fill{height:100%;background:linear-gradient(90deg,var(--c1),var(--c2));width:0}
.audio{display:flex;align-items:center;gap:.6rem}
.audio button{width:44px;border-radius:50%;aspect-ratio:1/1;font-size:1.1rem;display:grid;place-items:center}
.time{font-family:monospace;margin-left:auto}
.text-box{background:#fff;border:1px solid var(--bd);border-radius:var(--r);padding:1rem;max-height:340px;overflow:auto;line-height:1.6}
.word{display:inline-block;cursor:pointer;border-radius:3px;padding:1px 2px}
.word:hover{background:#f1f3f4}
.word.active{background:rgba(66,133,244,.25);color:var(--c1);font-weight:700}
.word.loading{background:#f1f3f4;cursor:wait;opacity:0.6}
.spinner{display:inline-block;width:14px;height:14px;border:2px solid rgba(0,0,0,0.1);border-radius:50%;border-top-color:var(--c1);animation:spin 0.8s linear infinite;margin-right:5px}
@keyframes spin{to{transform:rotate(360deg)}}
.controls{display:flex;align-items:center;gap:0.5rem;margin-bottom:0.8rem;}
.controls button{margin-bottom:0;}
.volume-control{display:flex;align-items:center;gap:0.5rem;flex:1;}
.volume-control input{margin:0;}
.download-btn{margin-left:auto;}
.hidden{display:none}
</style>
</head>
<body>
<h1>Google Cloud TTS Playground</h1>
<div class="grid two">
  <div class="card">
    <div class="card-header">
      <h2>üéõÔ∏è Configuration</h2>
    </div>
    <label>API Key</label>
    <div class="controls">
      <input id="k" type="password" placeholder="Enter your Google Cloud API Key"/>
      <button class="small-btn" id="ld">Load Voices</button>
    </div>
    <div id="loading" class="status hidden"><span class="spinner"></span>Loading voices...</div>
    
    <label>Text</label>
    <textarea id="txt" placeholder="Type or paste text here..."></textarea>
    
    <label>Voice</label>
    <select id="v" disabled></select>
    
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:.8rem">
      <div>
        <label>Pitch <span id="pitVal">0</span></label>
        <input id="pit" type="range" min="-20" max="20" value="0"/>
      </div>
      <div>
        <label>Rate <span id="ratVal">1</span></label>
        <input id="rat" type="range" min="0.25" max="4" step="0.05" value="1"/>
      </div>
    </div>
    
    <label>Chunk Size <span id="chkVal">1000</span></label>
    <input id="chk" type="range" min="500" max="4500" step="500" value="1000"/>
    
    <div class="toggle" id="method">
      <button data-m="sentence">Sentence</button>
      <button data-m="paragraph" class="active">Paragraph</button>
      <button data-m="exact">Exact</button>
    </div>
    
    <button id="gen" disabled>üé§ Generate & Play</button>
    <div id="stat" class="status"></div>
  </div>
  
  <div class="card">
    <div class="card-header">
      <h2>üîä Playback</h2>
    </div>
    <div id="text" class="text-box"><p style="opacity:.6;text-align:center;">Words will appear here...</p></div>
    
    <div class="bar" id="prog">
      <div class="fill" id="fill"></div>
    </div>
    
    <div class="audio">
      <button class="small-btn" id="play" disabled title="Play">‚ñ∂</button>
      <button class="small-btn" id="pause" disabled title="Pause">‚è∏</button>
      <button class="small-btn" id="stop" disabled title="Stop">‚èπ</button>
      
      <div class="volume-control">
        <span>üîä</span>
        <input type="range" id="volume" min="0" max="1" step="0.1" value="1"/>
      </div>
      
      <span class="time" id="time">00:00 / 00:00</span>
    </div>
    
    <button id="download" class="download-btn" disabled>üíæ Download Audio</button>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  // API endpoints & DOM elements
  const VO = 'https://texttospeech.googleapis.com/v1/voices';
  const SY = 'https://texttospeech.googleapis.com/v1/text:synthesize';
  const Q = id => document.getElementById(id);
  const E = {
    key: Q('k'),
    load: Q('ld'),
    loading: Q('loading'),
    txt: Q('txt'),
    voice: Q('v'),
    pit: Q('pit'),
    rat: Q('rat'),
    pitVal: Q('pitVal'),
    ratVal: Q('ratVal'),
    chk: Q('chk'),
    chkVal: Q('chkVal'),
    gen: Q('gen'),
    stat: Q('stat'),
    methodBtns: [...Q('method').children],
    textBox: Q('text'),
    play: Q('play'),
    pause: Q('pause'),
    stop: Q('stop'),
    volume: Q('volume'),
    download: Q('download'),
    prog: Q('prog'),
    fill: Q('fill'),
    time: Q('time')
  };

  // App state
  let API = localStorage.getItem('apiKey') || '';
  let ctx;
  let gainNode;
  let voices = [];
  let buffers = [];
  let rawBuffers = []; // For downloading
  let audioSources = []; // Track all audio sources
  let wordElements = []; // Store word elements for efficient lookup
  let wordOffsets = []; // Track which chunk each word belongs to
  let totalDuration = 0; // Total final duration
  let loadedDuration = 0; // Duration of loaded chunks so far
  let startTime = 0; // When playback started
  let pausedAt = 0; // Where we paused
  let playbackId = 0; // Used to cancel stale playback
  let playing = false;
  let paused = false;
  let method = 'paragraph';
  let currentWordIndex = -1;
  let loadingComplete = false;
  let chunksReceived = 0;
  let totalChunks = 0;
  
  // Initialize API key if saved
  if (API) {
    E.key.value = API;
    // Auto-load voices if API key is saved
    setTimeout(() => E.load.click(), 500);
  }

  // Utilities
  const fmt = s => `${String(Math.floor(s/60)).padStart(2, '0')}:${String(Math.floor(s%60)).padStart(2, '0')}`;
  
  const status = (m, isError) => {
    E.stat.textContent = m;
    E.stat.className = 'status' + (isError ? ' error' : isError === false ? ' success' : '');
    console.log(isError ? `Error: ${m}` : m);
  };
  
  // JSON fetch helper with error handling
  const fetchJSON = async (url, opts) => {
    try {
      const r = await fetch(url, opts);
      if (!r.ok) {
        let m = `HTTP ${r.status}`;
        try {
          const errorData = await r.json();
          m = errorData.error?.message || m;
          console.log('API Error', errorData);
        } catch (e) {
          console.log('Failed to parse error response', e);
        }
        throw new Error(m);
      }
      return r.json();
    } catch (e) {
      console.log('Fetch error:', e);
      throw e;
    }
  };

  // UI event binding
  ['pit', 'rat', 'chk'].forEach(id => {
    E[id].addEventListener('input', e => {
      const span = E[`${id}Val`];
      if (span) {
        const val = id === 'rat' ? parseFloat(e.target.value).toFixed(2) : e.target.value;
        span.textContent = val;
      }
    });
  });
  
  // Initialize volume control
  E.volume.addEventListener('input', () => {
    if (gainNode) {
      gainNode.gain.value = E.volume.value;
    }
  });

  // Load voices from Google TTS API
  E.load.onclick = async () => {
    API = E.key.value.trim();
    if (!API) return status('API key required', true);
    
    // Save API key to localStorage
    localStorage.setItem('apiKey', API);
    
    E.loading.classList.remove('hidden');
    E.load.disabled = true;
    status('Loading voices...');
    
    try {
      console.log(`Requesting voices from ${VO}`);
      const d = await fetchJSON(`${VO}?key=${API}`);
      voices = d.voices || [];
      
      if (!voices.length) throw new Error('No voices returned');
      
      console.log(`Loaded ${voices.length} voices`);
      
      // Group voices by language
      const langMap = new Map();
      voices.forEach(v => {
        v.languageCodes.forEach(code => {
          let name;
          try {
            name = new Intl.DisplayNames(['en'], { type: 'language' }).of(code);
          } catch (e) {
            name = code;
          }
          
          if (!langMap.has(code)) {
            langMap.set(code, { name, voices: [] });
          }
          langMap.get(code).voices.push(v);
        });
      });
      
      // Sort languages by name
      const sortedLangs = [...langMap.entries()]
        .sort((a, b) => a[1].name.localeCompare(b[1].name));
      
      // Group options by language
      const html = sortedLangs.map(([code, { name, voices }]) => {
        const options = voices
          .sort((a, b) => a.name.localeCompare(b.name))
          .map(v => {
            const isNeural = v.name.includes('Neural') || v.name.includes('Wavenet');
            return `<option value="${v.name}" data-l="${code}">${v.name} ${isNeural ? '(Neural)' : ''}</option>`;
          })
          .join('');
        
        return `<optgroup label="${name}">${options}</optgroup>`;
      }).join('');
      
      E.voice.innerHTML = html;
      E.voice.disabled = false;
      E.gen.disabled = false;
      
      status('Voices loaded successfully', false);
    } catch (e) {
      status(`Failed to load voices: ${e.message}`, true);
    } finally {
      E.loading.classList.add('hidden');
      E.load.disabled = false;
    }
  };

  // Configure chunk splitting method
  E.methodBtns.forEach(b => b.onclick = () => {
    E.methodBtns.forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    method = b.dataset.m;
    console.log(`Splitting method changed to: ${method}`);
  });

  // Split text into chunks based on selected method
  const splitText = t => {
    const m = +E.chk.value;
    if (t.length <= m) return [t];
    
    if (method === 'exact') {
      const a = [];
      for (let i = 0; i < t.length; i += m) {
        a.push(t.slice(i, i + m));
      }
      return a;
    }
    
    const re = method === 'paragraph' ? /\n\s*\n/ : /([.!?]+["']?\s+)/;
    const bits = t.split(re).filter(Boolean);
    const out = [];
    let cur = '';
    
    for (const p of bits) {
      if ((cur + p).length > m) {
        if (cur.trim()) out.push(cur.trim());
        cur = '';
        
        if (p.length > m) {
          let q = p;
          while (q.length > m) {
            out.push(q.slice(0, m));
            q = q.slice(m);
          }
          cur = q;
        } else {
          cur = p;
        }
      } else {
        cur += p;
      }
    }
    
    if (cur.trim()) out.push(cur.trim());
    
    console.log(`Split into ${out.length} chunks using ${method} method`);
    
    return out;
  };

  // Decode audio buffer
  const decodeBuffer = a => new Promise((res, rej) => ctx.decodeAudioData(a, res, rej));

  // Prepare text display with clickable words
  const prepareTextDisplay = (text, chunks) => {
    E.textBox.innerHTML = '';
    wordElements = [];
    wordOffsets = [];
    
    let globalWordIndex = 0;
    let currentChunk = 0;
    let chunkStart = 0;
    let chunkEnd = chunks[0]?.length || 0;
    
    // Split text into words and spaces
    text.split(/(\s+)/).forEach((part, i) => {
      if (part.trim()) {
        // This is a word (not whitespace)
        const span = document.createElement('span');
        span.textContent = part;
        span.className = 'word loading'; // Start as loading
        span.dataset.index = globalWordIndex;
        
        // Track which chunk this word belongs to
        while (i > chunkEnd && currentChunk < chunks.length - 1) {
          currentChunk++;
          chunkStart = chunkEnd;
          chunkEnd += chunks[currentChunk].length;
        }
        
        span.dataset.chunk = currentChunk;
        wordOffsets[globalWordIndex] = currentChunk;
        
        span.addEventListener('click', () => {
          if (span.classList.contains('loading')) {
            status('That part is still loading...');
            return;
          }
          seekToWord(globalWordIndex);
        });
        
        wordElements.push(span);
        E.textBox.appendChild(span);
        globalWordIndex++;
      } else {
        // This is whitespace
        E.textBox.appendChild(document.createTextNode(part));
      }
    });
    
    console.log(`Prepared text display with ${globalWordIndex} words`);
  };

  // Find which chunk and offset to play for a given time
  const locateTimePosition = (time) => {
    let currentTime = 0;
    
    // Handle case where time is beyond loaded duration
    if (time >= loadedDuration) {
      const lastIndex = buffers.findLastIndex(b => b);
      return { chunk: lastIndex === -1 ? 0 : lastIndex, offset: 0 };
    }
    
    // Find the chunk that contains this time
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      if (!buffer) continue; // Skip unloaded chunks
      
      const duration = buffer.duration;
      if (time < currentTime + duration) {
        return { chunk: i, offset: time - currentTime };
      }
      
      currentTime += duration;
    }
    
    // Fallback to beginning of last loaded chunk
    const lastLoaded = buffers.findLastIndex(b => b);
    return { chunk: lastLoaded === -1 ? 0 : lastLoaded, offset: 0 };
  };

  // Seek to a specific time
  const seekToTime = (time) => {
    if (!buffers.some(b => b)) return;
    
    // Ensure time is within valid range
    time = Math.max(0, Math.min(time, loadedDuration));
    
    console.log(`Seeking to ${time.toFixed(2)}s`);
    
    // Find the chunk this time belongs to
    const { chunk, offset } = locateTimePosition(time);
    
    // Cancel any current playback
    cancelPlayback();
    
    if (paused) {
      // Just update the paused position
      pausedAt = time;
      updateUI(time);
    } else {
      // Start playback from this position
      startPlayback(chunk, offset, time);
    }
  };

  // Seek to a specific word
  const seekToWord = (wordIndex) => {
    if (!buffers.some(b => b) || wordIndex < 0 || wordIndex >= wordElements.length) return;
    
    // Make sure the corresponding chunk is loaded
    const chunkIndex = wordOffsets[wordIndex];
    if (chunkIndex === undefined || !buffers[chunkIndex]) {
      console.log(`Word ${wordIndex} is in chunk ${chunkIndex} which is not loaded yet`);
      return;
    }
    
    // Calculate time based on word position in text
    const time = estimateTimeForWord(wordIndex);
    console.log(`Seeking to word ${wordIndex} at estimated time ${time.toFixed(2)}s`);
    
    seekToTime(time);
  };

  // Estimate time for a word
  const estimateTimeForWord = (wordIndex) => {
    if (wordIndex < 0 || wordIndex >= wordElements.length) return 0;
    
    // Get the chunk this word belongs to
    const chunkIndex = wordOffsets[wordIndex];
    if (chunkIndex === undefined) return 0;
    
    // Find all words in this chunk
    const wordsInChunk = wordElements.filter((_, i) => wordOffsets[i] === chunkIndex);
    if (!wordsInChunk.length) return 0;
    
    // Get base time (start of chunk)
    let baseTime = 0;
    for (let i = 0; i < chunkIndex; i++) {
      if (buffers[i]) baseTime += buffers[i].duration;
    }
    
    // If we don't have this chunk loaded, estimate based on overall
    if (!buffers[chunkIndex]) {
      return baseTime;
    }
    
    // Find position of word within its chunk
    const chunkWords = wordElements.filter((_, i) => wordOffsets[i] === chunkIndex);
    const indexInChunk = chunkWords.findIndex(el => +el.dataset.index === wordIndex);
    
    if (indexInChunk === -1) return baseTime;
    
    // Calculate offset within chunk
    const chunkDuration = buffers[chunkIndex].duration;
    const offsetInChunk = chunkDuration * (indexInChunk / chunkWords.length);
    
    return baseTime + offsetInChunk;
  };

  // Initialize audio context
  const initAudioContext = () => {
    if (!ctx) {
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create master gain node for volume control
      gainNode = ctx.createGain();
      gainNode.gain.value = E.volume.value;
      gainNode.connect(ctx.destination);
    }
    
    return ctx.resume(); // Ensure it's running
  };

  // Start playback from a specific position
  const startPlayback = (chunkIndex, offset = 0, absoluteTime = 0) => {
    // Ensure audio context is initialized
    initAudioContext();
    
    // Generate a new playback ID to track this session
    playbackId = Date.now();
    const currentPlayback = playbackId;
    
    // Update state
    playing = true;
    paused = false;
    startTime = ctx.currentTime - absoluteTime;
    
    console.log(`Starting playback: chunk ${chunkIndex}, offset ${offset.toFixed(2)}s, abs time ${absoluteTime.toFixed(2)}s`);
    
    // Update UI
    E.play.disabled = true;
    E.pause.disabled = false;
    E.stop.disabled = false;
    
    // Start playing from the specified position
    playChunk(chunkIndex, offset, currentPlayback);
    
    // Start the update loop
    requestAnimationFrame(updatePlayback);
  };

  // Play a specific chunk
  const playChunk = (index, offset = 0, id) => {
    // Check if this playback request is still valid
    if (id !== playbackId) {
      console.log(`Ignoring stale playback request: ${id} vs ${playbackId}`);
      return;
    }
    
    // Check if we've reached the end
    if (index >= buffers.length) {
      console.log('Reached end of audio');
      stopPlayback();
      return;
    }
    
    // Get the audio buffer for this chunk
    const buffer = buffers[index];
    
    // If the buffer isn't loaded yet, wait and retry
    if (!buffer) {
      console.log(`Chunk ${index} not loaded yet, waiting...`);
      setTimeout(() => {
        if (playing && id === playbackId) {
          playChunk(index, offset, id);
        }
      }, 300);
      return;
    }
    
    console.log(`Playing chunk ${index} from offset ${offset.toFixed(2)}s`);
    
    // Create a new audio source
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(gainNode);
    
    // When this chunk ends, play the next one
    source.onended = () => {
      // Only proceed if this is still the active playback
      if (playing && id === playbackId) {
        console.log(`Chunk ${index} ended, playing next chunk`);
        playChunk(index + 1, 0, id);
      }
    };
    
    // Save the source so we can stop it later
    audioSources[index] = source;
    
    // Start playback with the specified offset
    source.start(0, Math.min(offset, buffer.duration));
  };

  // Cancel any current playback
  const cancelPlayback = () => {
    // Stop all audio sources
    audioSources.forEach(source => {
      if (source) {
        source.onended = null; // Remove callback
        try { source.stop(); } catch (e) {}
      }
    });
    
    // Reset sources array
    audioSources = [];
    
    // Generate a new playback ID to invalidate any pending callbacks
    playbackId = Date.now();
  };

  // Pause playback
  const pausePlayback = () => {
    if (!playing) return;
    
    pausedAt = ctx.currentTime - startTime;
    playing = false;
    paused = true;
    
    console.log(`Pausing at ${pausedAt.toFixed(2)}s`);
    
    // Cancel current playback
    cancelPlayback();
    
    // Update UI
    E.play.disabled = false;
    E.pause.disabled = true;
    
    status(`Paused at ${fmt(pausedAt)}`);
  };

  // Resume playback
  const resumePlayback = () => {
    if (!paused) return;
    
    console.log(`Resuming from ${pausedAt.toFixed(2)}s`);
    
    // Find the chunk to resume from
    const { chunk, offset } = locateTimePosition(pausedAt);
    
    // Start playback from the pause position
    startPlayback(chunk, offset, pausedAt);
  };

  // Stop playback
  const stopPlayback = (silent = false) => {
    // Cancel current playback
    cancelPlayback();
    
    // Reset state
    playing = false;
    paused = false;
    pausedAt = 0;
    
    // Clear word highlighting
    if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
      wordElements[currentWordIndex].classList.remove('active');
    }
    currentWordIndex = -1;
    
    if (!silent) {
      console.log('Playback stopped');
      
      // Reset UI
      E.fill.style.width = '0%';
      E.time.textContent = `00:00 / ${fmt(totalDuration)}`;
      E.play.disabled = false;
      E.pause.disabled = true;
      E.stop.disabled = false;
    }
  };

  // Update playback UI (called on each animation frame)
  const updatePlayback = () => {
    if (!playing) return;
    
    // Calculate current time
    const currentTime = ctx.currentTime - startTime;
    
    // Check if we've reached the end
    if (currentTime >= totalDuration) {
      stopPlayback();
      return;
    }
    
    // Update UI
    updateUI(currentTime);
    
    // Continue updates
    requestAnimationFrame(updatePlayback);
  };

  // Update UI with current time
  const updateUI = (time) => {
    // Update progress bar
    const percentage = totalDuration > 0 ? (time / totalDuration) * 100 : 0;
    E.fill.style.width = `${percentage}%`;
    
    // Update time display
    E.time.textContent = `${fmt(time)} / ${fmt(totalDuration)}`;
    
    // Update word highlighting
    updateWordHighlight(time);
  };

  // Update word highlighting
  const updateWordHighlight = (time) => {
    // Find the appropriate word based on time
    let wordIndex = -1;
    
    // First try to find the word by chunk
    const { chunk } = locateTimePosition(time);
    const chunkWords = wordElements.filter((_, i) => wordOffsets[i] === chunk);
    
    if (chunkWords.length) {
      // Find position within chunk
      let chunkStart = 0;
      for (let i = 0; i < chunk; i++) {
        if (buffers[i]) chunkStart += buffers[i].duration;
      }
      
      const chunkDuration = buffers[chunk]?.duration || 0;
      const relativePosition = (time - chunkStart) / chunkDuration;
      const indexInChunk = Math.floor(relativePosition * chunkWords.length);
      
      // Map back to global index
      if (indexInChunk >= 0 && indexInChunk < chunkWords.length) {
        wordIndex = parseInt(chunkWords[indexInChunk].dataset.index);
      }
    }
    
    // If no word found by chunk or it's invalid, use fallback
    if (wordIndex < 0 || wordIndex >= wordElements.length) {
      // Fallback to simple ratio
      wordIndex = Math.floor((time / totalDuration) * wordElements.length);
      wordIndex = Math.min(wordIndex, wordElements.length - 1);
    }
    
    // Only update if it's a different word
    if (wordIndex !== currentWordIndex) {
      // Remove highlight from previous word
      if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
        wordElements[currentWordIndex].classList.remove('active');
      }
      
      // Add highlight to current word
      if (wordIndex >= 0 && wordIndex < wordElements.length) {
        const wordEl = wordElements[wordIndex];
        wordEl.classList.add('active');
        
        // Ensure word is visible
        const container = E.textBox;
        const wordTop = wordEl.offsetTop;
        const wordBottom = wordTop + wordEl.offsetHeight;
        const containerTop = container.scrollTop;
        const containerBottom = containerTop + container.offsetHeight;
        
        if (wordTop < containerTop + 30) {
          container.scrollTop = wordTop - 30;
        } else if (wordBottom > containerBottom - 30) {
          container.scrollTop = wordBottom - container.offsetHeight + 30;
        }
      }
      
      currentWordIndex = wordIndex;
    }
  };

  // Progress bar click handler
  E.prog.onclick = e => {
    if (!totalDuration) return;
    
    const rect = E.prog.getBoundingClientRect();
    const ratio = (e.clientX - rect.left) / rect.width;
    const targetTime = ratio * totalDuration;
    
    console.log(`Progress bar clicked at ${ratio.toFixed(2)} (${targetTime.toFixed(2)}s)`);
    seekToTime(targetTime);
  };

  // Playback control buttons
  E.play.onclick = () => {
    if (paused) {
      resumePlayback();
    } else {
      startPlayback(0, 0, 0);
    }
  };
  
  E.pause.onclick = pausePlayback;
  E.stop.onclick = stopPlayback;

  // Create download link
  const createDownloadLink = () => {
    if (!rawBuffers.length) return;
    
    // Create a single MP3 file using Web Audio API
    mergeAudioBuffers(rawBuffers)
      .then(mergedBuffer => {
        // Convert to WAV
        const wav = bufferToWav(mergedBuffer);
        const blob = new Blob([wav], { type: 'audio/wav' });
        
        // Create download link
        const url = URL.createObjectURL(blob);
        
        // Trigger download
        const a = document.createElement('a');
        const fileName = 'speech_' + new Date().toISOString().replace(/[:.]/g, '-') + '.wav';
        a.href = url;
        a.download = fileName;
        a.click();
        
        // Clean up
        setTimeout(() => URL.revokeObjectURL(url), 100);
        
        status('Download started', false);
      })
      .catch(err => {
        console.error('Error creating download:', err);
        status('Failed to create download', true);
      });
  };
  
  // Convert ArrayBuffer to WAV format
  const bufferToWav = (buffer) => {
    const numOfChan = buffer.numberOfChannels;
    const length = buffer.length * numOfChan * 2 + 44;
    const sampleRate = buffer.sampleRate;
    const bitsPerSample = 16;
    const byteRate = sampleRate * numOfChan * bitsPerSample / 8;
    const blockAlign = numOfChan * bitsPerSample / 8;
    const data = new DataView(new ArrayBuffer(length));
    let offset = 0;
    
    // RIFF header
    writeString(data, offset, 'RIFF'); offset += 4;
    data.setUint32(offset, length - 8, true); offset += 4;
    writeString(data, offset, 'WAVE'); offset += 4;
    
    // fmt chunk
    writeString(data, offset, 'fmt '); offset += 4;
    data.setUint32(offset, 16, true); offset += 4;
    data.setUint16(offset, 1, true); offset += 2; // PCM format
    data.setUint16(offset, numOfChan, true); offset += 2;
    data.setUint32(offset, sampleRate, true); offset += 4;
    data.setUint32(offset, byteRate, true); offset += 4;
    data.setUint16(offset, blockAlign, true); offset += 2;
    data.setUint16(offset, bitsPerSample, true); offset += 2;
    
    // data chunk
    writeString(data, offset, 'data'); offset += 4;
    data.setUint32(offset, length - 44, true); offset += 4;
    
    // Write interleaved audio data
    if (numOfChan === 2) {
      // Stereo
      const leftChannel = buffer.getChannelData(0);
      const rightChannel = buffer.getChannelData(1);
      for (let i = 0; i < buffer.length; i++) {
        data.setInt16(offset, leftChannel[i] * 0x7FFF, true); offset += 2;
        data.setInt16(offset, rightChannel[i] * 0x7FFF, true); offset += 2;
      }
    } else {
      // Mono
      const channel = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) {
        data.setInt16(offset, channel[i] * 0x7FFF, true); offset += 2;
      }
    }
    
    return data.buffer;
  };
  
  // Helper to write string to DataView
  const writeString = (view, offset, string) => {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  };
  
  // Merge audio buffers into a single buffer
  const mergeAudioBuffers = async (audioBuffers) => {
    // Initialize audio context if not done yet
    await initAudioContext();
    
    // Decode all buffers
    const decodedBuffers = await Promise.all(
      audioBuffers.map(buffer => decodeBuffer(buffer))
    );
    
    // Calculate total length
    let totalLength = 0;
    decodedBuffers.forEach(buffer => {
      totalLength += buffer.length;
    });
    
    // Create a new buffer with the total length
    const numberOfChannels = decodedBuffers[0].numberOfChannels;
    const sampleRate = decodedBuffers[0].sampleRate;
    const result = ctx.createBuffer(numberOfChannels, totalLength, sampleRate);
    
    // Copy data from each buffer
    let offset = 0;
    for (const buffer of decodedBuffers) {
      // For each channel
      for (let channel = 0; channel < numberOfChannels; channel++) {
        const resultData = result.getChannelData(channel);
        const bufferData = buffer.getChannelData(channel);
        
        // Copy data
        for (let i = 0; i < buffer.length; i++) {
          resultData[offset + i] = bufferData[i];
        }
      }
      
      offset += buffer.length;
    }
    
    return result;
  };
  
  // Download button
  E.download.onclick = createDownloadLink;

  // Generate speech
  E.gen.onclick = async () => {
    if (!API) return status('Load voices first', true);
    if (!E.voice.value) return status('Select a voice', true);
    
    // Initialize audio context and ensure it's running
    await initAudioContext();
    
    const text = E.txt.value.trim();
    if (!text) return status('Enter text', true);
    
    // Reset state
    stopPlayback();
    buffers = [];
    rawBuffers = [];
    audioSources = [];
    totalDuration = 0;
    loadedDuration = 0;
    loadingComplete = false;
    E.download.disabled = true;
    
    // Split text into chunks
    const chunks = splitText(text);
    if (!chunks.length) return status('Failed to split text', true);
    
    totalChunks = chunks.length;
    chunksReceived = 0;
    
    // Prepare UI
    status(`Processing ${chunks.length} chunk(s)...`);
    prepareTextDisplay(text, chunks);
    E.gen.disabled = true;
    
    // Initialize buffers array
    buffers = new Array(chunks.length);
    rawBuffers = new Array(chunks.length);
    
    // Create request body template
    const createRequest = chunk => ({
      input: { text: chunk },
      voice: {
        languageCode: E.voice.selectedOptions[0].dataset.l,
        name: E.voice.value
      },
      audioConfig: {
        audioEncoding: 'MP3',
        pitch: +E.pit.value,
        speakingRate: +E.rat.value
      }
    });
    
    // Process chunks
    try {
      // Start processing all chunks in parallel
      const chunkPromises = chunks.map(async (chunk, index) => {
        try {
          console.log(`Generating chunk ${index + 1}/${chunks.length} (${chunk.length} chars)`);
          
          const response = await fetchJSON(`${SY}?key=${API}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(createRequest(chunk))
          });
          
          if (!response.audioContent) {
            throw new Error(`No audio content in response for chunk ${index + 1}`);
          }
          
          // Convert base64 to ArrayBuffer
          const audioData = atob(response.audioContent);
          const arrayBuffer = new Uint8Array(audioData.length);
          for (let i = 0; i < audioData.length; i++) {
            arrayBuffer[i] = audioData.charCodeAt(i);
          }
          
          // Save raw buffer for downloading
          rawBuffers[index] = arrayBuffer.buffer;
          
          // Decode audio
          const audioBuffer = await decodeBuffer(arrayBuffer.buffer);
          
          // Store the decoded buffer
          buffers[index] = audioBuffer;
          
          // Update durations
          loadedDuration += audioBuffer.duration;
          totalDuration += audioBuffer.duration;
          
          console.log(`Chunk ${index + 1} decoded: ${audioBuffer.duration.toFixed(2)}s`);
          
          // Update word elements to show they're ready
          wordElements.forEach(word => {
            if (+word.dataset.chunk === index) {
              word.classList.remove('loading');
            }
          });
          
          // Update progress
          chunksReceived++;
          
          // Autoplay first chunk when it's ready
          if (index === 0 && !playing && !paused) {
            startPlayback(0, 0, 0);
          }
          
          return index;
        } catch (error) {
          console.log(`Error processing chunk ${index + 1}:`, error);
          status(`Chunk ${index + 1} failed: ${error.message}`, true);
          return null;
        }
      });
      
      // Wait for all chunks to complete
      await Promise.all(chunkPromises);
      
      // Check if all chunks were processed successfully
      const success = chunksReceived === totalChunks;
      loadingComplete = true;
      
      if (success) {
        status(`All chunks processed. Duration: ${fmt(totalDuration)}`, false);
        E.download.disabled = false;
      } else {
        status(`Completed ${chunksReceived}/${totalChunks} chunks`, true);
      }
    } catch (e) {
      status(`Generation failed: ${e.message}`, true);
    } finally {
      E.gen.disabled = false;
    }
  };
  
  // Add keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Don't trigger shortcuts when typing in inputs
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // Space - Play/Pause
    if (e.code === 'Space') {
      e.preventDefault();
      if (playing) E.pause.click();
      else if (paused || loadingComplete) E.play.click();
    }
    
    // Escape - Stop
    if (e.code === 'Escape' && (playing || paused)) {
      e.preventDefault();
      E.stop.click();
    }
    
    // G - Generate
    if (e.code === 'KeyG' && !E.gen.disabled) {
      e.preventDefault();
      E.gen.click();
    }
    
    // D - Download
    if (e.code === 'KeyD' && !E.download.disabled) {
      e.preventDefault();
      E.download.click();
    }
  });
});
</script>
</body>
</html>
