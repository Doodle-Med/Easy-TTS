<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Text‑to‑Speech Synthesizer (Web Audio API - Enhanced)</title>
    <style>
        :root { --primary-color:#007bff;--secondary-color:#6c757d;--success-color:#28a745;--error-color:#dc3545;--warning-color:#ffc107;--info-bg:#e2e3e5;--info-text:#383d41;--light-bg:#f8f9fa;--dark-text:#343a40;--light-text:#ffffff;--border-color:#dee2e6;--shadow-color:rgba(0,0,0,.1);--font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif }
        body{font-family:var(--font-family);max-width:800px;margin:2rem auto;padding:1rem;background:var(--light-bg);color:var(--dark-text)}h1{text-align:center;color:var(--primary-color);font-weight:600}h2{margin:0;}
        .container{background:var(--light-text);border-radius:12px;padding:2rem;box-shadow:0 4px 12px var(--shadow-color)}.section{margin-bottom:1.5rem}.section-title{font-weight:600;margin-bottom:.5rem;color:var(--primary-color);border-bottom:1px solid var(--border-color);padding-bottom:.25rem}
        textarea{width:100%;min-height:150px;padding:.75rem;border:1px solid var(--border-color);border-radius:6px;font-size:1rem;line-height:1.5;resize:vertical;box-sizing:border-box}
        textarea:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 2px rgba(0,123,255,.25)}
        .options-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:1rem;margin-top:1rem}
        select,button{padding:.6rem 1rem;border-radius:6px;font-size:1rem;border:1px solid var(--border-color)}select{width:100%;appearance:none;background:var(--light-text) url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e") no-repeat right .75rem center;background-size:16px 12px}button{background:var(--primary-color);color:#fff;border:none;cursor:pointer;transition:transform .1s,background .2s;margin-right:.5rem}button:hover:not(:disabled){background:#0056b3;transform:translateY(-1px)}button:disabled{background:#a0c7e8;cursor:not-allowed;transform:none}
        #download-button{background:var(--success-color)}#download-button:hover:not(:disabled){background:#218838}
        #stop-button{background:var(--error-color);display:none;}#stop-button:hover:not(:disabled){background:#c82333}
        .char-counter{font-size:.85rem;color:var(--secondary-color);margin-left:auto}.char-counter.warning{color:var(--warning-color);font-weight:500}.char-counter.danger{color:var(--error-color);font-weight:bold}
        .feedback-area{margin-top:1rem;padding:.75rem;border-radius:6px;font-size:.95rem;text-align:center}.status.info{background:var(--info-bg);color:var(--info-text)}.status.success{background:#d4edda;color:#155724;border:1px solid #c3e6cb}.status.error{background:#f8d7da;color:#721c24;border:1px solid #f5c6cb}.status.warning{background:#fff3cd;color:#856404;border:1px solid #ffeeba}
        .loading{display:flex;gap:.5rem;align-items:center;color:var(--secondary-color)}.loading-spinner{width:20px;height:20px;border:3px solid #f3f3f3;border-top:3px solid var(--primary-color);border-radius:50%;animation:spin 1s linear infinite}@keyframes spin{to{transform:rotate(360deg)}}
        .progress-container{width:100%;height:8px;background:#e9ecef;border-radius:4px;overflow:hidden;margin-top:.5rem}.progress-bar{height:100%;width:0;background:var(--primary-color);transition:width .2s}
        .progress-info{font-size:.85rem;text-align:center;margin-top:.5rem;color:var(--secondary-color)}
        #api-key-container{margin-bottom:1rem;padding:0.75rem;border-radius:6px;background-color:#f8f9fa;border:1px solid var(--border-color)}
        #api-key-input{width:calc(100% - 110px);padding:0.5rem;margin-right:0.5rem;border-radius:4px;border:1px solid var(--border-color)}
        #api-key-save{padding:0.5rem 1rem;background:var(--primary-color);color:white;border:none;border-radius:4px;cursor:pointer}
        #api-key-save:hover{background:#0056b3}
        .collapsed{height:0;overflow:hidden;padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-width:0;transition:all 0.3s ease}
        .expanded{height:auto;overflow:visible;transition:all 0.3s ease; padding-top: 0.75rem; padding-bottom: 0.75rem; margin-bottom: 1rem;}
        #api-key-toggle{background:none;border:none;color:var(--primary-color);cursor:pointer;margin-bottom:0.5rem;padding:0;font-size:0.9rem;display:flex;align-items:center;gap:0.25rem}
        #api-key-toggle:hover{text-decoration:underline}
        .footnote{font-size:0.75rem;color:var(--secondary-color);margin-top:1rem}
        /* Playback controls */
        .audio-controls{display:flex;gap:.75rem;justify-content:center;align-items:center;margin:1rem 0;}
        .audio-controls button{padding:0.5rem 1rem;font-size:1.1rem;border-radius:50%;border:1px solid var(--border-color);background:var(--light-bg);cursor:pointer;transition:.2s;}
        .audio-controls button:disabled{color:#aaa;cursor:default;background:#eee;}
        .audio-controls .main{background:var(--primary-color);color:#fff;}
        .audio-controls .main:disabled{background:#9cc7f7;}
        .audio-timeline{width:100%;height:12px;background:#e9ecef;border-radius:5px;cursor:pointer;margin:.5rem 0;position:relative;}
        .audio-timeline .current{height:100%;background:var(--primary-color);border-radius:5px;}
        .audio-timeline .buffered{height:100%;background:#a4d1f4;position:absolute;left:0;top:0;z-index:0;border-radius:5px;}
        .audio-timeline .thumb{width:14px;height:14px;background:var(--primary-color);border-radius:50%;position:absolute;top:-1px;transform:translateX(-50%);z-index:2;}
        .tts-word{transition:background 0.15s;border-radius:3px;}
        .tts-word.active{background:var(--primary-color);color:#fff;}
        #highlight-area{margin:.5rem 0 1.2rem 0;padding:.5rem 0;font-size:1.25rem;line-height:1.8;border-radius:7px;min-height:2.5em;}
    </style>
</head>
<body>
    <h1>Live Text‑to‑Speech Synthesizer</h1>
    <div class="container">
        <div id="api-key-section" class="section">
            <button id="api-key-toggle">
                <span class="toggle-icon">▶</span>&nbsp;Show API Key Settings
            </button>
            <div id="api-key-container" class="collapsed">
                <p><strong>Google Cloud Text-to-Speech API Key:</strong></p>
                <input type="password" id="api-key-input" placeholder="Enter your Google Cloud API key">
                <button id="api-key-save">Save Key</button>
                <p class="footnote">Your API key is stored only in your browser's local storage and never transmitted to any server other than Google Cloud.</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title">Input</h2>
            <div class="char-counter-container" style="display:flex;align-items:center">
                <span id="char-counter" class="char-counter">0 chars</span>
            </div>
            <textarea id="text-input" placeholder="Enter text here …"></textarea>
        </div>

        <div class="section">
            <h2 class="section-title">Options</h2>
            <div class="options-grid">
                <div>
                    <label for="voice-select">Voice</label>
                    <select id="voice-select"><option value="">Loading voices …</option></select>
                </div>
                <div>
                    <label for="speed-select">Speed</label>
                    <select id="speed-select">
                        <option value="0.5">0.5×</option>
                        <option value="0.75">0.75×</option>
                        <option value="1" selected>1×</option>
                        <option value="1.25">1.25×</option>
                        <option value="1.5">1.5×</option>
                        <option value="2">2×</option>
                    </select>
                </div>
                <div>
                    <label for="pitch-select">Pitch</label>
                    <select id="pitch-select">
                        <option value="-10">-10</option>
                        <option value="-5">-5</option>
                        <option value="0" selected>0</option>
                        <option value="5">+5</option>
                        <option value="10">+10</option>
                        <option value="20">+20</option>
                    </select>
                </div>
                <div>
                    <label for="chunk-size-select">Chunk size</label>
                    <select id="chunk-size-select">
                        <option value="0">No chunking (Max 5k)</option>
                        <option value="1000">1000</option>
                        <option value="2000">2000</option>
                        <option value="3000">3000</option>
                        <option value="4500" selected>4500</option>
                    </select>
                </div>
                <div>
                    <label for="chunk-break-select">Split at</label>
                    <select id="chunk-break-select">
                        <option value="sentence" selected>Sentence</option>
                        <option value="paragraph">Paragraph</option>
                        <option value="exact">Exact</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title">Generate & Play</h2>
            <button id="speak-button" disabled>Generate & Play</button>
            <button id="stop-button">Stop</button>
            <button id="download-button" disabled>Download MP3</button>
            <div id="loading" class="loading" style="display:none">
                <div class="loading-spinner"></div>
                <span>Generating …</span>
            </div>
            <div id="progress-container" class="progress-container" style="display:none">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
            <div id="progress-info" class="progress-info" style="display:none"></div>
            <div id="generation-status" class="feedback-area status info" style="display:none"></div>
            <!-- Enhanced Audio Controls -->
            <div class="audio-controls" id="audio-controls" style="display:none">
                <button id="rewind10" title="Back 10s">&#8676;10s</button>
                <button id="rewind5" title="Back 5s">&#8676;5s</button>
                <button id="play" class="main" title="Play">&#9658;</button>
                <button id="pause" class="main" title="Pause">&#10073;&#10073;</button>
                <button id="stop" title="Stop">&#9632;</button>
                <button id="forward5" title="Forward 5s">5s&#8677;</button>
                <button id="forward10" title="Forward 10s">10s&#8677;</button>
            </div>
            <div class="audio-timeline" id="audio-timeline" style="display:none">
                <div class="buffered" id="audio-buffered" style="width:0"></div>
                <div class="current" id="audio-current" style="width:0"></div>
                <div class="thumb" id="audio-thumb" style="left:0"></div>
            </div>
            <div id="audio-time-info" style="text-align:center;font-size:.97rem;color:var(--secondary-color);display:none;">
                <span id="audio-current-time">0:00</span> / <span id="audio-total-time">0:00</span>
            </div>
            <div id="highlight-area"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Constants
        const API_URL = 'https://texttospeech.googleapis.com/v1';
        const API_LIMIT = 5000;
        const MIN_INTERVAL = 350;
        const PREFERRED_VOICE = 'en-US-Chirp3-HD-Charon';
        const API_KEY_STORAGE_KEY = 'tts_api_key';

        // DOM Elements
        const el = id => document.getElementById(id);
        const textInput = el('text-input');
        const voiceSelect = el('voice-select');
        const speedSelect = el('speed-select');
        const pitchSelect = el('pitch-select');
        const chunkSizeSel = el('chunk-size-select');
        const chunkBreakSel = el('chunk-break-select');
        const speakBtn = el('speak-button');
        const stopBtn = el('stop-button');
        const downloadBtn = el('download-button');
        const loading = el('loading');
        const progCont = el('progress-container');
        const progBar = el('progress-bar');
        const progInfo = el('progress-info');
        const genStatus = el('generation-status');
        const charCounter = el('char-counter');
        const apiKeyInput = el('api-key-input');
        const apiKeySaveBtn = el('api-key-save');
        const apiKeyToggle = el('api-key-toggle');
        const apiKeyContainer = el('api-key-container');
        // Enhanced controls
        const audioControls = el('audio-controls');
        const rewind10Btn = el('rewind10');
        const rewind5Btn = el('rewind5');
        const playBtn = el('play');
        const pauseBtn = el('pause');
        const stopBtn2 = el('stop'); // new stop button
        const forward5Btn = el('forward5');
        const forward10Btn = el('forward10');
        const timeline = el('audio-timeline');
        const timelineCurrent = el('audio-current');
        const timelineBuffered = el('audio-buffered');
        const timelineThumb = el('audio-thumb');
        const timeInfo = el('audio-time-info');
        const currentTimeSpan = el('audio-current-time');
        const totalTimeSpan = el('audio-total-time');
        const highlightArea = el('highlight-area');

        // State variables
        let lastRequestTime = 0;
        let audioContext = null;
        let audioBufferQueue = [];
        let currentSourceNode = null;
        let nextStartTime = 0;
        let isPlaying = false;
        let isGenerating = false;
        let collectedRawBuffers = [];
        let apiKey = '';
        // Enhanced playback state
        let fullBuffer = null; // AudioBuffer holding the whole speech
        let audioStartTime = 0; // when playback started (audioContext.currentTime)
        let pausedAt = 0; // seconds offset
        let playbackTimer = null;
        let highlightWordMap = []; // Array of {start, end, word, idx}
        let wordsArray = [];
        let highlightActive = false;

        // --- API Key Management ---
        function loadApiKey() {
            const savedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
            if (savedKey) {
                apiKey = savedKey;
                apiKeyInput.value = '••••••••••••••••••••••';
                apiKeyInput.placeholder = 'API Key saved. Enter new key to replace.';
                return true;
            }
            apiKeyInput.placeholder = 'Enter your Google Cloud API key';
            return false;
        }
        function saveApiKey() {
            const newKey = apiKeyInput.value.trim();
            if (newKey === '••••••••••••••••••••••' || newKey === '') {
                if (confirm("Clear saved API key? You will need to enter it again later.")) {
                    apiKey = '';
                    localStorage.removeItem(API_KEY_STORAGE_KEY);
                    apiKeyInput.value = '';
                    apiKeyInput.placeholder = 'Enter your Google Cloud API key';
                    showStatus('API key cleared.', 'warning');
                    updateCharCount();
                    loadVoices();
                } else {
                    if(apiKey) apiKeyInput.value = '••••••••••••••••••••••';
                    else apiKeyInput.value = '';
                }
                return false;
            }
            apiKey = newKey;
            localStorage.setItem(API_KEY_STORAGE_KEY, newKey);
            apiKeyInput.value = '••••••••••••••••••••••';
            apiKeyInput.placeholder = 'API Key saved. Enter new key to replace.';
            showStatus('API key saved successfully!', 'success');
            loadVoices();
            return true;
        }
        function toggleApiKeyContainer() {
            const isCollapsed = apiKeyContainer.classList.contains('collapsed');
            if (isCollapsed) {
                apiKeyContainer.classList.remove('collapsed');
                apiKeyContainer.classList.add('expanded');
                apiKeyToggle.innerHTML = `<span class="toggle-icon">▼</span>&nbsp;Hide API Key Settings`;
            } else {
                apiKeyContainer.classList.remove('expanded');
                apiKeyContainer.classList.add('collapsed');
                apiKeyToggle.innerHTML = `<span class="toggle-icon">▶</span>&nbsp;Show API Key Settings`;
            }
            if (!isCollapsed && apiKey && apiKeyInput.value !== '••••••••••••••••••••••') {
                apiKeyInput.value = '••••••••••••••••••••••';
            }
        }
        function checkApiKeyAvailability() {
            if (!apiKey) {
                showStatus('Please provide a Google Cloud API key to use this application', 'warning');
                if (apiKeyContainer.classList.contains('collapsed')) {
                    toggleApiKeyContainer();
                }
                apiKeyInput.focus();
                return false;
            }
            return true;
        }

        // --- Core Application Logic ---
        async function loadVoices() {
            if (!apiKey) {
                voiceSelect.innerHTML = '<option value="">API key required</option>';
                speakBtn.disabled = true;
                updateCharCount();
                return;
            }
            voiceSelect.innerHTML = '<option value="">Loading voices …</option>';
            speakBtn.disabled = true;
            try {
                const res = await fetch(`${API_URL}/voices?key=${apiKey}`);
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({}));
                    const errorMsg = errorData?.error?.message || `Status: ${res.status} ${res.statusText}`;
                    if (res.status === 400 && errorMsg.includes('API key not valid')) {
                        throw new Error(`API key is not valid. Please check it. (${errorMsg})`);
                    } else if (res.status === 403) {
                        throw new Error(`Permission denied. Ensure the Text-to-Speech API is enabled for this key. (${errorMsg})`);
                    }
                    throw new Error(`Failed to fetch voices: ${errorMsg}`);
                }
                const { voices } = await res.json();
                if (!voices || !Array.isArray(voices) || voices.length === 0) {
                    throw new Error('No voices returned from API. Check API key permissions.');
                }
                const byLang = {};
                voices.forEach(v => { const l = v.languageCodes[0]; (byLang[l] = byLang[l] || []).push(v); });
                voiceSelect.innerHTML = '<option value="">-- Select Voice --</option>';
                Object.keys(byLang).sort().forEach(lang => {
                    const optg = document.createElement('optgroup');
                    optg.label = lang;
                    byLang[lang].sort((a, b) => a.name.localeCompare(b.name)).forEach(v => {
                        const o = document.createElement('option');
                        o.value = v.name;
                        o.dataset.lang = lang;
                        const short = v.name.startsWith(lang + '-') ? v.name.substring(lang.length + 1) : v.name;
                        o.textContent = `${short} (${v.ssmlGender})`;
                        optg.appendChild(o);
                    });
                    voiceSelect.appendChild(optg);
                });
                const preferredOption = voiceSelect.querySelector(`option[value="${PREFERRED_VOICE}"]`);
                if (preferredOption) voiceSelect.value = PREFERRED_VOICE;
                else {
                    const firstEnUS = voiceSelect.querySelector('optgroup[label="en-US"] option');
                    if (firstEnUS) voiceSelect.value = firstEnUS.value;
                    else {
                        const firstOption = voiceSelect.querySelector('option:not([value=""])');
                        if (firstOption) voiceSelect.value = firstOption.value;
                    }
                }
                showStatus('Voices loaded successfully!', 'success');
            } catch (e) {
                console.error("Voice loading failed:", e);
                voiceSelect.innerHTML = '<option value="">Error loading voices</option>';
                showStatus(`Voice loading error: ${e.message}`, 'error');
            } finally {
                updateCharCount();
            }
        }
        function updateCharCount() {
            const len = textInput.value.length;
            charCounter.textContent = `${len.toLocaleString()} chars`;
            charCounter.classList.remove('warning', 'danger');
            const chunkSize = parseInt(chunkSizeSel.value, 10);
            const needsChunking = chunkSize > 0;
            let isOverLimit = false;
            if (!needsChunking && len > API_LIMIT) {
                charCounter.classList.add('danger');
                isOverLimit = true;
                if (!genStatus.classList.contains('error')) {
                    showStatus(`Text exceeds ${API_LIMIT.toLocaleString()} characters and chunking is disabled. Enable chunking or shorten text.`, 'warning');
                }
            } else if (len > API_LIMIT * 0.8 && !needsChunking) {
                charCounter.classList.add('warning');
            }
            const hasText = textInput.value.trim().length > 0;
            const hasVoice = voiceSelect.value !== '';
            const hasApiKey = apiKey !== '';
            speakBtn.disabled = isGenerating || !hasText || !hasVoice || !hasApiKey || isOverLimit;
        }
        function showStatus(msg, cls = 'info') {
            genStatus.textContent = msg;
            genStatus.className = `feedback-area status ${cls}`;
            genStatus.style.display = 'block';
            if (cls === 'success') {
                setTimeout(() => {
                    if (genStatus.textContent === msg) {
                        hideStatus();
                    }
                }, 5000);
            }
        }
        function hideStatus() {
            genStatus.style.display = 'none';
        }
        function splitChunks(text, size, method) {
            if (size <= 0 || text.length <= size) return [text.trim()];
            const out = [];
            let remaining = text;
            const sentenceRe = /([.!?])\s+/g;
            const paragraphRe = /\n\s*\n+/g;
            while (remaining.length > 0) {
                let chunk;
                let splitIndex = Math.min(size, remaining.length);
                if (remaining.length > size && method !== 'exact') {
                    const head = remaining.substring(0, size);
                    const re = method === 'paragraph' ? paragraphRe : sentenceRe;
                    let lastMatchIndex = -1;
                    let match;
                    re.lastIndex = 0;
                    while ((match = re.exec(head)) !== null) {
                        lastMatchIndex = match.index + match[0].length;
                    }
                    if (lastMatchIndex > 0) {
                        splitIndex = lastMatchIndex;
                    } else {
                        const lastSpace = head.lastIndexOf(' ');
                        if (lastSpace > size * 0.5) {
                            splitIndex = lastSpace + 1;
                        }
                    }
                }
                chunk = remaining.substring(0, splitIndex).trim();
                if (chunk) out.push(chunk);
                remaining = remaining.substring(splitIndex);
            }
            return out;
        }
        function initAudioContext() {
            try {
                if (!audioContext || audioContext.state === 'closed') {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    nextStartTime = 0;
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume().catch(e => {
                        showStatus("Failed to resume audio playback. Click 'Generate' again.", 'error');
                    });
                }
                if (audioContext.state !== 'running') {
                    showStatus("Audio playback unavailable. Ensure browser allows audio.", 'warning');
                    return false;
                }
                return true;
            } catch (e) {
                showStatus("Your browser doesn't support Web Audio API or permission denied.", 'error');
                return false;
            }
        }
        async function synthesizeChunk(text, opts) {
            const body = {
                input: { text },
                voice: { languageCode: opts.lang, name: opts.name },
                audioConfig: {
                    audioEncoding: 'MP3',
                    speakingRate: opts.speed,
                    pitch: opts.pitch
                }
            };
            const now = Date.now();
            const timeSinceLastRequest = now - lastRequestTime;
            if (timeSinceLastRequest < MIN_INTERVAL) {
                await new Promise(resolve => setTimeout(resolve, MIN_INTERVAL - timeSinceLastRequest));
            }
            lastRequestTime = Date.now();
            try {
                const response = await fetch(`${API_URL}/text:synthesize?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMsg = errorData?.error?.message || `Status: ${response.status} ${response.statusText}`;
                    if (response.status === 400 && errorMsg.includes('API key not valid')) {
                        throw new Error(`API key is not valid. Please check it. (${errorMsg})`);
                    } else if (response.status === 403) {
                        throw new Error(`Permission denied. Check API key permissions/billing. (${errorMsg})`);
                    }
                    throw new Error(`TTS API Error: ${errorMsg}`);
                }
                const data = await response.json();
                if (!data.audioContent) {
                    throw new Error('TTS API Error: Received empty audio content');
                }
                const binaryString = window.atob(data.audioContent);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
                return bytes.buffer;
            } catch (error) {
                if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                    throw new Error('Network error during synthesis. Please check connection.');
                }
                throw error;
            }
        }

        // --- Enhanced Audio Logic ---
        function getTotalAudioDuration() {
            return fullBuffer ? fullBuffer.duration : 0;
        }
        function getCurrentAudioTime() {
            if (!fullBuffer) return 0;
            if (!isPlaying) return pausedAt;
            let elapsed = audioContext ? (audioContext.currentTime - audioStartTime) : 0;
            let t = pausedAt + elapsed;
            return Math.min(t, fullBuffer.duration);
        }
        function setCurrentAudioTime(secs) {
            if (!fullBuffer) return;
            secs = Math.max(0, Math.min(secs, fullBuffer.duration));
            pausedAt = secs;
            if (isPlaying) {
                stopCurrentSource();
                playAudioFrom(pausedAt);
            } else {
                updateTimeline();
                highlightCurrentWord();
            }
        }
        function stopCurrentSource() {
            if (currentSourceNode) {
                try {
                    currentSourceNode.onended = null;
                    currentSourceNode.stop(0);
                    currentSourceNode.disconnect();
                } catch (e) {}
                currentSourceNode = null;
            }
            isPlaying = false;
            clearInterval(playbackTimer);
            playbackTimer = null;
        }
        function playAudioFrom(offset = 0) {
            if (!audioContext || !fullBuffer) return;
            stopCurrentSource();
            currentSourceNode = audioContext.createBufferSource();
            currentSourceNode.buffer = fullBuffer;
            currentSourceNode.connect(audioContext.destination);
            currentSourceNode.onended = () => {
                isPlaying = false;
                clearInterval(playbackTimer);
                playbackTimer = null;
                updateControls();
                highlightCurrentWord();
                updateTimeline();
            };
            audioStartTime = audioContext.currentTime;
            isPlaying = true;
            currentSourceNode.start(0, offset);
            playbackTimer = setInterval(() => {
                updateTimeline();
                highlightCurrentWord();
                if (getCurrentAudioTime() >= fullBuffer.duration - 0.01) {
                    stopCurrentSource();
                    pausedAt = 0;
                    updateControls();
                    updateTimeline();
                }
            }, 50);
            updateControls();
            updateTimeline();
            highlightCurrentWord();
        }
        function pauseAudio() {
            if (!isPlaying) return;
            pausedAt = getCurrentAudioTime();
            stopCurrentSource();
            updateControls();
            updateTimeline();
            highlightCurrentWord();
        }
        function stopAudio() {
            stopCurrentSource();
            pausedAt = 0;
            updateControls();
            updateTimeline();
            highlightCurrentWord();
        }
        function updateTimeline() {
            if (!fullBuffer) {
                timelineCurrent && (timelineCurrent.style.width = '0');
                timelineBuffered && (timelineBuffered.style.width = '0');
                timelineThumb && (timelineThumb.style.left = '0');
                currentTimeSpan && (currentTimeSpan.textContent = '0:00');
                totalTimeSpan && (totalTimeSpan.textContent = '0:00');
                return;
            }
            let t = getCurrentAudioTime();
            let duration = fullBuffer.duration || 1;
            let percent = 100 * t / duration;
            timelineCurrent && (timelineCurrent.style.width = percent + '%');
            timelineBuffered && (timelineBuffered.style.width = '100%');
            timelineThumb && (timelineThumb.style.left = percent + '%');
            currentTimeSpan && (currentTimeSpan.textContent = formatTime(t));
            totalTimeSpan && (totalTimeSpan.textContent = formatTime(duration));
        }
        function formatTime(secs) {
            let m = Math.floor(secs / 60);
            let s = Math.floor(secs % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }
        function buildHighlightMap(text, sampleRate, duration) {
            wordsArray = text.match(/\S+/g) || [];
            highlightWordMap = [];
            if (!wordsArray.length) return;
            let perWord = duration / wordsArray.length;
            let offset = 0;
            for (let i = 0; i < wordsArray.length; ++i) {
                let word = wordsArray[i];
                highlightWordMap.push({start: offset, end: offset + perWord, word, idx: i});
                offset += perWord;
            }
        }
        function renderHighlight() {
            let html = '';
            for (let i = 0; i < wordsArray.length; ++i) {
                html += `<span class="tts-word" id="tts-word-${i}">${wordsArray[i]}</span> `;
            }
            highlightArea && (highlightArea.innerHTML = html);
        }
        function highlightCurrentWord() {
            if (!highlightWordMap.length) return;
            let t = getCurrentAudioTime();
            let idx = highlightWordMap.findIndex(({start, end}) => t >= start && t < end);
            if (idx === -1 && t >= (highlightWordMap.at(-1)?.start || 0)) idx = highlightWordMap.length - 1;
            for (let i = 0; i < highlightWordMap.length; ++i) {
                let elw = document.getElementById('tts-word-' + i);
                if (elw) elw.classList.toggle('active', i === idx);
            }
        }
        function updateControls() {
            playBtn && (playBtn.disabled = !fullBuffer || isPlaying);
            pauseBtn && (pauseBtn.disabled = !fullBuffer || !isPlaying);
            stopBtn2 && (stopBtn2.disabled = !fullBuffer || (!isPlaying && pausedAt === 0));
            rewind5Btn && (rewind5Btn.disabled = !fullBuffer);
            rewind10Btn && (rewind10Btn.disabled = !fullBuffer);
            forward5Btn && (forward5Btn.disabled = !fullBuffer);
            forward10Btn && (forward10Btn.disabled = !fullBuffer);
            timeline && (timeline.style.display = fullBuffer ? 'block' : 'none');
            timeInfo && (timeInfo.style.display = fullBuffer ? 'block' : 'none');
            audioControls && (audioControls.style.display = fullBuffer ? 'flex' : 'none');
            highlightArea && (highlightArea.style.display = fullBuffer ? 'block' : 'none');
        }
        // --- Timeline Seek Handling ---
        timeline && timeline.addEventListener('click', function (e) {
            if (!fullBuffer) return;
            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = Math.max(0, Math.min(1, x / rect.width));
            setCurrentAudioTime(percent * fullBuffer.duration);
        });

        // --- Enhanced Event Listeners ---
        playBtn && playBtn.addEventListener('click', () => playAudioFrom(pausedAt));
        pauseBtn && pauseBtn.addEventListener('click', pauseAudio);
        stopBtn2 && stopBtn2.addEventListener('click', stopAudio);
        rewind5Btn && rewind5Btn.addEventListener('click', () => setCurrentAudioTime(getCurrentAudioTime() - 5));
        rewind10Btn && rewind10Btn.addEventListener('click', () => setCurrentAudioTime(getCurrentAudioTime() - 10));
        forward5Btn && forward5Btn.addEventListener('click', () => setCurrentAudioTime(getCurrentAudioTime() + 5));
        forward10Btn && forward10Btn.addEventListener('click', () => setCurrentAudioTime(getCurrentAudioTime() + 10));

        // --- Build buffer and highlight after generation ---
        async function postProcessAfterGeneration(text, buffers) {
            if (!audioContext) return;
            let audioParts = [];
            for (let buf of buffers) {
                let ab = buf.slice(0);
                let decoded = await audioContext.decodeAudioData(ab);
                audioParts.push(decoded);
            }
            let totalLen = audioParts.reduce((s, b) => s + b.length, 0);
            let sampleRate = audioParts[0]?.sampleRate || 24000;
            let channels = audioParts[0]?.numberOfChannels || 1;
            let out = audioContext.createBuffer(channels, totalLen, sampleRate);
            let offset = 0;
            for (let part of audioParts) {
                for (let c = 0; c < channels; ++c) {
                    out.getChannelData(c).set(part.getChannelData(c), offset);
                }
                offset += part.length;
            }
            fullBuffer = out;
            pausedAt = 0;
            buildHighlightMap(text, sampleRate, out.duration);
            renderHighlight();
            updateControls();
            updateTimeline();
            highlightCurrentWord();
        }

        // --- INTEGRATE WITH EXISTING GENERATION LOGIC ---
        async function startGeneration() {
            if (isGenerating || speakBtn.disabled) return;
            if (!checkApiKeyAvailability()) return;
            const text = textInput.value.trim();
            if (!text) { showStatus("Please enter some text", 'warning'); return; }
            if (!voiceSelect.value) { showStatus("Please select a voice", 'warning'); return; }
            if (!initAudioContext()) return;

            stopPlaybackAndGeneration(true);
            isGenerating = true;
            collectedRawBuffers = [];
            audioBufferQueue = [];
            fullBuffer = null; pausedAt = 0; highlightWordMap = []; highlightArea.innerHTML = '';
            nextStartTime = audioContext.currentTime;

            hideStatus();
            loading.style.display = 'flex';
            progCont.style.display = 'none';
            progInfo.style.display = 'none';
            progBar.style.width = '0%';
            speakBtn.disabled = true;
            stopBtn.style.display = 'inline-block';
            downloadBtn.disabled = true;

            const selectedOption = voiceSelect.selectedOptions[0];
            const options = { name: selectedOption.value, lang: selectedOption.dataset.lang, speed: parseFloat(speedSelect.value), pitch: parseFloat(pitchSelect.value) };
            const chunkSize = parseInt(chunkSizeSel.value, 10);
            const chunkMethod = chunkBreakSel.value;
            const chunks = splitChunks(text, chunkSize || API_LIMIT, chunkMethod);
            if (chunks.length > 1) { progCont.style.display = 'block'; progInfo.style.display = 'block'; }

            let hasError = false;
            try {
                for (let i = 0; i < chunks.length; i++) {
                    if (!isGenerating) { break; }
                    const currentChunkText = chunks[i];
                    if (currentChunkText.length > API_LIMIT) {
                        showStatus(`Error: Chunk ${i + 1} exceeds API limit of ${API_LIMIT} chars (${currentChunkText.length}).`, 'error');
                        hasError = true; break;
                    }
                    if (chunks.length > 1) {
                        progBar.style.width = `${Math.round((i + 1) / chunks.length * 100)}%`;
                        progInfo.textContent = `Processing chunk ${i + 1} / ${chunks.length}`;
                    } else if (!progInfo.style.display || progInfo.style.display === 'none') {
                        progInfo.textContent = `Processing text...`; progInfo.style.display = 'block';
                    }
                    try {
                        const rawBuffer = await synthesizeChunk(currentChunkText, options);
                        collectedRawBuffers.push(rawBuffer);
                    } catch (e) {
                        showStatus(`Error on chunk ${i + 1}: ${e.message}`, 'error');
                        hasError = true; break;
                    }
                }
                if (!hasError) {
                    await postProcessAfterGeneration(text, collectedRawBuffers);
                    showStatus('Audio is ready! Use the controls below.', 'success');
                    downloadBtn.disabled = collectedRawBuffers.length === 0;
                }
            } catch (e) {
                showStatus(`Unexpected generation error: ${e.message}`, 'error');
                hasError = true;
            } finally {
                isGenerating = false;
                loading.style.display = 'none';
                if (hasError) {
                    progInfo.textContent = 'Generation stopped due to error';
                    stopPlaybackAndGeneration();
                }
            }
        }
        function stopPlaybackAndGeneration(isInternalReset = false) {
            isGenerating = false;
            stopCurrentSource();
            audioBufferQueue = [];
            isPlaying = false;
            nextStartTime = audioContext ? audioContext.currentTime : 0;
            loading.style.display = 'none';
            updateCharCount();
            stopBtn.style.display = 'none';
            downloadBtn.disabled = collectedRawBuffers.length === 0;
            updateControls();
            if (!isInternalReset && !genStatus.classList.contains('error')) {
                showStatus('Stopped', 'warning');
            }
        }
        function downloadAudio() {
            if (!collectedRawBuffers.length || downloadBtn.disabled) {
                showStatus("No audio data to download", "warning"); return;
            }
            try {
                const finalBlob = new Blob(collectedRawBuffers, { type: 'audio/mp3' });
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const textPreview = textInput.value.trim().substring(0, 25).replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_');
                const filename = `speech_${textPreview || 'audio'}_${timestamp}.mp3`;
                const url = URL.createObjectURL(finalBlob);
                const a = document.createElement('a');
                a.style.display = 'none'; a.href = url; a.download = filename;
                document.body.appendChild(a); a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
                showStatus(`Downloaded "${filename}"`, 'success');
            } catch (e) {
                showStatus(`Download failed: ${e.message}`, 'error');
            }
        }

        // --- Event Listeners & Initialization ---
        textInput && textInput.addEventListener('input', updateCharCount);
        speakBtn && speakBtn.addEventListener('click', startGeneration);
        stopBtn && stopBtn.addEventListener('click', () => stopPlaybackAndGeneration(false));
        downloadBtn && downloadBtn.addEventListener('click', downloadAudio);
        apiKeySaveBtn && apiKeySaveBtn.addEventListener('click', saveApiKey);
        apiKeyToggle && apiKeyToggle.addEventListener('click', toggleApiKeyContainer);
        voiceSelect && voiceSelect.addEventListener('change', () => { updateCharCount(); stopPlaybackAndGeneration(false); });
        speedSelect && speedSelect.addEventListener('change', () => stopPlaybackAndGeneration(false));
        pitchSelect && pitchSelect.addEventListener('change', () => stopPlaybackAndGeneration(false));
        chunkSizeSel && chunkSizeSel.addEventListener('change', () => { updateCharCount(); stopPlaybackAndGeneration(false); });
        chunkBreakSel && chunkBreakSel.addEventListener('change', () => stopPlaybackAndGeneration(false));

        window.addEventListener('error', (event) => {
            if (isGenerating || isPlaying) {
                showStatus(`An unexpected error occurred: ${event.message || 'Unknown error'}. Stopping operation.`, 'error');
                stopPlaybackAndGeneration();
            }
        });
        window.addEventListener('unhandledrejection', (event) => {
            if (isGenerating || isPlaying) {
                showStatus(`An unexpected async error occurred: ${event.reason?.message || 'Unknown rejection'}. Stopping operation.`, 'error');
                stopPlaybackAndGeneration();
            }
        });
        window.addEventListener('beforeunload', () => {
            stopPlaybackAndGeneration(true);
            if (audioContext && audioContext.state !== 'closed') {
                try { audioContext.close(); }
                catch (e) {}
            }
        });

        // Initial setup
        loadApiKey();
        updateCharCount();
        if (apiKey) {
            loadVoices();
        } else {
            checkApiKeyAvailability();
        }
        updateControls();
    });
    </script>
</body>
</html>
