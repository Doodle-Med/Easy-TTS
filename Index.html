<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Google Cloud TTS (v7 - Complete)</title>
    <style>
        /* CSS remains the same as v4/v5/v6 - Keeping it for brevity */
        :root { --primary-color: #4285f4; --secondary-color: #34a853; --accent-color: #ea4335; --light-gray: #f5f5f5; --medium-gray: #e0e0e0; --dark-gray: #757575; --text-color: #212121; --buffer-color: #fbbc05; }
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background-color: #fafafa; color: var(--text-color); line-height: 1.6; padding: 20px; max-width: 1200px; margin: 0 auto; }
        h1, h2, h3 { margin-bottom: 15px; color: var(--primary-color); }
        h1 { text-align: center; margin-top: 0; padding-bottom: 15px; border-bottom: 1px solid var(--medium-gray); }
        .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        @media (max-width: 992px) { .container { grid-template-columns: 1fr; } }
        .panel { background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); padding: 20px; margin-bottom: 20px; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; }
        input[type="text"], input[type="password"], input[type="number"], textarea, select, button { width: 100%; padding: 10px; border: 1px solid var(--medium-gray); border-radius: 4px; font-size: 14px; }
        input[type="range"] { width: 100%; }
        textarea { resize: vertical; min-height: 150px; }
        button { background-color: var(--primary-color); color: white; border: none; font-weight: bold; cursor: pointer; transition: background-color 0.3s; margin-top: 10px; }
        button:hover { background-color: #3367d6; }
        button:disabled { background-color: var(--dark-gray); cursor: not-allowed; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .audio-player { margin-top: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); }
        .timeline-container { position: relative; width: 100%; height: 15px; background-color: var(--light-gray); border-radius: 15px; margin-top: 10px; overflow: hidden; cursor: pointer; }
        .buffered-progress { position: absolute; height: 100%; background-color: var(--buffer-color); border-radius: 15px; width: 0%; transition: width 0.2s; }
        .playback-progress { position: absolute; height: 100%; background-color: var(--primary-color); border-radius: 15px; width: 0%; }
        .timeline-tooltip { position: absolute; background: rgba(0, 0, 0, 0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; bottom: 25px; transform: translateX(-50%); display: none; white-space: nowrap; }
        .controls { display: flex; justify-content: space-between; align-items: center; margin-top: 15px; flex-wrap: wrap; }
        .play-controls { display: flex; gap: 10px; }
        .control-button { background: none; border: none; color: var(--dark-gray); font-size: 18px; cursor: pointer; width: auto; padding: 5px 10px; }
        .control-button:hover { color: var(--primary-color); }
        .time-display { font-family: monospace; font-size: 14px; white-space: nowrap; }
        .text-display { background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); padding: 20px; line-height: 1.8; max-height: 400px; overflow-y: auto; }
        .text-display .word { display: inline-block; cursor: pointer; padding: 2px 0; margin: 0 1px; border-radius: 2px; transition: background-color 0.2s; }
        .text-display .word:hover { background-color: var(--light-gray); }
        .text-display .word.active { background-color: rgba(66, 133, 244, 0.2); color: var(--primary-color); font-weight: bold; }
        .progress-container { margin-top: 20px; text-align: center; }
        .progress-bar { width: 100%; height: 10px; background-color: var(--light-gray); border-radius: 5px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background-color: var(--secondary-color); width: 0%; transition: width 0.3s; }
        .status-message { color: var(--dark-gray); font-style: italic; margin-top: 5px; min-height: 1.6em; }
        .error-message { color: var(--accent-color); font-weight: bold; margin-top: 5px; min-height: 1.6em; }
        .hidden { display: none; }
        .range-value { text-align: center; margin-top: 5px; font-size: 14px; }
        .toggle-group { display: flex; flex-wrap: wrap; gap: 5px; }
        .toggle-button { flex: 1; background-color: white; border: 1px solid var(--medium-gray); color: var(--dark-gray); font-weight: normal; min-width: 80px; }
        .toggle-button.active { background-color: var(--primary-color); color: white; }
        .spinner { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(0, 0, 0, 0.1); border-radius: 50%; border-top-color: var(--primary-color); animation: spin 1s ease-in-out infinite; margin-right: 10px; vertical-align: middle; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .tooltip { position: relative; display: inline-block; margin-left: 5px; }
        .tooltip .icon { color: var(--dark-gray); font-size: 16px; cursor: help; }
        .tooltip .tooltip-text { visibility: hidden; width: 250px; background-color: rgba(0, 0, 0, 0.8); color: white; text-align: center; border-radius: 6px; padding: 10px; position: absolute; z-index: 1; bottom: 125%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.3s; font-size: 12px; font-weight: normal; }
        .tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }
        .voice-list { max-height: 200px; overflow-y: auto; border: 1px solid var(--medium-gray); padding: 5px; }
        .download-button { background-color: var(--secondary-color); margin-left: 15px; }
        .download-button:hover { background-color: #2d8f48; }
        #loadVoicesButton { width: auto; padding: 10px 15px; margin-left: 10px; vertical-align: bottom; background-color: var(--secondary-color); }
        #loadVoicesButton:hover { background-color: #2d8f48; }
        .api-key-group { display: flex; align-items: flex-end; gap: 10px; }
        .api-key-group input { flex-grow: 1; margin-bottom: 0; }
        .api-key-group button { margin-top: 0; }
        #voiceFilterInput { width: 100%; padding: 5px; margin-bottom: 5px; border: 1px solid var(--medium-gray); border-radius: 4px; font-size: 13px; }
    </style>
</head>
<body>
    <h1>Advanced Google Cloud TTS (v7 - Complete)</h1>

    <!-- HTML Structure remains the same as v6 -->
    <div class="container">
        <!-- Input Section Panels (Configuration, Voice Settings, Chunking) -->
        <div class="input-section">
            <div class="panel">
                <h2>Configuration</h2>
                <div class="form-group api-key-group">
                    <div style="flex-grow: 1;">
                         <label for="apiKey">Google Cloud API Key</label>
                         <input type="password" id="apiKey" placeholder="Enter API Key & Click Load Voices">
                    </div>
                    <button id="loadVoicesButton" title="Fetch available voices from Google Cloud">Load Voices</button>
                </div>
                <div class="form-group">
                    <label for="textInput">Text to Convert</label>
                    <textarea id="textInput" placeholder="Enter the text you want to convert to speech..."></textarea>
                </div>
                <button id="generateButton" disabled>Generate Speech</button>
                <p class="status-message" id="initStatus">Enter API Key and click "Load Voices".</p>
            </div>

            <div class="panel">
                <h2>Voice Settings</h2>
                 <p id="voiceLoadingStatus" class="status-message hidden"><span class="spinner"></span> Loading voices...</p>
                <div class="settings-grid">
                    <div class="form-group">
                        <label for="languageSelect">Language</label>
                        <select id="languageSelect" disabled></select>
                    </div>
                    <div class="form-group">
                        <label for="voiceFilterInput">Filter Voices</label>
                        <input type="text" id="voiceFilterInput" placeholder="Filter by name or gender..." disabled>
                        <label for="voiceSelect" style="margin-top: 5px;">Voice</label>
                        <select id="voiceSelect" class="voice-list" disabled></select>
                    </div>
                </div>
                <div class="form-group">
                    <label for="pitchRange">Pitch <span class="tooltip"><span class="icon">ⓘ</span><span class="tooltip-text">Adjust speaking pitch (-20 to 20). Default: 0.</span></span></label>
                    <input type="range" id="pitchRange" min="-20" max="20" value="0" step="1">
                    <div id="pitchValue" class="range-value">0</div>
                </div>
                <div class="form-group">
                    <label for="rateRange">Speaking Rate <span class="tooltip"><span class="icon">ⓘ</span><span class="tooltip-text">Adjust speaking rate (0.25 to 4.0). Default: 1.0.</span></span></label>
                    <input type="range" id="rateRange" min="0.25" max="4" value="1" step="0.05">
                    <div id="rateValue" class="range-value">1.00</div>
                </div>
            </div>

            <div class="panel">
                <h2>Advanced Chunking Settings</h2>
                <div class="form-group">
                    <label for="chunkSizeRange">Chunk Size <span class="tooltip"><span class="icon">ⓘ</span><span class="tooltip-text">Max characters per API request (500-4500). Google limit ~5000.</span></span></label>
                    <input type="range" id="chunkSizeRange" min="500" max="4500" value="3000" step="500">
                    <div id="chunkSizeValue" class="range-value">3000 characters</div>
                </div>
                <div class="form-group">
                    <label>Chunk Splitting Method <span class="tooltip"><span class="icon">ⓘ</span><span class="tooltip-text">How to split text: Sentence, Paragraph, or Exact characters.</span></span></label>
                    <div class="toggle-group" id="chunkMethodGroup">
                        <button class="toggle-button active" data-value="sentence">Sentence</button>
                        <button class="toggle-button" data-value="paragraph">Paragraph</button>
                        <button class="toggle-button" data-value="exact">Exact</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Processing Strategy <span class="tooltip"><span class="icon">ⓘ</span><span class="tooltip-text">Sequential: One chunk after another. Parallel: All chunks at once.</span></span></label>
                    <div class="toggle-group" id="processingStrategyGroup">
                        <button class="toggle-button active" data-value="sequential">Sequential</button>
                        <button class="toggle-button" data-value="parallel">Parallel</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Output Section Panels (Text Display, Player, Progress) -->
        <div class="output-section">
            <div class="panel">
                <h2>Text Display with Highlighting</h2>
                <div id="textDisplay" class="text-display">
                    <p>Your converted text will appear here...</p>
                </div>
            </div>

            <div class="panel">
                <h2>Audio Player</h2>
                <div class="audio-player">
                    <div class="timeline-container" id="timelineContainer">
                        <div class="buffered-progress" id="bufferedProgress"></div>
                        <div class="playback-progress" id="playbackProgress"></div>
                        <div class="timeline-tooltip" id="timelineTooltip"></div>
                    </div>
                    <div class="controls">
                        <div class="play-controls">
                            <button class="control-button" id="playButton" disabled title="Play/Pause">▶</button>
                            <button class="control-button" id="pauseButton" disabled title="Pause">⏸</button>
                            <button class="control-button" id="stopButton" disabled title="Stop">⏹</button>
                            <button class="control-button" id="rewindButton" disabled title="Rewind 10s">⏪ 10s</button>
                            <button class="control-button" id="forwardButton" disabled title="Forward 10s">10s ⏩</button>
                        </div>
                        <div class="time-display" id="timeDisplay">00:00 / 00:00</div>
                    </div>
                    <div class="download-section" style="margin-top: 15px; text-align: right;">
                        <button id="downloadButton" class="download-button" disabled title="Download combined audio as MP3">Download MP3</button>
                    </div>
                </div>

                <div class="progress-container">
                    <h3>Generation Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="status-message" id="statusMessage"></div>
                    <div class="error-message hidden" id="errorMessage"></div>
                     <p><small><strong>Need Help?</strong> Check Browser Console (F12 &gt; Console) for detailed errors.</small></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Constants ---
            const GOOGLE_TTS_API_URL = 'https://texttospeech.googleapis.com/v1';
            const LOCAL_STORAGE_KEY = 'advancedTtsSettings_v7'; // Updated key

            // --- UI Elements ---
            const ui = {
                apiKeyInput: document.getElementById('apiKey'), loadVoicesButton: document.getElementById('loadVoicesButton'),
                textInput: document.getElementById('textInput'), generateButton: document.getElementById('generateButton'),
                languageSelect: document.getElementById('languageSelect'), voiceFilterInput: document.getElementById('voiceFilterInput'), voiceSelect: document.getElementById('voiceSelect'),
                pitchRange: document.getElementById('pitchRange'), pitchValue: document.getElementById('pitchValue'), rateRange: document.getElementById('rateRange'), rateValue: document.getElementById('rateValue'),
                chunkSizeRange: document.getElementById('chunkSizeRange'), chunkSizeValue: document.getElementById('chunkSizeValue'),
                chunkMethodButtons: document.querySelectorAll('#chunkMethodGroup .toggle-button'), processingStrategyButtons: document.querySelectorAll('#processingStrategyGroup .toggle-button'),
                textDisplay: document.getElementById('textDisplay'), statusMessage: document.getElementById('statusMessage'), errorMessage: document.getElementById('errorMessage'),
                initStatus: document.getElementById('initStatus'), voiceLoadingStatus: document.getElementById('voiceLoadingStatus'),
                progressFill: document.getElementById('progressFill'), playButton: document.getElementById('playButton'), pauseButton: document.getElementById('pauseButton'),
                stopButton: document.getElementById('stopButton'), rewindButton: document.getElementById('rewindButton'), forwardButton: document.getElementById('forwardButton'),
                timeDisplay: document.getElementById('timeDisplay'), timelineContainer: document.getElementById('timelineContainer'), bufferedProgress: document.getElementById('bufferedProgress'),
                playbackProgress: document.getElementById('playbackProgress'), timelineTooltip: document.getElementById('timelineTooltip'), downloadButton: document.getElementById('downloadButton')
            };

            // --- App State ---
            const state = {
                apiKey: '', availableVoices: [], text: '', language: '', voice: '', pitch: 0, rate: 1,
                chunkSize: 3000, chunkMethod: 'sentence', processingStrategy: 'sequential',
                audio: { context: null, chunks: [], buffers: [], wordTimings: [], source: null, startTime: 0, pausedAt: 0, duration: 0, playing: false, buffering: false, currentChunk: 0, currentWord: -1 },
                processing: { chunks: [], chunkTimings: [], totalChunks: 0, completedChunks: 0, inProgress: false },
                ui: { voiceFilter: '' }
            };

            // --- Initialization ---
            initializeApplication();

            function initializeApplication() {
                console.log("Advanced TTS App Initializing (v7)...");
                loadSettings(); setupEventListeners(); updateRangeDisplays();
                showMessage("Enter API Key and click 'Load Voices', or settings might load automatically.");
                if (state.apiKey) { console.log("API Key found, attempting auto voice load."); ui.apiKeyInput.value = state.apiKey; handleLoadVoices(); }
            }

            // --- Settings Persistence ---
            function saveSettings() { try { const s = { apiKey: state.apiKey, language: state.language, voice: state.voice, pitch: state.pitch, rate: state.rate, chunkSize: state.chunkSize, chunkMethod: state.chunkMethod, processingStrategy: state.processingStrategy }; localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(s)); } catch (e) { console.error("Failed save settings:", e); } }
            function loadSettings() { try { const s = localStorage.getItem(LOCAL_STORAGE_KEY); if (s) { const p = JSON.parse(s); console.log("Loading saved settings:", p); state.apiKey = p.apiKey || ''; state.pitch = p.pitch ?? 0; state.rate = p.rate ?? 1; state.chunkSize = p.chunkSize ?? 3000; state.chunkMethod = p.chunkMethod || 'sentence'; state.processingStrategy = p.processingStrategy || 'sequential'; ui.pitchRange.value = state.pitch; ui.rateRange.value = state.rate; ui.chunkSizeRange.value = state.chunkSize; ui.chunkMethodButtons.forEach(b => b.classList.toggle('active', b.dataset.value === state.chunkMethod)); ui.processingStrategyButtons.forEach(b => b.classList.toggle('active', b.dataset.value === state.processingStrategy)); } } catch (e) { console.error("Failed load settings:", e); localStorage.removeItem(LOCAL_STORAGE_KEY); } }

            // --- Event Listeners ---
            function setupEventListeners() {
                 ui.loadVoicesButton.addEventListener('click', handleLoadVoices);
                 ui.apiKeyInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleLoadVoices(); });
                 ui.apiKeyInput.addEventListener('change', () => { state.apiKey = ui.apiKeyInput.value.trim(); saveSettings(); });
                 ui.languageSelect.addEventListener('change', handleLanguageChange);
                 ui.voiceFilterInput.addEventListener('input', handleVoiceFilterChange);
                 ui.voiceSelect.addEventListener('change', handleVoiceChange);
                 ui.pitchRange.addEventListener('input', () => { state.pitch = parseInt(ui.pitchRange.value); ui.pitchValue.textContent = state.pitch; saveSettings(); });
                 ui.rateRange.addEventListener('input', () => { state.rate = parseFloat(ui.rateRange.value); ui.rateValue.textContent = state.rate.toFixed(2); saveSettings(); });
                 ui.chunkSizeRange.addEventListener('input', () => { state.chunkSize = parseInt(ui.chunkSizeRange.value); ui.chunkSizeValue.textContent = `${state.chunkSize} chars`; saveSettings(); });
                 setupToggleButtons(ui.chunkMethodButtons, 'chunkMethod');
                 setupToggleButtons(ui.processingStrategyButtons, 'processingStrategy');
                 ui.generateButton.addEventListener('click', () => { initAudioContext(); startTTSGeneration(); });
                 ui.playButton.addEventListener('click', playAudio);
                 ui.pauseButton.addEventListener('click', pauseAudio);
                 ui.stopButton.addEventListener('click', stopAudio);
                 ui.rewindButton.addEventListener('click', () => seekAudio(-10));
                 ui.forwardButton.addEventListener('click', () => seekAudio(10));
                 ui.downloadButton.addEventListener('click', downloadAudio);
                 ui.timelineContainer.addEventListener('click', handleTimelineClick);
                 ui.timelineContainer.addEventListener('mousemove', handleTimelineMousemove);
                 ui.timelineContainer.addEventListener('mouseout', () => { ui.timelineTooltip.style.display = 'none'; });
            }
            function handleLanguageChange() { state.language = ui.languageSelect.value; console.log("Lang change:", state.language); state.ui.voiceFilter = ''; ui.voiceFilterInput.value = ''; populateVoices(state.language); saveSettings(); }
            function handleVoiceFilterChange() { state.ui.voiceFilter = ui.voiceFilterInput.value.toLowerCase(); console.log("Filter change:", state.ui.voiceFilter); populateVoices(state.language); }
            function handleVoiceChange() { state.voice = ui.voiceSelect.value; console.log("Voice change:", state.voice); saveSettings(); }
            function setupToggleButtons(buttons, prop) { buttons.forEach(b => { b.addEventListener('click', function() { buttons.forEach(btn => btn.classList.remove('active')); this.classList.add('active'); state[prop] = this.dataset.value; console.log(`${prop}=${state[prop]}`); saveSettings(); }); }); }
            function updateRangeDisplays() { ui.pitchValue.textContent = ui.pitchRange.value; ui.rateValue.textContent = parseFloat(ui.rateRange.value).toFixed(2); ui.chunkSizeValue.textContent = `${ui.chunkSizeRange.value} chars`; }

            // --- Voice Loading ---
            async function handleLoadVoices() { /* Same logic as v6 */ if (!state.apiKey) return showError("API Key required."); console.log("Loading voices..."); ui.voiceLoadingStatus.classList.remove('hidden'); ui.initStatus.classList.add('hidden'); ui.languageSelect.disabled = true; ui.voiceSelect.disabled = true; ui.voiceFilterInput.disabled = true; ui.generateButton.disabled = true; showMessage(""); showError(""); try { const voices = await fetchVoices(state.apiKey); state.availableVoices = voices; console.log(`Fetched ${voices.length} voices.`); populateLanguages(); const saved = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '{}'); if (saved.language && [...ui.languageSelect.options].some(o => o.value === saved.language)) state.language = saved.language; ui.languageSelect.value = state.language; populateVoices(state.language); if (saved.voice && [...ui.voiceSelect.options].some(o => o.value === saved.voice)) state.voice = saved.voice; else if (ui.voiceSelect.options.length > 0) state.voice = ui.voiceSelect.options[0].value; ui.voiceSelect.value = state.voice; ui.languageSelect.disabled = false; ui.voiceSelect.disabled = false; ui.voiceFilterInput.disabled = false; ui.generateButton.disabled = !state.voice; ui.voiceLoadingStatus.classList.add('hidden'); showMessage("Voices loaded. Ready."); saveSettings(); } catch (e) { console.error("Voice Load Fail:", e); showError(`Voice Load Fail: ${e.message}. Check Key/Perms/Billing & Console.`); ui.voiceLoadingStatus.classList.add('hidden'); ui.initStatus.classList.remove('hidden'); ui.initStatus.textContent = "Voice load failed. Check Key/Console (F12), retry."; state.apiKey = ''; saveSettings(); } }
            async function fetchVoices(apiKey) { /* Same logic as v6 */ const r = await fetch(`${GOOGLE_TTS_API_URL}/voices?key=${apiKey}`); if (!r.ok) { let m = `HTTP ${r.status}`; try { const d = await r.json(); m = d.error?.message || m; } catch (e) {} throw new Error(m); } const d = await r.json(); if (!d.voices) throw new Error("Invalid API response"); return d.voices; }
            function populateLanguages() { /* Same logic as v6 */ const cur = ui.languageSelect.value; ui.languageSelect.innerHTML = ''; const map = new Map(); state.availableVoices.forEach(v => v.languageCodes.forEach(c => map.set(c, getLanguageName(c)))); const sorted = [...map.entries()].sort((a, b) => a[1].localeCompare(b[1])); let defSet = false; sorted.forEach(([c, n]) => { const o = document.createElement('option'); o.value = c; o.textContent = n; ui.languageSelect.appendChild(o); if (c === 'en-US') { state.language = c; defSet = true; } }); if (!defSet && sorted.length > 0) state.language = sorted[0][0]; if ([...ui.languageSelect.options].some(o => o.value === cur)) state.language = cur; ui.languageSelect.value = state.language; console.log("Langs populated, selected:", state.language); }
            function populateVoices(languageCode) { /* Same logic as v6 */ const cur = ui.voiceSelect.value; ui.voiceSelect.innerHTML = ''; const filter = state.ui.voiceFilter; const filtered = state.availableVoices.filter(v => v.languageCodes.includes(languageCode) && (!filter || v.name.toLowerCase().includes(filter) || v.ssmlGender.toLowerCase().includes(filter))).sort((a, b) => a.name.localeCompare(b.name)); if (filtered.length === 0) { ui.voiceSelect.innerHTML = `<option value="">No voices match</option>`; state.voice = ''; ui.generateButton.disabled = true; return; } filtered.forEach(v => { const o = document.createElement('option'); o.value = v.name; o.textContent = `${v.name} (${v.ssmlGender})`; ui.voiceSelect.appendChild(o); }); if ([...ui.voiceSelect.options].some(o => o.value === cur)) state.voice = cur; else state.voice = filtered[0].name; ui.voiceSelect.value = state.voice; ui.generateButton.disabled = false; console.log("Voices populated for", languageCode, "filter '", filter, "', selected:", state.voice); }

            // --- Audio Context ---
            function initAudioContext() { /* Same logic as v6 */ if (!state.audio.context || state.audio.context.state === 'suspended') { try { window.AudioContext = window.AudioContext || window.webkitAudioContext; if (!state.audio.context) { state.audio.context = new AudioContext(); console.log("AudioContext created."); } if (state.audio.context.state === 'suspended') { state.audio.context.resume().then(() => console.log("AudioContext resumed.")).catch(e => { console.error("Resume failed:", e); showError("Audio context blocked."); }); } } catch (e) { showError("Web Audio API Error."); console.error("AudioContext init error:", e); state.audio.context = null; } } return state.audio.context; }

            // --- Utilities ---
            function formatTime(s) { s = Math.max(0, s || 0); const m = Math.floor(s / 60); s = Math.floor(s % 60); return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; }
            function updateTimeDisplay(c, t) { if (ui.timeDisplay) ui.timeDisplay.textContent = `${formatTime(c)} / ${formatTime(t)}`; }
            function showMessage(m) { if (ui.statusMessage) ui.statusMessage.textContent = m; if (ui.errorMessage) ui.errorMessage.classList.add('hidden'); }
            function showError(m) { if (ui.errorMessage) { ui.errorMessage.textContent = m; ui.errorMessage.classList.remove('hidden'); } if (ui.statusMessage) ui.statusMessage.textContent = ''; }
            function getLanguageName(c) { try { let rn = new Intl.DisplayNames(['en'], { type: 'language' }); return rn.of(c) || c; } catch (e) { const n = { 'en-US': 'English (US)', 'en-GB': 'English (UK)' }; return n[c] || c; } }

            // --- TTS Generation Core ---
            function startTTSGeneration() { /* Same logic as v6 */ state.text = ui.textInput.value.trim(); if (!state.apiKey) return showError("API Key not loaded."); if (!state.language || !state.voice) return showError("Lang/Voice missing."); if (!state.text) return showError("No text."); const ctx = initAudioContext(); if (!ctx) return showError("Audio unavailable."); console.log(`Starting TTS: ${state.voice}`); resetAudioState(); resetProcessingState(); updateUIForGeneration(true); prepareTextDisplay(); try { const chunks = splitTextIntoChunks(); if (!chunks?.length) throw new Error("Chunking failed."); state.processing.chunks = chunks; state.processing.totalChunks = chunks.length; state.processing.inProgress = true; showMessage(`Split to ${chunks.length} chunks. Generating...`); if (state.processingStrategy === 'sequential') processNextChunk(0); else processAllChunksInParallel(); } catch (e) { console.error("TTS Setup:", e); showError(`Setup Error: ${e.message}`); updateUIForGeneration(false); } }
            function resetAudioState() { /* Same logic as v6 */ console.log("Reset audio state."); if (state.audio.source) { try { state.audio.source.stop(); } catch (e) {} state.audio.source = null; } const size = state.processing.totalChunks || 1; state.audio.chunks = new Array(size); state.audio.buffers = new Array(size); state.audio.wordTimings = []; state.audio.startTime = 0; state.audio.pausedAt = 0; state.audio.duration = 0; state.audio.playing = false; state.audio.buffering = false; state.audio.currentChunk = 0; state.audio.currentWord = -1; document.querySelectorAll('.word.active').forEach(w => w.classList.remove('active')); updateTimeDisplay(0, 0); if (ui.playbackProgress) ui.playbackProgress.style.width = '0%'; if (ui.bufferedProgress) ui.bufferedProgress.style.width = '0%'; }
            function resetProcessingState() { /* Same logic as v6 */ console.log("Reset proc state."); state.processing.chunks = []; state.processing.chunkTimings = []; state.processing.totalChunks = 0; state.processing.completedChunks = 0; state.processing.inProgress = false; if (ui.progressFill) ui.progressFill.style.width = '0%'; }
            function updateUIForGeneration(starting) { /* Same logic as v6 */ ui.generateButton.disabled = starting; ui.generateButton.innerHTML = starting ? '<span class="spinner"></span> Generating...' : 'Generate Speech'; ui.playButton.disabled = true; ui.pauseButton.disabled = true; ui.stopButton.disabled = true; ui.rewindButton.disabled = true; ui.forwardButton.disabled = true; ui.downloadButton.disabled = true; if (!starting) { const hasAudio = state.audio.buffers.some(b => b); ui.playButton.disabled = !hasAudio; ui.stopButton.disabled = !hasAudio; ui.rewindButton.disabled = !hasAudio; ui.forwardButton.disabled = !hasAudio; if (state.processing.completedChunks === state.processing.totalChunks && hasAudio) ui.downloadButton.disabled = false; } }
            function prepareTextDisplay() { /* Same logic as v6 */ ui.textDisplay.innerHTML = ''; let idx = 0; state.text.split(/(\s+)/).forEach(p => { if (p?.trim()) { const s = document.createElement('span'); s.className = 'word'; s.dataset.index = idx; s.textContent = p; s.addEventListener('click', () => jumpToWord(parseInt(s.dataset.index))); ui.textDisplay.appendChild(s); idx++; } else if (p) { ui.textDisplay.appendChild(document.createTextNode(p)); } }); ui.textDisplay.scrollTop = 0; }
            function splitTextIntoChunks() { /* Same robust logic as v6 */ const text = state.text; const chunks = []; const max = state.chunkSize; let method = state.chunkMethod; if (text.length < max) return [text]; if (method === 'exact') { for (let i = 0; i < text.length; i += max) chunks.push(text.substring(i, i + max)); } else { let regex = method === 'paragraph' ? /(\n\s*\n)/ : /([.!?]+(?:\s+|$))/; let current = ''; let parts = text.split(regex).filter(Boolean); for (let i = 0; i < parts.length; i += 2) { let seg = parts[i]; let delim = parts[i+1] || ''; let full = seg + delim; if ((current + full).length <= max) { current += full; } else { if (current) chunks.push(current); if (full.length > max) { let rem = full; while (rem.length > max) { let splitPoint = -1; let subSegs = rem.substring(0, max).split(/([.!?]+(?:\s+|$))/).filter(Boolean); if (subSegs.length > 1) { let temp = ''; for (let j=0; j<subSegs.length; j+=2) { if ((temp + subSegs[j] + (subSegs[j+1]||'')).length <= max) temp += subSegs[j] + (subSegs[j+1]||''); else break; } if (temp) splitPoint = temp.length; } if (splitPoint > 0 && splitPoint < rem.length) { chunks.push(rem.substring(0, splitPoint)); rem = rem.substring(splitPoint); } else { chunks.push(rem.substring(0, max)); rem = rem.substring(max); } } current = rem; } else { current = full; } } } if (current) chunks.push(current); } console.log(`Split ${text.length} chars into ${chunks.length} chunks using ${method} method (max ${max}).`); return chunks; }
            function processNextChunk(index) { /* Same logic as v6 */ if (index >= state.processing.chunks.length) { finishProcessing(); return; } const chunk = state.processing.chunks[index]; if (!chunk?.trim()) { console.log(`Skip empty chunk ${index + 1}`); state.processing.completedChunks++; updateProgress(); processNextChunk(index + 1); return; } showMessage(`Req chunk ${index + 1}/${state.processing.totalChunks}`); callGoogleTTSAPI(chunk, index).then(d => { showMessage(`Decode chunk ${index + 1}/${state.processing.totalChunks}`); return processAudioData(d, index); }).then(() => { state.processing.completedChunks++; updateProgress(); processNextChunk(index + 1); }).catch(e => { console.error(`Seq Err chunk ${index + 1}:`, e); showError(`Chunk ${index + 1} fail: ${e.message}. See Console.`); updateUIForGeneration(false); }); }
            function processAllChunksInParallel() { /* Same logic as v6 */ showMessage(`Req ${state.processing.totalChunks} chunks (Parallel)...`); const promises = state.processing.chunks.map((chunk, i) => { if (!chunk?.trim()) { console.log(`Skip empty chunk ${i + 1}`); state.processing.completedChunks++; updateProgress(); return Promise.resolve(i); } return callGoogleTTSAPI(chunk, i).then(d => processAudioData(d, i)).then(() => { state.processing.completedChunks++; updateProgress(); return i; }).catch(e => { console.error(`Parallel Err chunk ${i + 1}:`, e); showError(`Chunk ${i + 1} fail: ${e.message}. See Console.`); return Promise.resolve(i); }); }); Promise.all(promises).then(finishProcessing).catch(e => { console.error("Unexpected Parallel Err:", e); finishProcessing(); }); }
            function callGoogleTTSAPI(text, index) { /* Same logic as v6 */ console.log(`API Call: Chunk ${index + 1}, Len: ${text.length}, Voice: ${state.voice}`); return new Promise((resolve, reject) => { let ssml = '<speak>'; let wc = 0; text.split(/(\s+)/).forEach(p => { if (p?.trim()) { const esc = p.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;'); ssml += `<mark name="${wc}"/>${esc}`; wc++; } else if (p) { ssml += p; } }); ssml += '</speak>'; const req = { input: { ssml: ssml }, voice: { languageCode: state.language, name: state.voice }, audioConfig: { audioEncoding: 'MP3', pitch: state.pitch, speakingRate: state.rate, enableTimePointing: ['SSML_MARK'] } }; fetch(`${GOOGLE_TTS_API_URL}/text:synthesize?key=${state.apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(req) }).then(res => { console.log(`Res Status (Chunk ${index + 1}): ${res.status}`); if (!res.ok) { return res.json().then(err => { const m = err.error?.message || `HTTP ${res.status}`; console.error(`API Err (Chunk ${index + 1}):`, err); reject(new Error(m)); }).catch(() => reject(new Error(`HTTP ${res.status}`))); } return res.json(); }).then(d => { if (!d.audioContent) return reject(new Error('No audio content')); console.log(`Recvd audio (Chunk ${index + 1}), Len: ${d.audioContent.length}`); let timings = []; if (d.timepoints) { let offset = 0; if (index > 0) for(let i=0; i<index; i++) offset += (state.processing.chunks[i]||'').split(/(\s+)/).filter(w=>w?.trim()).length; const start = getChunkStartTime(index); timings = d.timepoints.map(p => ({ time: p.timeSeconds + start, wordIndex: parseInt(p.markName) + offset })).sort((a, b) => a.wordIndex - b.wordIndex); } else console.warn(`No timepoints (Chunk ${index + 1})`); resolve({ audio: d.audioContent, timings: timings, chunkIndex: index }); }).catch(e => { console.error(`Fetch/Net Err (Chunk ${index + 1}):`, e); reject(new Error(`Network/API fail: ${e.message}`)); }); }); }
            function processAudioData(data, index) { /* Same logic as v6 */ return new Promise((resolve, reject) => { try { const audio = atob(data.audio); const buf = new ArrayBuffer(audio.length); const view = new Uint8Array(buf); for (let i = 0; i < audio.length; i++) view[i] = audio.charCodeAt(i); state.audio.chunks[index] = buf; if (data.timings) state.audio.wordTimings.push(...data.timings); console.log(`Decoding (Chunk ${index + 1})`); state.audio.context.decodeAudioData(buf.slice(0), buffer => { console.log(`Decoded Chunk ${index + 1}, Dur: ${buffer.duration.toFixed(3)}s`); state.audio.buffers[index] = buffer; calculateTotalDuration(); updateBufferedProgress(); if (index === 0 && !state.audio.playing) updatePlaybackControls(false); if (state.audio.playing && state.audio.buffering && index === state.audio.currentChunk) playCurrentChunk(state.audio.context.currentTime - state.audio.startTime); resolve(); }, e => { console.error(`Decode Err chunk ${index + 1}:`, e); reject(new Error(`Decode fail chunk ${index + 1}`)); }); } catch (e) { console.error(`Base64 Err chunk ${index + 1}:`, e); reject(new Error(`Data process fail chunk ${index + 1}`)); } }); }
            function calculateTotalDuration() { state.audio.duration = state.audio.buffers.reduce((s, b) => s + (b?.duration || 0), 0); updateTimeDisplay(state.audio.playing ? (state.audio.context.currentTime - state.audio.startTime) : state.audio.pausedAt, state.audio.duration); }
            function getChunkStartTime(index) { let t = 0; for (let i = 0; i < index; i++) t += state.audio.buffers[i]?.duration || 0; return t; }
            function updateProgress() { const p = state.processing.totalChunks > 0 ? (state.processing.completedChunks / state.processing.totalChunks) * 100 : 0; if (ui.progressFill) ui.progressFill.style.width = `${p}%`; showMessage(`Processed ${state.processing.completedChunks}/${state.processing.totalChunks} (${Math.round(p)}%)`); }
            function updateBufferedProgress() { let dur = 0; let contig = true; for (let i = 0; i < state.processing.totalChunks; i++) { if (state.audio.buffers[i] && contig) dur += state.audio.buffers[i].duration; else contig = false; } const p = state.audio.duration > 0 ? (dur / state.audio.duration) * 100 : 0; if (ui.bufferedProgress) ui.bufferedProgress.style.width = `${p}%`; }
            function finishProcessing() { /* Same logic as v6 */ state.processing.inProgress = false; calculateTotalDuration(); state.audio.wordTimings.sort((a, b) => a.time - b.time); updateUIForGeneration(false); const hasAudio = state.audio.duration > 0; if (state.processing.completedChunks === state.processing.totalChunks && hasAudio) { showMessage(`Generation complete! Duration: ${formatTime(state.audio.duration)}`); ui.downloadButton.disabled = false; } else if (!hasAudio) showError(`Generation failed. No audio produced.`); else { showError(`Generation incomplete. ${state.processing.completedChunks}/${state.processing.totalChunks} OK.`); if (state.audio.chunks.some(c=>c)) ui.downloadButton.disabled = false; } console.log("Processing finished."); }

            // --- Full Playback Logic --- (Re-integrated and verified)
            function playAudio() { const ctx = initAudioContext(); if (!ctx) return showError("Audio unavailable."); if (state.audio.playing) return; console.log("Play cmd"); if (state.audio.pausedAt > 0) resumeFromPause(); else startPlayback(); updatePlaybackControls(true); }
            function startPlayback() { if (!state.audio.buffers.some(b => b)) return showMessage("Waiting for audio..."); const firstChunkIdx = state.audio.buffers.findIndex(b => b); if (firstChunkIdx === -1) return showMessage("No audio decoded."); console.log("Starting playback."); state.audio.playing = true; state.audio.pausedAt = 0; state.audio.currentChunk = firstChunkIdx; const startTimeOffset = getChunkStartTime(firstChunkIdx); state.audio.startTime = state.audio.context.currentTime - startTimeOffset; playCurrentChunk(startTimeOffset); requestAnimationFrame(updatePlayback); }
            function resumeFromPause() { if (state.audio.pausedAt <= 0) return startPlayback(); console.log(`Resuming from ${state.audio.pausedAt.toFixed(3)}s`); state.audio.playing = true; state.audio.startTime = state.audio.context.currentTime - state.audio.pausedAt; const { chunkIndex } = findChunkForTime(state.audio.pausedAt); state.audio.currentChunk = chunkIndex; playCurrentChunk(state.audio.pausedAt); state.audio.pausedAt = 0; requestAnimationFrame(updatePlayback); }
            function playCurrentChunk(offset = 0) { const index = state.audio.currentChunk; if (index >= state.processing.totalChunks) { stopAudio(); return; } const buffer = state.audio.buffers[index]; if (!buffer) { showMessage("Buffering..."); state.audio.buffering = true; if (state.audio.source) { try { state.audio.source.stop(); } catch(e){} state.audio.source = null; } return; } if (state.audio.source) { try { state.audio.source.stop(); } catch(e){} } const source = state.audio.context.createBufferSource(); source.buffer = buffer; source.connect(state.audio.context.destination); state.audio.source = source; state.audio.buffering = false; const chunkStart = getChunkStartTime(index); const offsetInChunk = Math.max(0, offset - chunkStart); console.log(`Play chunk ${index + 1}, abs offset ${offset.toFixed(3)}s, chunk offset ${offsetInChunk.toFixed(3)}s`); source.onended = () => { if (state.audio.playing && state.audio.source === source) { console.log(`Chunk ${index + 1} ended.`); state.audio.currentChunk++; scheduleNextChunk(); } }; source.start(0, offsetInChunk); showMessage(`Playing chunk ${index + 1}/${state.processing.totalChunks}`); }
            function scheduleNextChunk() { const nextIndex = state.audio.currentChunk; if (nextIndex >= state.processing.totalChunks) { console.log("Playback finished."); stopAudio(); return; } playCurrentChunk(getChunkStartTime(nextIndex)); }
            function pauseAudio() { if (!state.audio.playing) return; console.log("Pause cmd"); state.audio.playing = false; state.audio.pausedAt = state.audio.context.currentTime - state.audio.startTime; if (state.audio.source) { state.audio.source.onended = null; try { state.audio.source.stop(); } catch(e){} state.audio.source = null; } updatePlaybackControls(false); showMessage(`Paused at ${formatTime(state.audio.pausedAt)}`); }
            function stopAudio() { console.log("Stop cmd"); state.audio.playing = false; state.audio.pausedAt = 0; if (state.audio.source) { state.audio.source.onended = null; try { state.audio.source.stop(); } catch(e){} state.audio.source = null; } state.audio.currentChunk = 0; state.audio.currentWord = -1; document.querySelectorAll('.word.active').forEach(w => w.classList.remove('active')); updatePlaybackControls(false); updatePlaybackProgress(0); updateTimeDisplay(0, state.audio.duration); showMessage("Stopped."); }
            function seekAudio(seconds) { if (state.audio.duration === 0) return; const current = state.audio.playing ? (state.audio.context.currentTime - state.audio.startTime) : state.audio.pausedAt; const newTime = Math.max(0, Math.min(current + seconds, state.audio.duration)); seekToTime(newTime); }
            function seekToTime(time) { if (state.audio.duration === 0) return; const newTime = Math.max(0, Math.min(time, state.audio.duration)); console.log(`Seek cmd to ${newTime.toFixed(3)}s`); if (!canSeekToTime(newTime)) { showMessage("Cannot seek: unbuffered"); return; } const wasPlaying = state.audio.playing; if (state.audio.source) { state.audio.source.onended = null; try { state.audio.source.stop(); } catch(e){} state.audio.source = null; } const { chunkIndex } = findChunkForTime(newTime); state.audio.currentChunk = chunkIndex; if (wasPlaying) { state.audio.playing = true; state.audio.startTime = state.audio.context.currentTime - newTime; playCurrentChunk(newTime); } else { state.audio.playing = false; state.audio.pausedAt = newTime; updatePlaybackProgress(newTime / state.audio.duration); updateTimeDisplay(newTime, state.audio.duration); highlightCurrentWord(newTime); } showMessage(`Seeked to ${formatTime(newTime)}`); }
            function canSeekToTime(time) { if (time < 0 || !state.audio.duration || time > state.audio.duration) return false; const { chunkIndex } = findChunkForTime(time); return chunkIndex < state.processing.totalChunks && state.audio.buffers[chunkIndex] !== undefined; }
            function findChunkForTime(time) { let current = 0; time = Math.max(0, time); for (let i = 0; i < state.processing.totalChunks; i++) { const buf = state.audio.buffers[i]; if (buf) { if (time < current + buf.duration || i === state.processing.totalChunks - 1) return { chunkIndex: i, chunkTime: time - current }; current += buf.duration; } else if (time >= current) return { chunkIndex: i, chunkTime: 0 }; } return { chunkIndex: Math.max(0, state.processing.totalChunks - 1), chunkTime: 0 }; }
            function jumpToWord(index) { console.log(`Jump to word ${index} req.`); let targetTime = -1; if (state.audio.wordTimings.length > 0) { for(let i = 0; i < state.audio.wordTimings.length; i++) { if (state.audio.wordTimings[i].wordIndex === index) { targetTime = state.audio.wordTimings[i].time; break; } if (state.audio.wordTimings[i].wordIndex < index) targetTime = state.audio.wordTimings[i].time; else break; } } if (targetTime < 0 && state.audio.duration > 0) { const words = ui.textDisplay.querySelectorAll('.word'); if (words.length > 0) targetTime = (index / words.length) * state.audio.duration; console.log(`Estimating time for word ${index}: ${targetTime.toFixed(3)}s`); } if (targetTime >= 0) seekToTime(targetTime); else console.warn(`Cannot find time for word ${index}`); }
            function updatePlayback() { if (!state.audio.playing) return; const currentTime = state.audio.context.currentTime - state.audio.startTime; const displayTime = Math.min(currentTime, state.audio.duration); if (displayTime >= state.audio.duration && state.audio.duration > 0) { console.log("updatePlayback reached end."); stopAudio(); updatePlaybackProgress(1); updateTimeDisplay(state.audio.duration, state.audio.duration); return; } updatePlaybackProgress(displayTime / state.audio.duration); updateTimeDisplay(displayTime, state.audio.duration); highlightCurrentWord(displayTime); requestAnimationFrame(updatePlayback); }
            function updatePlaybackProgress(f) { if (ui.playbackProgress) ui.playbackProgress.style.width = `${Math.min(1, Math.max(0, f)) * 100}%`; }

            function highlightCurrentWord(time) {
                let currentWordIndex = -1;
                // Find the latest word timing that is less than or equal to the current time
                for (let i = state.audio.wordTimings.length - 1; i >= 0; i--) {
                    if (state.audio.wordTimings[i].time <= time) {
                        currentWordIndex = state.audio.wordTimings[i].wordIndex;
                        break;
                    }
                }
                // Fallback estimation if no timing found (e.g., before first word)
                if (currentWordIndex === -1 && state.audio.duration > 0 && time > 0) {
                    const words = ui.textDisplay.querySelectorAll('.word');
                    currentWordIndex = Math.min(Math.floor((time / state.audio.duration) * words.length), words.length - 1);
                }

                // *** This is the completion of the cutoff part ***
                // Only update DOM if the highlighted word has changed
                if (currentWordIndex !== state.audio.currentWord) {
                    // Remove 'active' class from the previously highlighted word
                    const previousWordElement = ui.textDisplay.querySelector(`.word[data-index="${state.audio.currentWord}"]`);
                    if (previousWordElement) previousWordElement.classList.remove('active');

                    // Add 'active' class to the new current word
                    const currentWordElement = ui.textDisplay.querySelector(`.word[data-index="${currentWordIndex}"]`);
                    if (currentWordElement) {
                        currentWordElement.classList.add('active');
                        ensureWordVisible(currentWordElement); // Scroll the word into view if necessary
                    }
                    // Update the state to remember the new current word
                    state.audio.currentWord = currentWordIndex;
                }
                // *** End of completion ***
            }

            function ensureWordVisible(el) { const cont = ui.textDisplay; const contRect = cont.getBoundingClientRect(); const elRect = el.getBoundingClientRect(); if (elRect.top < contRect.top + 30) cont.scrollTop -= (contRect.top - elRect.top + 30); else if (elRect.bottom > contRect.bottom - 30) cont.scrollTop += (elRect.bottom - contRect.bottom + 30); }
            function updatePlaybackControls(playing) { const hasAudio = state.audio.duration > 0; if (ui.playButton) ui.playButton.disabled = playing || !hasAudio; if (ui.pauseButton) ui.pauseButton.disabled = !playing; if (ui.stopButton) ui.stopButton.disabled = !hasAudio; if (ui.rewindButton) ui.rewindButton.disabled = !hasAudio; if (ui.forwardButton) ui.forwardButton.disabled = !hasAudio; }

            // --- Timeline Interaction ---
            function handleTimelineClick(e) { /* Same as v6 */ if (!state.audio.duration) return; const rect = ui.timelineContainer.getBoundingClientRect(); const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)); const time = pos * state.audio.duration; console.log(`Timeline click: seek to ${time.toFixed(3)}s`); if (canSeekToTime(time)) seekToTime(time); else showMessage("Cannot seek: unbuffered"); }
            function handleTimelineMousemove(e) { /* Same as v6 */ if (!state.audio.duration) return; const rect = ui.timelineContainer.getBoundingClientRect(); const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)); const time = pos * state.audio.duration; ui.timelineTooltip.style.display = 'block'; ui.timelineTooltip.style.left = `${pos * 100}%`; ui.timelineTooltip.textContent = formatTime(time); ui.timelineTooltip.style.backgroundColor = canSeekToTime(time) ? 'rgba(0,0,0,0.8)' : 'rgba(234,67,53,0.8)'; }

            // --- Download ---
            function downloadAudio() { /* Same as v6 */ if (!state.audio.chunks.some(c => c)) return showError("No audio data."); const valid = state.audio.chunks.filter(c => c instanceof ArrayBuffer); if (valid.length === 0) return showError("No valid audio data."); try { const blob = new Blob(valid, { type: 'audio/mp3' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.style.display = 'none'; a.href = url; a.download = 'tts_output.mp3'; document.body.appendChild(a); a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a); showMessage("Download started."); } catch (e) { showError("Download failed."); console.error("Download error:", e); } }

        }); // End DOMContentLoaded
    </script>
</body>
</html>
