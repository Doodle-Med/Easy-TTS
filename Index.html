<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js" async defer></script>
<script src="voice-visualizer.js"></script>
<style>
/* --- CSS remains exactly the same --- */
:root { /* ... */ } [data-theme="dark"] { /* ... */ } * { /* ... */ } body { /* ... */ } h1 { /* ... */ } .grid { /* ... */ } .two { /* ... */ } @media(max-width:800px) { .two { /* ... */ } } .card { /* ... */ } .card:hover { /* ... */ } .card-header { /* ... */ } .card-header h2 { /* ... */ } label { /* ... */ } input, select, textarea, button { /* ... */ } input:focus, select:focus, textarea:focus { /* ... */ } textarea { /* ... */ } button { /* ... */ } button:not(:disabled):hover { /* ... */ } button:disabled { /* ... */ } .small-btn { /* ... */ } .toggle { /* ... */ } .toggle button { /* ... */ } .toggle .active { /* ... */ } .status { /* ... */ } .error { /* ... */ } .success { /* ... */ } .bar { /* ... */ } .fill { /* ... */ } .audio { /* ... */ } .audio button { /* ... */ } .time { /* ... */ } .text-box { /* ... */ } .word { /* ... */ } .word:hover { /* ... */ } .word.active { /* ... */ } .word.loading { /* ... */ } @keyframes shine { /* ... */ } .spinner { /* ... */ } @keyframes spin { /* ... */ } .controls { /* ... */ } .controls button { /* ... */ } .controls #authStatus { /* ... */ } .volume-control { /* ... */ } .volume-control input { /* ... */ } .download-btn { /* ... */ } .debug-panel { /* ... */ } .debug-entry { /* ... */ } .debug-time { /* ... */ } .debug-msg { /* ... */ } .debug-data { /* ... */ } .toggle-debug { /* ... */ } .theme-toggle { /* ... */ } .theme-toggle button { /* ... */ } .theme-toggle button:hover { /* ... */ } ::-webkit-scrollbar { /* ... */ } ::-webkit-scrollbar-track { /* ... */ } ::-webkit-scrollbar-thumb { /* ... */ } ::-webkit-scrollbar-thumb:hover { /* ... */ } .hidden { /* ... */ }
</style>
</head>
<body>
<h1>Google Cloud TTS Playground</h1>
<div class="theme-toggle">
  <button id="themeToggle" title="Toggle Theme">üåì</button>
</div>
<div class="grid two">
  <div class="card">
    <div class="card-header"><h2>üéõÔ∏è Configuration</h2></div>
    <label>Authentication</label>
    <div class="controls">
      <button class="small-btn" id="signInBtn" disabled>Sign in with Google</button>
      <span id="authStatus">Initializing...</span>
    </div>
    <button class="small-btn" id="ld" disabled>Load Voices</button>
    <div id="loading" class="status hidden"><span class="spinner"></span>Loading voices...</div>
    <label>Text</label><textarea id="txt" placeholder="Type or paste text here..."></textarea>
    <label>Voice</label><select id="v" disabled></select>
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:.8rem">
      <div><label>Pitch <span id="pitVal">0</span></label><input id="pit" type="range" min="-20" max="20" value="0"/></div>
      <div><label>Rate <span id="ratVal">1</span></label><input id="rat" type="range" min="0.25" max="4" step="0.05" value="1"/></div>
    </div>
    <label>Chunk Size <span id="chkVal">1000</span></label><input id="chk" type="range" min="500" max="4500" step="500" value="1000"/>
    <div class="toggle" id="method"><button data-m="sentence">Sentence</button><button data-m="paragraph" class="active">Paragraph</button><button data-m="exact">Exact</button></div>
    <button id="gen" disabled>üé§ Generate & Play</button><div id="stat" class="status"></div>
  </div>
  <div class="card">
    <div class="card-header"><h2>üîä Playback</h2></div>
    <div id="text" class="text-box"><p style="opacity:.6;text-align:center;">Words will appear here...</p></div>
    <canvas id="visualizer" height="80" style="width:100%;margin:0.8rem 0;border:1px solid var(--bd);border-radius:var(--r);"></canvas>
    <div class="bar" id="prog"><div class="fill" id="fill"></div></div>
    <div class="audio">
      <button class="small-btn" id="play" disabled title="Play">‚ñ∂</button><button class="small-btn" id="pause" disabled title="Pause">‚è∏</button><button class="small-btn" id="stop" disabled title="Stop">‚èπ</button>
      <div class="volume-control"><span>üîä</span><input type="range" id="volume" min="0" max="1" step="0.1" value="1"/></div>
      <span class="time" id="time">00:00 / 00:00</span>
    </div>
    <button id="download" class="download-btn" disabled>üíæ Download Audio</button>
    <div class="toggle-debug" id="toggleDebug">Show Debug Info</div><div id="debugPanel" class="debug-panel hidden"></div>
  </div>
</div>

<script>
// --- Global Scope ---
let gapiReady = false;
let gisReady = false;
let tokenClient;
let accessToken = null;
// ** Define placeholder functions globally to avoid errors if called before DOM ready **
// These will be overwritten by the versions inside DOMContentLoaded
let initializeGapiClient = () => { console.warn("initializeGapiClient called before DOM ready!"); };
let handleTokenResponse = () => { console.warn("handleTokenResponse called before DOM ready!"); };
let checkEnableSignIn = () => { console.warn("checkEnableSignIn called before DOM ready!"); };

// --- Functions called by Google Libraries (must be global) ---
function gapiLoaded() {
    console.log("[GLOBAL] gapiLoaded triggered."); // <<< NEW LOG
    // Queue the client library loading, callback inside DOMContentLoaded
    // The actual 'initializeGapiClient' it calls will be the one defined later
    gapi.load('client', initializeGapiClient);
}

function gisLoaded() {
    console.log("[GLOBAL] gisLoaded triggered."); // <<< NEW LOG
    try {
        console.log("[GLOBAL] Initializing Token Client..."); // <<< NEW LOG
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: '879295177554-m3j1d2pks6lukl3h9cl92r953ef2jd4e.apps.googleusercontent.com',
            scope: 'https://www.googleapis.com/auth/cloud-platform',
            callback: handleTokenResponse, // Pass the function reference (defined below)
        });
        console.log("[GLOBAL] Token client initialization apparently successful."); // <<< NEW LOG
        gisReady = true;
        checkEnableSignIn(); // Attempt to enable sign-in button (needs DOM ready)
    } catch (error) {
        console.error('[GLOBAL] Error initializing Token Client:', error); // <<< NEW LOG
        // Maybe update status visually if possible, though E might not exist yet
        const authStatusSpan = document.getElementById('authStatus');
         if(authStatusSpan) authStatusSpan.textContent = 'Auth Error (GIS Init)';
    }
}

// --- DOMContentLoaded Listener ---
window.addEventListener('DOMContentLoaded', () => {
    console.log("[DOM] DOMContentLoaded event fired."); // <<< NEW LOG

    // --- Constants and Element Map ---
    const VO = 'https://texttospeech.googleapis.com/v1/voices';
    const SY = 'https://texttospeech.googleapis.com/v1/text:synthesize';
    const Q = id => document.getElementById(id);
    const E = {
        signInBtn: Q('signInBtn'), authStatus: Q('authStatus'), load: Q('ld'), loading: Q('loading'),
        txt: Q('txt'), voice: Q('v'), pit: Q('pit'), rat: Q('rat'), pitVal: Q('pitVal'), ratVal: Q('ratVal'),
        chk: Q('chk'), chkVal: Q('chkVal'), gen: Q('gen'), stat: Q('stat'), methodBtns: [...Q('method').children],
        textBox: Q('text'), play: Q('play'), pause: Q('pause'), stop: Q('stop'), volume: Q('volume'),
        download: Q('download'), prog: Q('prog'), fill: Q('fill'), time: Q('time'),
        toggleDebug: Q('toggleDebug'), debugPanel: Q('debugPanel'), themeToggle: Q('themeToggle')
    };
    console.log("[DOM] E object defined."); // <<< NEW LOG


    // --- Debug Logging Setup (as before) ---
    let debugEnabled = localStorage.getItem('debugEnabled') === 'true'; const maxDebugEntries = 100; let debugEntries = []; const updateDebugPanel = () => { E.debugPanel.innerHTML = debugEntries.map(entry => { const timeStr = new Date(entry.timestamp).toLocaleTimeString(); let dataStr = ''; if (entry.data !== null) { try { dataStr = `<div class="debug-data">${(typeof entry.data === 'object' ? JSON.stringify(entry.data) : entry.data)}</div>`; } catch (e) { dataStr = `<div class="debug-data">[Complex Object]</div>`; } } return `<div class="debug-entry ${entry.level}"><span class="debug-time">${timeStr}</span> <span class="debug-msg">${entry.message}</span>${dataStr}</div>`; }).join(''); }; const log = (message, data = null, level = 'info') => { const timestamp = new Date().toISOString(); const entry = { timestamp, message, data, level }; debugEntries.unshift(entry); if (debugEntries.length > maxDebugEntries) debugEntries.pop(); const consoleMethod = level === 'error' ? console.error : level === 'warn' ? console.warn : console.log; consoleMethod(`[${new Date(timestamp).toLocaleTimeString()}] ${message}`, data ?? ''); if (debugEnabled && E?.debugPanel) updateDebugPanel(); }; if (debugEnabled) { E.debugPanel.classList.remove('hidden'); E.toggleDebug.textContent = 'Hide Debug Info'; } E.toggleDebug.addEventListener('click', () => { debugEnabled = !debugEnabled; localStorage.setItem('debugEnabled', debugEnabled); E.debugPanel.classList.toggle('hidden', !debugEnabled); E.toggleDebug.textContent = debugEnabled ? 'Hide Debug Info' : 'Show Debug Info'; if (debugEnabled) updateDebugPanel(); });

    // --- Theme Toggle (as before) ---
    let isDarkMode = localStorage.getItem('darkMode') === 'true'; if (isDarkMode) document.documentElement.setAttribute('data-theme', 'dark'); E.themeToggle.addEventListener('click', () => { isDarkMode = !isDarkMode; document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light'); localStorage.setItem('darkMode', isDarkMode); log(`Theme changed to ${isDarkMode ? 'dark' : 'light'} mode`); });

    // --- Status Function (as before) ---
     const status = (m, isError) => { if(!E?.stat) return; E.stat.textContent = m; E.stat.className = 'status' + (isError ? ' error' : isError === false ? ' success' : ''); log(m, null, isError ? 'error' : 'info'); };

    // --- OAuth Initialization & Handling Functions (Defined Inside DOMContentLoaded) ---

    // Overwrite the global placeholder
    initializeGapiClient = async () => {
        console.log("[DOM] initializeGapiClient called."); // <<< NEW LOG
        log('Initializing GAPI client...');
        try {
            console.log("[DOM] Calling gapi.client.init..."); // <<< NEW LOG
            await gapi.client.init({
                 // API Key is NOT needed here when using OAuth
                discoveryDocs: ['https://texttospeech.googleapis.com/$discovery/rest?version=v1']
            });
            console.log("[DOM] gapi.client.init successful."); // <<< NEW LOG
            gapiReady = true;
            log('GAPI client initialized.');
            checkEnableSignIn();
        } catch (error) {
            console.error('[DOM] GAPI client initialization failed:', error); // <<< NEW LOG
            log('GAPI client initialization failed', error.message || error, 'error');
            status('Failed to initialize Google API client.', true);
            if(E?.authStatus) E.authStatus.textContent = 'Auth Error (GAPI Init)';
        }
    }

    // Overwrite the global placeholder
    handleTokenResponse = (resp) => {
        console.log("[DOM] handleTokenResponse called.", "Response:", resp); // <<< NEW LOG
        if (resp.error) {
            console.error('[DOM] OAuth error response:', resp);
            log(`OAuth Error: ${resp.error}`, resp, 'error');
            status(`OAuth failed: ${resp.error_description || resp.error}`, true);
            accessToken = null;
            if(E?.authStatus) E.authStatus.textContent = '‚ùå Sign-in failed';
            if(E?.load) E.load.disabled = true;
            // Re-enable sign-in button on failure *if* the client itself initialized ok
            if(E?.signInBtn && tokenClient) E.signInBtn.disabled = false;
            return;
        }
        accessToken = resp.access_token;
        log('OAuth successful, access token obtained.');
        if(E?.authStatus) E.authStatus.textContent = '‚úÖ Signed in';
        // Keep Sign in button enabled
        if(E?.load) E.load.disabled = false;
        log('Triggering auto-load voices...');
        if(E?.load) E.load.click(); else console.error("E.load not found in handleTokenResponse");
    }

    // Overwrite the global placeholder
    checkEnableSignIn = () => {
        console.log(`[DOM] checkEnableSignIn called: gapiReady=${gapiReady}, gisReady=${gisReady}, E exists=${!!E}`); // <<< NEW LOG
        if (gapiReady && gisReady && E?.signInBtn) {
            E.signInBtn.disabled = false;
            if (E.authStatus) E.authStatus.textContent = 'Ready to sign in';
            log('GAPI and GIS ready, Sign-In button enabled.');
            console.log("[DOM] Sign-In button ENABLED."); // <<< NEW LOG
        } else if (E?.authStatus) {
             // Update status only if DOM element exists
             E.authStatus.textContent = `Initializing... (GAPI: ${gapiReady}, GIS: ${gisReady})`;
        } else {
            console.warn("[DOM] checkEnableSignIn: Cannot update status or button yet (DOM not ready or libs not ready)."); // <<< NEW LOG
        }
    }

    // --- Application State & Core Logic (Reduced for brevity - Use full code from previous correct version) ---
    let ctx; let gainNode; let voices = []; let buffers = []; let audioBlobs = []; let audioSources = []; let wordElements = []; let wordTimings = []; let totalDuration = 0; let loadedDuration = 0; let startTime = 0; let pausedAt = 0; let playbackId = 0; let playing = false; let paused = false; let method = 'paragraph'; let currentWordIndex = -1; let loadingComplete = false; let chunksReceived = 0; let totalChunks = 0; let chunksData = []; let visualizer;
    const fmt = s => `${String(Math.floor(s/60)).padStart(2, '0')}:${String(Math.floor(s%60)).padStart(2, '0')}`;
    const fetchJSON = async (url, opts) => { try { log(`Workspaceing ${url}`, opts); const r = await fetch(url, opts); if (!r.ok) { let m = `HTTP ${r.status}`; try { const d = await r.json(); m = d.error?.message || m; log('API Error Resp', d,'error');} catch(e){log('No JSON in API err','warn');} throw new Error(m); } const d = await r.json(); log(`Workspace ${url} OK`); return d; } catch (e) { log(`Workspace error ${url}: ${e.message}`, e, 'error'); throw e; } };
    const splitText = t => { const m = +E.chk.value; log(`Splitting text (${t.length}) mtd: ${method}, chunk: ${m}`); if (t.length <= m) return [t]; if (method === 'exact') { const a = []; for (let i = 0; i < t.length; i += m) a.push(t.slice(i, i + m)); log(`Split exact: ${a.length}`); return a; } const re = method === 'paragraph' ? /\n\s*\n/ : /([.!?]+["']?\s+)/; const bits = t.split(re).filter(Boolean); log(`Split initial: ${bits.length}`); const out = []; let cur = ''; for (const p of bits) { if ((cur + p).length > m) { if (cur.trim()) out.push(cur.trim()); cur = ''; if (p.length > m) { let q = p; while (q.length > m) { out.push(q.slice(0, m)); q = q.slice(m); } cur = q; } else { cur = p; } } else { cur += p; } } if (cur.trim()) out.push(cur.trim()); log(`Final chunks: ${out.length}`); return out; };
    const decodeBuffer = a => { log(`Decoding buffer ${a.byteLength} bytes`); return new Promise((res, rej) => { try { if (!ctx) { rej(new Error("AudioContext not init")); return; } ctx.decodeAudioData(a, (b) => { log(`Decoded: ${b.duration.toFixed(2)}s`); res(b); }, (e) => { log(`Decode error`, e, 'error'); rej(e); }); } catch (e) { log(`Decode exception`, e, 'error'); rej(e); } }); };
    const prepareTextDisplay = (text, chunks) => { log(`Prep text display: ${text.length} chars, ${chunks.length} chunks`); E.textBox.innerHTML = ''; wordElements = []; wordTimings = []; chunksData = []; chunks.forEach((c, i) => { chunksData[i] = { text: c, sT: 0, eT: 0, wc: c.split(/\s+/).filter(Boolean).length, dur: 0, ld: false }; }); let cC = 0; let cWC = 0; let cSP = 0; let gWI = 0; text.split(/(\s+)/).forEach((p) => { if (p.trim()) { const s = document.createElement('span'); s.textContent = p; s.className = 'word loading'; s.dataset.index = gWI; let cTP = text.indexOf(p, cSP); while (cSP + chunksData[cC]?.text.length <= cTP && cC < chunks.length - 1) { cSP += chunksData[cC].text.length; cC++; cWC = 0; } s.dataset.chunk = cC; wordTimings[gWI] = { w: p, c: cC, iic: cWC, sT: 0, eT: 0 }; cWC++; s.onclick = (e) => { if (s.classList.contains('loading')) { status('Still loading...'); return; } seekToWord(parseInt(e.currentTarget.dataset.index)); }; wordElements.push(s); E.textBox.appendChild(s); gWI++; } else { E.textBox.appendChild(document.createTextNode(p)); } }); log(`Prep text done: ${gWI} words`); };
    const updateWordTimings = (ci, dur) => { if (!chunksData[ci]) return; log(`Update timings chunk ${ci}, dur ${dur.toFixed(2)}s`); chunksData[ci].ld = true; chunksData[ci].dur = dur; let cST = 0; for (let i = 0; i < ci; i++) { if (chunksData[i]?.ld && chunksData[i].dur > 0) cST += chunksData[i].dur; else log(`Warn: Prev chunk ${i} timing needed for ${ci} missing`, chunksData[i], 'warn'); } chunksData[ci].sT = cST; chunksData[ci].eT = cST + dur; const wc = chunksData[ci].wc; if (wc <= 0) return; wordTimings.forEach((t, i) => { if (t.c === ci) { const sT = cST + (t.iic / wc) * dur; const nST = cST + ((t.iic + 1) / wc) * dur; const eT = Math.min(cST + dur, nST - 0.01); t.sT = sT; t.eT = Math.max(sT + 0.05, eT); const el = wordElements[i]; if (el) el.classList.remove('loading'); } }); log(`Updated timings chunk ${ci}`); };
    const locateTimePosition = (t) => { const sL = Math.random() < 0.01; if (sL) log(`Locate time ${t.toFixed(2)}s`); const mT = loadingComplete ? totalDuration : loadedDuration; t = Math.max(0, Math.min(t, mT)); for (let i = 0; i < chunksData.length; i++) { if (chunksData[i]?.ld && t >= chunksData[i].sT && t < chunksData[i].eT) { const o = t - chunksData[i].sT; if (sL) log(`Found time ${t.toFixed(2)}s in chunk ${i} offset ${o.toFixed(2)}s`); return { chunk: i, offset: o }; } } let fC = 0; let fO = 0; for (let i = 0; i < chunksData.length; i++) { if (chunksData[i]?.ld && chunksData[i].sT <= t) { fC = i; fO = Math.min(chunksData[i].dur, t - chunksData[i].sT); } else if(chunksData[i]?.ld) break; } if (sL) log(`Fallback time ${t.toFixed(2)}s to chunk ${fC} offset ${fO.toFixed(2)}s`); return { chunk: fC, offset: fO }; };
    const initAudioContext = () => { if(!ctx){log('Init AudioCtx');try{ctx=new(window.AudioContext||window.webkitAudioContext)();gainNode=ctx.createGain();gainNode.gain.value=E.volume.value;gainNode.connect(ctx.destination);if(typeof VoiceVisualizer!=='undefined'){visualizer=new VoiceVisualizer('visualizer',ctx,{mode:'waveform',color:isDarkMode?'#8ab4f8':'#4285f4',stroke:2});log('Visualizer init.');}else{log('No Visualizer class','warn');Q('visualizer').style.display='none';}log('AudioCtx init OK',{sr:ctx.sampleRate,st:ctx.state});ctx.onstatechange=()=>{log(`AudioCtx state: ${ctx.state}`);if(ctx.state==='interrupted'){stopPlayback();status('Audio interrupted.',true);}else if(ctx.state==='suspended'){ctx.resume().catch(e=>log('Resume failed',e,'error'));}}; }catch(e){log('AudioCtx init FAIL',e,'error');status('Audio init failed: '+e.message,true);[E.play,E.pause,E.stop,E.gen].forEach(b=>b.disabled=true);return Promise.reject(e);}} if(ctx.state==='suspended'){log('AudioCtx suspended, resume...');return ctx.resume().then(()=>{log('Resumed.');return ctx;}).catch(e=>{log('Resume failed',e,'error');status('Audio resume failed.',true);throw e;});} return Promise.resolve(ctx); };
    const cancelPlayback = () => { log('Cancel playback'); if (visualizer) visualizer.stop(); audioSources.forEach((s) => { if (s) { s.onended = null; try { s.stop(); } catch (e) {} } }); audioSources = []; };
    const updateUI = (t) => { const dT = Math.max(0, Math.min(t, totalDuration)); const p = totalDuration > 0 ? (dT / totalDuration) * 100 : 0; E.fill.style.width = `${Math.max(0, Math.min(100, p))}%`; E.time.textContent = `${fmt(dT)} / ${fmt(totalDuration)}`; updateWordHighlight(dT); if (playing) status(`Playing... ${fmt(dT)} / ${fmt(totalDuration)}`); };
    const updateWordHighlight = (t) => { let nWI = -1; for (let i = 0; i < wordTimings.length; i++) { const tm = wordTimings[i]; if (tm && typeof tm.sT === 'number' && typeof tm.eT === 'number' && tm.sT <= t && t <= tm.eT) { nWI = i; break; } } if (nWI === -1) { for (let i = wordTimings.length - 1; i >= 0; i--) { const tm = wordTimings[i]; if (tm && typeof tm.sT === 'number' && t >= tm.sT) { nWI = i; break; } } } if (nWI !== currentWordIndex && nWI !== -1) { if (currentWordIndex >= 0 && wordElements[currentWordIndex]) wordElements[currentWordIndex].classList.remove('active'); if (nWI >= 0 && wordElements[nWI]) { const wE = wordElements[nWI]; wE.classList.add('active'); const c = E.textBox; const wT = wE.offsetTop - c.offsetTop; const wB = wT + wE.offsetHeight; const cST = c.scrollTop; const cH = c.clientHeight; const sB = 30; if (wT < cST + sB) c.scrollTop = Math.max(0, wT - sB); else if (wB > cST + cH - sB) c.scrollTop = wB - cH + sB; } currentWordIndex = nWI; } };
    const stopPlayback = (silent = false) => { const was = playing || paused; cancelPlayback(); playing = false; paused = false; pausedAt = 0; startTime = 0; if (currentWordIndex >= 0 && wordElements[currentWordIndex]) wordElements[currentWordIndex].classList.remove('active'); currentWordIndex = -1; if (!silent && was) { log('Stopped'); if (totalDuration > 0) { updateUI(0); E.play.disabled = false; } else E.play.disabled = true; E.pause.disabled = true; E.stop.disabled = true; status('Stopped.'); } else if (!silent) { E.play.disabled = !(totalDuration > 0); E.pause.disabled = true; E.stop.disabled = true; } };
    const playChunk = (idx, off = 0, id) => { if (id !== playbackId) { log(`Stale play: ${id}`); return; } if (idx >= buffers.length || !buffers[idx]) { if (loadingComplete) { log(`End audio chunk ${idx}`); stopPlayback(); } else { log(`Chunk ${idx} wait...`); status(`Buffering...`); setTimeout(() => { if (playing && id === playbackId) playChunk(idx, off, id); }, 300); } return; } const buf = buffers[idx]; log(`Play chunk ${idx} off ${off.toFixed(2)} (dur ${buf.duration.toFixed(2)})`); const src = ctx.createBufferSource(); src.buffer = buf; const dest = visualizer?.analyser ? visualizer.analyser : gainNode; src.connect(dest); if (visualizer?.analyser) visualizer.analyser.connect(gainNode); src.onended = () => { if (audioSources[idx] === src) audioSources[idx] = null; if (playing && id === playbackId) { log(`Chunk ${idx} ended.`); playChunk(idx + 1, 0, id); } }; audioSources[idx] = src; const vOff = Math.max(0, Math.min(off, buf.duration - 0.001)); try { src.start(0, vOff); if(visualizer) visualizer.start(); } catch (e) { log(`Start chunk ${idx} err`, e, 'error'); if (playing && id === playbackId) playChunk(idx + 1, 0, id); } };
    const startPlayback = (cI, off = 0, aT = 0) => { initAudioContext().then(() => { playbackId = Date.now(); playing = true; paused = false; startTime = ctx.currentTime - aT; log(`Start playback chunk ${cI} off ${off.toFixed(2)} abs ${aT.toFixed(2)} ctx ${ctx.currentTime.toFixed(2)}`); E.play.disabled = true; E.pause.disabled = false; E.stop.disabled = false; status(`Playing... ${fmt(aT)} / ${fmt(totalDuration)}`); playChunk(cI, off, playbackId); requestAnimationFrame(updatePlayback); }).catch(e => {}); };
    const pausePlayback = () => { if (!playing) return; pausedAt = ctx.currentTime - startTime; playing = false; paused = true; log(`Pause at ${pausedAt.toFixed(2)}s`); cancelPlayback(); E.play.disabled = false; E.pause.disabled = true; status(`Paused at ${fmt(pausedAt)}`); };
    const resumePlayback = () => { if (!paused) return; log(`Resume from ${pausedAt.toFixed(2)}s`); const { chunk, offset } = locateTimePosition(pausedAt); startPlayback(chunk, offset, pausedAt); };
    const seekToTime = (t) => { if (!chunksData.some(c => c?.ld && c.dur > 0)) { log(`Seek fail: no audio`); return; } const mST = loadingComplete ? totalDuration : loadedDuration; t = Math.max(0, Math.min(t, mST)); log(`Seek to ${t.toFixed(2)}s`); const { chunk, offset } = locateTimePosition(t); const wasP = playing; cancelPlayback(); if (paused || !wasP) { pausedAt = t; paused = true; playing = false; updateUI(t); log(`Seek updated pause pos ${t.toFixed(2)}s`); E.play.disabled = false; E.pause.disabled = true; } else { startPlayback(chunk, offset, t); } };
    const seekToWord = (wI) => { wI = parseInt(wI); if (isNaN(wI) || wI < 0 || wI >= wordElements.length) { log(`Seek word ${wI} out of range`); return; } const tm = wordTimings[wI]; if (!tm) { log(`No timing word ${wI}`); return; } const cI = tm.c; if (!chunksData[cI]?.ld || !buffers[cI]) { log(`Word ${wI} (${tm.w}) chunk ${cI} not loaded`); status('Wait audio load.', true); return; } const time = tm.sT; log(`Seek word "${tm.w}" (idx ${wI}) time ${time.toFixed(2)}s`); seekToTime(time); };
    const createDownloadLink = () => { log('Create DL'); const vB = audioBlobs.filter(b => b instanceof Blob && b.size > 0); if (!vB.length) { log('No valid blobs','err'); status('No audio DL', true); return; } try { const cB = new Blob(vB, { type: 'audio/mp3' }); log(`Combined blob: ${(cB.size / 1024 / 1024).toFixed(2)} MB`); const url = URL.createObjectURL(cB); const a = document.createElement('a'); a.href = url; a.download = 'speech_' + new Date().toISOString().replace(/[:.]/g, '-') + '.mp3'; log(`Trigger DL: ${a.download}`); document.body.appendChild(a); a.click(); setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); log('DL cleanup'); }, 100); status('DL started', false); } catch (e) { log('DL err', e, 'error'); status('DL failed: ' + e.message, true); } };

    // --- Event Listeners ---
    E.signInBtn.onclick = () => {
        console.log("[DOM] signInBtn clicked."); // <<< NEW LOG
        log('signInBtn clicked');
        if (!tokenClient) {
            log('Token client not ready.', null, 'warn');
            status('Authentication system not ready.', true);
            console.warn("[DOM] Sign-in failed: tokenClient not ready."); // <<< NEW LOG
            return;
        }
        log('Requesting access token...');
        console.log("[DOM] Calling tokenClient.requestAccessToken..."); // <<< NEW LOG
        try {
             tokenClient.requestAccessToken({ prompt: accessToken ? '' : 'consent' });
        } catch(error) {
             console.error('[DOM] Error calling requestAccessToken:', error); // <<< NEW LOG
             log('Error initiating sign-in', error, 'error');
             status('Sign-in error.', true);
        }
    };
    E.load.onclick = async () => { /* --- Load Voices --- */ if (!accessToken) { status('Sign in first.', true); if (tokenClient) tokenClient.requestAccessToken({ prompt: 'consent' }); else status('Auth not ready.', true); return; } E.loading.classList.remove('hidden'); E.load.disabled = true; E.gen.disabled = true; status('Loading voices...'); try { log(`Req voices ${VO}`); const d = await fetchJSON(VO, { method: 'GET', headers: { 'Authorization': 'Bearer ' + accessToken } }); voices = d.voices || []; if (!voices.length) throw new Error('No voices'); log(`Loaded ${voices.length} voices`); const lM = new Map(); voices.forEach(v => v.languageCodes.forEach(c => { let n = c; try { n = new Intl.DisplayNames(['en'], { type: 'language' }).of(c); } catch (e) {} if (!lM.has(c)) lM.set(c, { name: n, voices: [] }); lM.get(c).voices.push(v); })); const sL = [...lM.entries()].sort((a, b) => a[1].name.localeCompare(b[1].name)); const h = sL.map(([c, { name, voices }]) => { const o = voices.sort((a, b) => a.name.localeCompare(b.name)).map(v => `<option value="${v.name}" data-l="${c}">${v.name}${v.name.includes('Neural') || v.name.includes('Wavenet') ? ' (N)' : ''}</option>`).join(''); return `<optgroup label="${name}">${o}</optgroup>`; }).join(''); E.voice.innerHTML = h; E.voice.disabled = false; E.gen.disabled = false; status('Voices loaded', false); } catch (e) { status(`Load voices failed: ${e.message}`, true); log('Voice load err', e, 'error'); if (String(e.message).includes('401') || String(e.message).includes('403')) { accessToken = null; E.authStatus.textContent = '‚ö†Ô∏è Re-auth'; E.load.disabled = true; } } finally { E.loading.classList.add('hidden'); E.load.disabled = !accessToken; } };
    E.gen.onclick = async () => { /* --- Generate Speech --- */ if (!accessToken) { status('Sign in first.', true); if (tokenClient) tokenClient.requestAccessToken({ prompt: 'consent' }); else status('Auth not ready.', true); return; } if (!E.voice.value) { status('Select voice.', true); return; } try { await initAudioContext(); const t = E.txt.value.trim(); if (!t) { status('Enter text.', true); return; } stopPlayback(true); buffers = []; audioBlobs = []; audioSources = []; wordTimings = []; chunksData = []; totalDuration = 0; loadedDuration = 0; loadingComplete = false; E.download.disabled = true; E.play.disabled = true; E.pause.disabled = true; E.stop.disabled = true; const c = splitText(t); if (!c.length) { status('Split text failed.', true); return; } totalChunks = c.length; chunksReceived = 0; status(`Req synth ${c.length} chunks...`); prepareTextDisplay(t, c); E.gen.disabled = true; E.load.disabled = true; buffers = new Array(c.length).fill(null); audioBlobs = new Array(c.length).fill(null); const cR = k => ({ input: { text: k }, voice: { languageCode: E.voice.selectedOptions[0].dataset.l, name: E.voice.value }, audioConfig: { audioEncoding: 'MP3', pitch: +E.pit.value, speakingRate: +E.rat.value } }); const cP = c.map(async (k, i) => { try { log(`Gen chunk ${i + 1}/${c.length}`); const r = await fetchJSON(SY, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + accessToken }, body: JSON.stringify(cR(k)) }); if (!r.audioContent) throw new Error(`No audio chunk ${i + 1}`); log(`Recvd chunk ${i + 1}`); const aD = atob(r.audioContent); const aB = new Uint8Array(aD.length); for (let j = 0; j < aD.length; j++) aB[j] = aD.charCodeAt(j); const bl = new Blob([aB], { type: 'audio/mp3' }); audioBlobs[i] = bl; log(`Blob chunk ${i + 1}: ${(bl.size / 1024).toFixed(1)} KB`); const bC = aB.buffer.slice(0); try { const aBuf = await decodeBuffer(bC); buffers[i] = aBuf; updateWordTimings(i, aBuf.duration); loadedDuration = chunksData.reduce((s, d) => s + (d.ld ? d.dur : 0), 0); totalDuration = loadedDuration; log(`Chunk ${i + 1} decoded: ${aBuf.duration.toFixed(2)}s. Loaded: ${loadedDuration.toFixed(2)}s`); chunksReceived++; status(`Proc ${chunksReceived}/${totalChunks}...`); if (i === 0 && !playing && !paused) { E.play.disabled = false; E.stop.disabled = false; startPlayback(0, 0, 0); } else if (!playing && !paused && buffers[0]) { E.play.disabled = false; E.stop.disabled = false; } return i; } catch (dE) { log(`Decode err ${i + 1}`, dE, 'error'); if (chunksData[i]) chunksData[i].ld = false; throw new Error(`Decode fail ${i + 1}: ${dE.message}`); } } catch (e) { log(`Proc err chunk ${i + 1}`, e, 'error'); if (String(e.message).includes('401') || String(e.message).includes('403')) { accessToken = null; E.authStatus.textContent = '‚ö†Ô∏è Re-auth'; E.load.disabled = true; status(`Chunk ${i + 1} fail: Auth error. Sign in.`, true); } else status(`Chunk ${i + 1} fail: ${e.message}`, true); if (chunksData[i]) chunksData[i].ld = false; return null; } }); await Promise.allSettled(cP); loadingComplete = true; totalDuration = chunksData.reduce((s, d) => s + (d.ld ? d.dur : 0), 0); log(`All chunks settled. Final dur: ${totalDuration.toFixed(2)}s`); updateUI(playing ? ctx.currentTime - startTime : pausedAt); const sC = chunksData.filter(d => d?.ld).length; if (sC === totalChunks) { log('All OK', { totalDuration }); status(`Synth OK. Dur: ${fmt(totalDuration)}`, false); E.download.disabled = false; } else { log(`Some fail (${sC}/${totalChunks})`, null, 'warn'); status(`Done ${sC}/${totalChunks}. Dur: ${fmt(totalDuration)}`, sC > 0); if (sC > 0) E.download.disabled = false; } } catch (e) { log('Gen fail', e, 'error'); status(`Gen failed: ${e.message}`, true); } finally { E.gen.disabled = false; E.load.disabled = !accessToken; if (!playing && !paused) { E.play.disabled = !(totalDuration > 0); E.pause.disabled = true; E.stop.disabled = true; } } };
    E.methodBtns.forEach(b => b.onclick = () => { E.methodBtns.forEach(x => x.classList.remove('active')); b.classList.add('active'); method = b.dataset.m; log(`Split method: ${method}`); });
    ['pit', 'rat', 'chk'].forEach(id => E[id].oninput = e => { const s = E[`${id}Val`]; if (s) s.textContent = id === 'rat' ? parseFloat(e.target.value).toFixed(2) : e.target.value; });
    E.volume.oninput = () => { if (gainNode) { gainNode.gain.value = E.volume.value; log(`Volume: ${E.volume.value}`); } };
    E.prog.onclick = e => { if (!totalDuration) return; const r = E.prog.getBoundingClientRect(); const rat = Math.max(0, Math.min(1, (e.clientX - r.left) / r.width)); const t = rat * (loadingComplete ? totalDuration : loadedDuration); log(`Prog click ${rat.toFixed(2)} (${t.toFixed(2)}s)`); seekToTime(t); };
    E.play.onclick = () => { if (paused) resumePlayback(); else startPlayback(0, 0, 0); };
    E.pause.onclick = pausePlayback; E.stop.onclick = () => stopPlayback(false); E.download.onclick = createDownloadLink;
    document.onkeydown = (e) => { if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return; let h = false; switch (e.code) { case 'Space': if (playing && !E.pause.disabled) E.pause.click(); else if ((paused || (loadingComplete && totalDuration > 0)) && !E.play.disabled) E.play.click(); h = true; break; case 'Escape': if ((playing || paused) && !E.stop.disabled) E.stop.click(); h = true; break; case 'KeyG': if (!E.gen.disabled) E.gen.click(); h = true; break; case 'KeyD': if (!E.download.disabled) E.download.click(); h = true; break; case 'KeyT': E.themeToggle.click(); h = true; break; case 'ArrowLeft': if (playing || paused) { seekToTime((playing ? ctx.currentTime - startTime : pausedAt) - 5); h = true; } break; case 'ArrowRight': if (playing || paused) { seekToTime((playing ? ctx.currentTime - startTime : pausedAt) + 5); h = true; } break; case 'ArrowUp': E.volume.value = Math.min(1, parseFloat(E.volume.value) + 0.1); if (gainNode) gainNode.gain.value = E.volume.value; h = true; break; case 'ArrowDown': E.volume.value = Math.max(0, parseFloat(E.volume.value) - 0.1); if (gainNode) gainNode.gain.value = E.volume.value; h = true; break; } if (h) e.preventDefault(); };

    // --- Initial Log & UI State ---
    console.log("[DOM] Adding initial log and setting initial UI state."); // <<< NEW LOG
    log('DOM Ready. Waiting for OAuth libs init...');
    E.play.disabled = true; E.pause.disabled = true; E.stop.disabled = true; E.download.disabled = true; E.gen.disabled = true; E.voice.disabled = true; E.load.disabled = true; E.signInBtn.disabled = true; // Ensure it starts disabled

    // Initial check immediately on DOM ready
    // This might enable the button if libs loaded *very* fast, before DOM ready
    checkEnableSignIn();

}); // End DOMContentLoaded
</script>
</body>
</html>
