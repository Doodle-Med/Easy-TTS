<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<style>
:root{
  --c1:#4285f4;
  --c2:#34a853;
  --c3:#ea4335;
  --c4:#fbbc04;
  --bg:#fdfdfd;
  --fg:#202124;
  --bd:#dadce0;
  --r:10px;
  --shadow: 0 4px 12px rgba(0,0,0,.05);
  --hover: rgba(66,133,244,0.1);
}
*{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif}
body{background:var(--bg);color:var(--fg);padding:1rem;max-width:1200px;margin:auto}
h1{font-size:clamp(1.7rem,2.5vw,3rem);text-align:center;margin-bottom:1rem;background:linear-gradient(90deg,var(--c1),var(--c2),var(--c4),var(--c3));-webkit-background-clip:text;color:transparent;font-weight:800}
.grid{display:grid;gap:1rem}.two{grid-template-columns:1fr 1fr}@media(max-width:800px){.two{grid-template-columns:1fr}}
.card{background:#fff;border:1px solid var(--bd);border-radius:var(--r);box-shadow:var(--shadow);padding:1.2rem;position:relative}
.card-header{display:flex;align-items:center;margin-bottom:1rem;}
.card-header h2{flex:1;font-size:1.3rem;}
label{font-weight:600;margin:.6rem 0 .3rem;display:block}
input,select,textarea,button{width:100%;padding:.55rem .65rem;border:1px solid var(--bd);border-radius:6px;font-size:1rem;margin-bottom:.8rem}
input:focus,select:focus,textarea:focus{border-color:var(--c1);outline:none}
textarea{resize:vertical;min-height:140px}
button{cursor:pointer;background:var(--c1);color:#fff;border:none;font-weight:600}
button:not(:disabled):hover{background:#3367d6}
button:disabled{background:var(--bd);cursor:not-allowed;}
.small-btn{width:auto}
.toggle{display:flex;gap:.5rem;margin:.6rem 0}.toggle button{flex:1;background:var(--bg);border:1px solid var(--bd);color:var(--fg)}
.toggle .active{background:var(--c2);color:#fff;border-color:var(--c2)}
.status{min-height:1.4em;font-size:.95rem;margin:.5rem 0}.error{color:var(--c3);font-weight:700}
.success{color:var(--c2);font-weight:700}
.bar{height:12px;background:var(--bd);border-radius:6px;overflow:hidden;cursor:pointer;margin:.8rem 0}
.fill{height:100%;background:linear-gradient(90deg,var(--c1),var(--c2));width:0}
.audio{display:flex;align-items:center;gap:.6rem}
.audio button{width:44px;border-radius:50%;aspect-ratio:1/1;font-size:1.1rem;display:grid;place-items:center}
.time{font-family:monospace;margin-left:auto}
.text-box{background:#fff;border:1px solid var(--bd);border-radius:var(--r);padding:1rem;max-height:340px;overflow:auto;line-height:1.6}
.word{display:inline-block;cursor:pointer;border-radius:3px;padding:1px 2px}
.word:hover{background:#f1f3f4}
.word.active{background:rgba(66,133,244,.25);color:var(--c1);font-weight:700}
.word.loading{background:#f1f3f4;cursor:wait;opacity:0.6}
.spinner{display:inline-block;width:14px;height:14px;border:2px solid rgba(0,0,0,0.1);border-radius:50%;border-top-color:var(--c1);animation:spin 0.8s linear infinite;margin-right:5px}
@keyframes spin{to{transform:rotate(360deg)}}
.controls{display:flex;align-items:center;gap:0.5rem;margin-bottom:0.8rem;}
.controls button{margin-bottom:0;}
.volume-control{display:flex;align-items:center;gap:0.5rem;flex:1;}
.volume-control input{margin:0;}
.download-btn{margin-left:auto;}
.debug-panel{font-family:monospace;font-size:12px;background:#f5f5f5;border:1px solid #ddd;border-radius:var(--r);padding:0.8rem;margin-top:1rem;max-height:200px;overflow:auto;}
.debug-entry{margin-bottom:0.3rem;border-bottom:1px solid #eee;padding-bottom:0.3rem;}
.debug-time{color:#666;font-size:10px;}
.debug-msg{font-weight:bold;}
.debug-data{color:#333;margin-left:1rem;}
.toggle-debug{text-align:center;font-size:0.9rem;margin-top:0.5rem;cursor:pointer;color:var(--c1);}
.hidden{display:none}
</style>
</head>
<body>
<h1>Google Cloud TTS Playground</h1>
  <!-- Paste right after <h1>Google Cloud TTS Playground</h1> -->
<button id="themeToggle" class="small-btn" style="position:absolute;top:1rem;right:1rem;">üåì Toggle Theme</button>
<div class="grid two">
  <div class="card">
    <div class="card-header">
      <h2>üéõÔ∏è Configuration</h2>
    </div>
    <label>API Key</label>
    <div class="controls">
      <input id="k" type="password" placeholder="Enter your Google Cloud API Key"/>
      <button class="small-btn" id="ld">Load Voices</button>
    </div>
    <div id="loading" class="status hidden"><span class="spinner"></span>Loading voices...</div>
    
    <label>Text</label>
    <textarea id="txt" placeholder="Type or paste text here..."></textarea>
    
    <label>Voice</label>
    <select id="v" disabled></select>
    
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:.8rem">
      <div>
        <label>Pitch <span id="pitVal">0</span></label>
        <input id="pit" type="range" min="-20" max="20" value="0"/>
      </div>
      <div>
        <label>Rate <span id="ratVal">1</span></label>
        <input id="rat" type="range" min="0.25" max="4" step="0.05" value="1"/>
      </div>
    </div>
    
    <label>Chunk Size <span id="chkVal">1000</span></label>
    <input id="chk" type="range" min="500" max="4500" step="500" value="1000"/>
    
    <div class="toggle" id="method">
      <button data-m="sentence">Sentence</button>
      <button data-m="paragraph" class="active">Paragraph</button>
      <button data-m="exact">Exact</button>
    </div>
    
    <button id="gen" disabled>üé§ Generate & Play</button>
    <div id="stat" class="status"></div>
  </div>
  
  <div class="card">
    <div class="card-header">
      <h2>üîä Playback</h2>
    </div>
    <div id="text" class="text-box"><p style="opacity:.6;text-align:center;">Words will appear here...</p></div>
    <!-- Paste right after <div id="text" class="text-box">...</div> -->
<canvas id="visualizer" width="100%" height="100"></canvas>
    <div class="bar" id="prog">
      <div class="fill" id="fill"></div>
    </div>
    
    <div class="audio">
      <button class="small-btn" id="play" disabled title="Play">‚ñ∂</button>
      <button class="small-btn" id="pause" disabled title="Pause">‚è∏</button>
      <button class="small-btn" id="stop" disabled title="Stop">‚èπ</button>
      
      <div class="volume-control">
        <span>üîä</span>
        <input type="range" id="volume" min="0" max="1" step="0.1" value="1"/>
      </div>
      
      <span class="time" id="time">00:00 / 00:00</span>
    </div>
    
    <button id="download" class="download-btn" disabled>üíæ Download Audio</button>
    <div class="toggle-debug" id="toggleDebug">Show Debug Info</div>
    <div id="debugPanel" class="debug-panel hidden"></div>
  </div>
</div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  // API endpoints & DOM elements
  const VO = 'https://texttospeech.googleapis.com/v1/voices';
  const SY = 'https://texttospeech.googleapis.com/v1/text:synthesize';
  const Q = id => document.getElementById(id);
  const E = {
    key: Q('k'),
    load: Q('ld'),
    loading: Q('loading'),
    txt: Q('txt'),
    voice: Q('v'),
    pit: Q('pit'),
    rat: Q('rat'),
    pitVal: Q('pitVal'),
    ratVal: Q('ratVal'),
    chk: Q('chk'),
    chkVal: Q('chkVal'),
    gen: Q('gen'),
    stat: Q('stat'),
    methodBtns: [...Q('method').children],
    textBox: Q('text'),
    play: Q('play'),
    pause: Q('pause'),
    stop: Q('stop'),
    volume: Q('volume'),
    download: Q('download'),
    prog: Q('prog'),
    fill: Q('fill'),
    time: Q('time'),
    toggleDebug: Q('toggleDebug'),
    debugPanel: Q('debugPanel')
  };
  
  // Debug logging
  let debugEnabled = localStorage.getItem('debugEnabled') === 'true';
  const maxDebugEntries = 100;
  let debugEntries = [];
  
  // Toggle debug panel
  E.toggleDebug.addEventListener('click', () => {
    debugEnabled = !debugEnabled;
    localStorage.setItem('debugEnabled', debugEnabled);
    E.debugPanel.classList.toggle('hidden', !debugEnabled);
    E.toggleDebug.textContent = debugEnabled ? 'Hide Debug Info' : 'Show Debug Info';
    
    if (debugEnabled) {
      updateDebugPanel();
    }
  });
  
  // Initialize debug panel state
  if (debugEnabled) {
    E.debugPanel.classList.remove('hidden');
    E.toggleDebug.textContent = 'Hide Debug Info';
  }

  // Enhanced logging with debug panel support
  const log = (message, data = null, level = 'info') => {
    const timestamp = new Date().toISOString();
    const entry = {
      timestamp,
      message,
      data,
      level
    };
    
    // Add to debug entries
    debugEntries.unshift(entry);
    if (debugEntries.length > maxDebugEntries) {
      debugEntries.pop();
    }
    
    // Output to console with appropriate level
    switch(level) {
      case 'error':
        console.error(`[${timestamp}] ${message}`, data);
        break;
      case 'warn':
        console.warn(`[${timestamp}] ${message}`, data);
        break;
      default:
        console.log(`[${timestamp}] ${message}`, data);
    }
    
    // Update debug panel if visible
    if (debugEnabled) {
      updateDebugPanel();
    }
  };
  
  // Update debug panel with latest entries
  const updateDebugPanel = () => {
    E.debugPanel.innerHTML = debugEntries.map(entry => {
      const timeStr = new Date(entry.timestamp).toLocaleTimeString();
      let dataStr = '';
      
      if (entry.data !== null) {
        try {
          if (typeof entry.data === 'object') {
            dataStr = `<div class="debug-data">${JSON.stringify(entry.data)}</div>`;
          } else {
            dataStr = `<div class="debug-data">${entry.data}</div>`;
          }
        } catch (e) {
          dataStr = `<div class="debug-data">[Complex Object]</div>`;
        }
      }
      
      return `
        <div class="debug-entry ${entry.level}">
          <span class="debug-time">${timeStr}</span>
          <span class="debug-msg">${entry.message}</span>
          ${dataStr}
        </div>
      `;
    }).join('');
  };

  // App state
  let API = localStorage.getItem('apiKey') || '';
  let ctx;
  let gainNode;
  let voices = [];
  let buffers = [];
  let audioBlobs = []; // Store audio as blobs for download
  let audioSources = []; // Track all audio sources
  let wordElements = []; // Store word elements for efficient lookup
  let wordOffsets = []; // Track which chunk each word belongs to
  let totalDuration = 0; // Total final duration
  let loadedDuration = 0; // Duration of loaded chunks so far
  let startTime = 0; // When playback started
  let pausedAt = 0; // Where we paused
  let playbackId = 0; // Used to cancel stale playback
  let playing = false;
  let paused = false;
  let method = 'paragraph';
  let currentWordIndex = -1;
  let loadingComplete = false;
  let chunksReceived = 0;
  let totalChunks = 0;
  let visualizer;  
  // Initialize API key if saved
  if (API) {
    E.key.value = API;
    // Auto-load voices if API key is saved
    log('API key found in localStorage, auto-loading voices');
    setTimeout(() => E.load.click(), 500);
  }

  // Utilities
  const fmt = s => `${String(Math.floor(s/60)).padStart(2, '0')}:${String(Math.floor(s%60)).padStart(2, '0')}`;
  
  const status = (m, isError) => {
    E.stat.textContent = m;
    E.stat.className = 'status' + (isError ? ' error' : isError === false ? ' success' : '');
    log(m, null, isError ? 'error' : 'info');
  };
  
  // JSON fetch helper with error handling
  const fetchJSON = async (url, opts) => {
    try {
      log(`Fetching ${url}`, opts);
      const r = await fetch(url, opts);
      
      if (!r.ok) {
        let m = `HTTP ${r.status}`;
        try {
          const errorData = await r.json();
          m = errorData.error?.message || m;
          log('API Error', errorData, 'error');
        } catch (e) {
          log('Failed to parse error response', e, 'error');
        }
        throw new Error(m);
      }
      
      const data = await r.json();
      log(`Fetch completed successfully`, { url });
      return data;
    } catch (e) {
      log('Fetch error', e, 'error');
      throw e;
    }
  };

  // UI event binding
  ['pit', 'rat', 'chk'].forEach(id => {
    E[id].addEventListener('input', e => {
      const span = E[`${id}Val`];
      if (span) {
        const val = id === 'rat' ? parseFloat(e.target.value).toFixed(2) : e.target.value;
        span.textContent = val;
      }
    });
  });
  
  // Initialize volume control
  E.volume.addEventListener('input', () => {
    if (gainNode) {
      gainNode.gain.value = E.volume.value;
      log(`Volume changed to ${E.volume.value}`);
    }
  });

  // Load voices from Google TTS API
  E.load.onclick = async () => {
    API = E.key.value.trim();
    if (!API) return status('API key required', true);
    
    // Save API key to localStorage
    localStorage.setItem('apiKey', API);
    
    E.loading.classList.remove('hidden');
    E.load.disabled = true;
    status('Loading voices...');
    
    try {
      log(`Requesting voices from ${VO}`);
      const d = await fetchJSON(`${VO}?key=${API}`);
      voices = d.voices || [];
      
      if (!voices.length) throw new Error('No voices returned');
      
      log(`Loaded ${voices.length} voices`);
      
      // Group voices by language
      const langMap = new Map();
      voices.forEach(v => {
        v.languageCodes.forEach(code => {
          let name;
          try {
            name = new Intl.DisplayNames(['en'], { type: 'language' }).of(code);
          } catch (e) {
            name = code;
          }
          
          if (!langMap.has(code)) {
            langMap.set(code, { name, voices: [] });
          }
          langMap.get(code).voices.push(v);
        });
      });
      
      // Sort languages by name
      const sortedLangs = [...langMap.entries()]
        .sort((a, b) => a[1].name.localeCompare(b[1].name));
      
      // Group options by language
      const html = sortedLangs.map(([code, { name, voices }]) => {
        const options = voices
          .sort((a, b) => a.name.localeCompare(b.name))
          .map(v => {
            const isNeural = v.name.includes('Neural') || v.name.includes('Wavenet');
            return `<option value="${v.name}" data-l="${code}">${v.name} ${isNeural ? '(Neural)' : ''}</option>`;
          })
          .join('');
        
        return `<optgroup label="${name}">${options}</optgroup>`;
      }).join('');
      
      E.voice.innerHTML = html;
      E.voice.disabled = false;
      E.gen.disabled = false;
      
      status('Voices loaded successfully', false);
    } catch (e) {
      status(`Failed to load voices: ${e.message}`, true);
    } finally {
      E.loading.classList.add('hidden');
      E.load.disabled = false;
    }
  };

  // Configure chunk splitting method
  E.methodBtns.forEach(b => b.onclick = () => {
    E.methodBtns.forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    method = b.dataset.m;
    log(`Splitting method changed to: ${method}`);
  });

  // Split text into chunks based on selected method
  const splitText = t => {
    const m = +E.chk.value;
    log(`Splitting text (${t.length} chars) with method: ${method}, chunk size: ${m}`);
    
    if (t.length <= m) return [t];
    
    if (method === 'exact') {
      const a = [];
      for (let i = 0; i < t.length; i += m) {
        a.push(t.slice(i, i + m));
      }
      log(`Split into ${a.length} chunks using exact method`);
      return a;
    }
    
    const re = method === 'paragraph' ? /\n\s*\n/ : /([.!?]+["']?\s+)/;
    const bits = t.split(re).filter(Boolean);
    log(`Split text into ${bits.length} initial segments`);
    
    const out = [];
    let cur = '';
    
    for (const p of bits) {
      if ((cur + p).length > m) {
        if (cur.trim()) out.push(cur.trim());
        cur = '';
        
        if (p.length > m) {
          let q = p;
          while (q.length > m) {
            out.push(q.slice(0, m));
            q = q.slice(m);
          }
          cur = q;
        } else {
          cur = p;
        }
      } else {
        cur += p;
      }
    }
    
    if (cur.trim()) out.push(cur.trim());
    
    log(`Final chunks: ${out.length}`, {
      chunkSizes: out.map(c => c.length)
    });
    
    return out;
  };

  // Decode audio buffer
  const decodeBuffer = a => {
    log(`Decoding audio buffer of size ${a.byteLength}`);
    return new Promise((res, rej) => {
      try {
        ctx.decodeAudioData(a, 
          (buffer) => {
            log(`Audio buffer decoded successfully: ${buffer.duration.toFixed(2)}s`);
            res(buffer);
          },
          (err) => {
            log(`Error decoding audio buffer`, err, 'error');
            rej(err);
          }
        );
      } catch (e) {
        log(`Exception in decodeBuffer`, e, 'error');
        rej(e);
      }
    });
  };

  // Prepare text display with clickable words
  const prepareTextDisplay = (text, chunks) => {
    log(`Preparing text display with ${text.length} chars and ${chunks.length} chunks`);
    
    E.textBox.innerHTML = '';
    wordElements = [];
    wordOffsets = [];
    
    let globalWordIndex = 0;
    let currentChunk = 0;
    let chunkStart = 0;
    let chunkEnd = chunks[0]?.length || 0;
    
    // Split text into words and spaces
    text.split(/(\s+)/).forEach((part, i) => {
      if (part.trim()) {
        // This is a word (not whitespace)
        const span = document.createElement('span');
        span.textContent = part;
        span.className = 'word loading'; // Start as loading
        span.dataset.index = globalWordIndex;
        
        // Track which chunk this word belongs to
        while (i > chunkEnd && currentChunk < chunks.length - 1) {
          currentChunk++;
          chunkStart = chunkEnd;
          chunkEnd += chunks[currentChunk].length;
        }
        
        span.dataset.chunk = currentChunk;
        wordOffsets[globalWordIndex] = currentChunk;
        
        span.addEventListener('click', () => {
          if (span.classList.contains('loading')) {
            status('That part is still loading...');
            return;
          }
          seekToWord(globalWordIndex);
        });
        
        wordElements.push(span);
        E.textBox.appendChild(span);
        globalWordIndex++;
      } else {
        // This is whitespace
        E.textBox.appendChild(document.createTextNode(part));
      }
    });
    
    log(`Text display prepared with ${globalWordIndex} words`);
  };

  // Find which chunk and offset to play for a given time
  const locateTimePosition = (time) => {
    log(`Locating position for time ${time.toFixed(2)}s`);
    
    let currentTime = 0;
    
    // Handle case where time is beyond loaded duration
    if (time >= loadedDuration) {
      const lastIndex = buffers.findLastIndex(b => b);
      log(`Time ${time.toFixed(2)}s is beyond loaded duration ${loadedDuration.toFixed(2)}s, using last loaded chunk`);
      return { chunk: lastIndex === -1 ? 0 : lastIndex, offset: 0 };
    }
    
    // Find the chunk that contains this time
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      if (!buffer) continue; // Skip unloaded chunks
      
      const duration = buffer.duration;
      if (time < currentTime + duration) {
        const offset = time - currentTime;
        log(`Found time ${time.toFixed(2)}s in chunk ${i} at offset ${offset.toFixed(2)}s`);
        return { chunk: i, offset: offset };
      }
      
      currentTime += duration;
    }
    
    // Fallback to beginning of last loaded chunk
    const lastLoaded = buffers.findLastIndex(b => b);
    log(`Could not locate time ${time.toFixed(2)}s in any chunk, using last loaded chunk`);
    return { chunk: lastLoaded === -1 ? 0 : lastLoaded, offset: 0 };
  };

  // Seek to a specific time
  const seekToTime = (time) => {
    if (!buffers.some(b => b)) {
      log(`Cannot seek: no buffers loaded`);
      return;
    }
    
    // Ensure time is within valid range
    time = Math.max(0, Math.min(time, loadedDuration));
    
    log(`Seeking to ${time.toFixed(2)}s`);
    
    // Find the chunk this time belongs to
    const { chunk, offset } = locateTimePosition(time);
    
    // Cancel any current playback
    cancelPlayback();
    
    if (paused) {
      // Just update the paused position
      pausedAt = time;
      updateUI(time);
      log(`Updated paused position to ${time.toFixed(2)}s`);
    } else {
      // Start playback from this position
      startPlayback(chunk, offset, time);
    }
  };

  // Seek to a specific word
  const seekToWord = (wordIndex) => {
    if (!buffers.some(b => b) || wordIndex < 0 || wordIndex >= wordElements.length) {
      log(`Cannot seek to word ${wordIndex}: invalid conditions`, {
        hasBuffers: buffers.some(b => b),
        wordCount: wordElements.length
      });
      return;
    }
    
    // Make sure the corresponding chunk is loaded
    const chunkIndex = wordOffsets[wordIndex];
    if (chunkIndex === undefined || !buffers[chunkIndex]) {
      log(`Word ${wordIndex} is in chunk ${chunkIndex} which is not loaded yet`);
      return;
    }
    
    // Calculate time based on word position in text
    const time = estimateTimeForWord(wordIndex);
    log(`Seeking to word ${wordIndex} at estimated time ${time.toFixed(2)}s`);
    
    seekToTime(time);
  };

  // Estimate time for a word
  const estimateTimeForWord = (wordIndex) => {
    if (wordIndex < 0 || wordIndex >= wordElements.length) return 0;
    
    // Get the chunk this word belongs to
    const chunkIndex = wordOffsets[wordIndex];
    if (chunkIndex === undefined) return 0;
    
    // Find all words in this chunk
    const wordsInChunk = wordElements.filter((_, i) => wordOffsets[i] === chunkIndex);
    if (!wordsInChunk.length) return 0;
    
    // Get base time (start of chunk)
    let baseTime = 0;
    for (let i = 0; i < chunkIndex; i++) {
      if (buffers[i]) baseTime += buffers[i].duration;
    }
    
    // If we don't have this chunk loaded, estimate based on overall
    if (!buffers[chunkIndex]) {
      return baseTime;
    }
    
    // Find position of word within its chunk
    const chunkWords = wordElements.filter((_, i) => wordOffsets[i] === chunkIndex);
    const indexInChunk = chunkWords.findIndex(el => +el.dataset.index === wordIndex);
    
    if (indexInChunk === -1) return baseTime;
    
    // Calculate offset within chunk
    const chunkDuration = buffers[chunkIndex].duration;
    const offsetInChunk = chunkDuration * (indexInChunk / chunkWords.length);
    
    return baseTime + offsetInChunk;
  };

  // Initialize audio context
  const initAudioContext = () => {
    if (!ctx) {
      log('Initializing AudioContext');
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create master gain node for volume control
      gainNode = ctx.createGain();
      gainNode.gain.value = E.volume.value;
      gainNode.connect(ctx.destination);
visualizer = new VoiceVisualizer('visualizer', ctx, {
  mode: 'waveform',
  color: 'gradient'
});
      log('AudioContext initialized', {
        sampleRate: ctx.sampleRate
      });
    }
    
    return ctx.resume(); // Ensure it's running
  };

  // Start playback from a specific position
  const startPlayback = (chunkIndex, offset = 0, absoluteTime = 0) => {
    // Ensure audio context is initialized
    initAudioContext();
    
    // Generate a new playback ID to track this session
    playbackId = Date.now();
    const currentPlayback = playbackId;
    
    // Update state
    playing = true;
    paused = false;
    startTime = ctx.currentTime - absoluteTime;
    
    log(`Starting playback: chunk ${chunkIndex}, offset ${offset.toFixed(2)}s, abs time ${absoluteTime.toFixed(2)}s`);
    
    // Update UI
    E.play.disabled = true;
    E.pause.disabled = false;
    E.stop.disabled = false;
    
    // Start playing from the specified position
    playChunk(chunkIndex, offset, currentPlayback);
    
    // Start the update loop
    requestAnimationFrame(updatePlayback);
  };

  // Play a specific chunk
  const playChunk = (index, offset = 0, id) => {
    // Check if this playback request is still valid
    if (id !== playbackId) {
      log(`Ignoring stale playback request: ${id} vs ${playbackId}`);
      return;
    }
    
    // Check if we've reached the end
    if (index >= buffers.length) {
      log('Reached end of audio');
      stopPlayback();
      return;
    }
    
    // Get the audio buffer for this chunk
    const buffer = buffers[index];
    
    // If the buffer isn't loaded yet, wait and retry
    if (!buffer) {
      log(`Chunk ${index} not loaded yet, waiting...`);
      setTimeout(() => {
        if (playing && id === playbackId) {
          playChunk(index, offset, id);
        }
      }, 300);
      return;
    }
    
    log(`Playing chunk ${index} from offset ${offset.toFixed(2)}s`);
    
    // Create a new audio source
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(visualizer.analyser);
visualizer.analyser.connect(gainNode);
    
    // When this chunk ends, play the next one
    source.onended = () => {
      // Only proceed if this is still the active playback
      if (playing && id === playbackId) {
        log(`Chunk ${index} ended, playing next chunk`);
        playChunk(index + 1, 0, id);
      }
    };
    
    // Save the source so we can stop it later
    audioSources[index] = source;
    
    // Start playback with the specified offset
    source.start(0, Math.min(offset, buffer.duration));
  };

  // Cancel any current playback
  const cancelPlayback = () => {
    log('Canceling current playback');
    
    // Stop all audio sources
    audioSources.forEach((source, i) => {
      if (source) {
        log(`Stopping audio source for chunk ${i}`);
        source.onended = null; // Remove callback
        try { source.stop(); } catch (e) {
          log(`Error stopping source for chunk ${i}`, e, 'warn');
        }
      }
    });
    
    // Reset sources array
    audioSources = [];
    
    // Generate a new playback ID to invalidate any pending callbacks
    playbackId = Date.now();
  };

  // Pause playback
  const pausePlayback = () => {
    if (!playing) {
      log('Cannot pause: not playing');
      return;
    }
    
    pausedAt = ctx.currentTime - startTime;
    playing = false;
    paused = true;
    
    log(`Pausing at ${pausedAt.toFixed(2)}s`);
    
    // Cancel current playback
    cancelPlayback();
    
    // Update UI
    E.play.disabled = false;
    E.pause.disabled = true;
    
    status(`Paused at ${fmt(pausedAt)}`);
  };

  // Resume playback
  const resumePlayback = () => {
    if (!paused) {
      log('Cannot resume: not paused');
      return;
    }
    
    log(`Resuming from ${pausedAt.toFixed(2)}s`);
    
    // Find the chunk to resume from
    const { chunk, offset } = locateTimePosition(pausedAt);
    
    // Start playback from the pause position
    startPlayback(chunk, offset, pausedAt);
  };

  // Stop playback
  const stopPlayback = (silent = false) => {
    // Cancel current playback
    cancelPlayback();
    
    // Reset state
    playing = false;
    paused = false;
    pausedAt = 0;
    
    // Clear word highlighting
    if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
      wordElements[currentWordIndex].classList.remove('active');
    }
    currentWordIndex = -1;
    
    if (!silent) {
      log('Playback stopped');
      
      // Reset UI
      E.fill.style.width = '0%';
      E.time.textContent = `00:00 / ${fmt(totalDuration)}`;
      E.play.disabled = false;
      E.pause.disabled = true;
      E.stop.disabled = false;
    }
  };

  // Update playback UI (called on each animation frame)
  const updatePlayback = () => {
    if (!playing) return;
    
    // Calculate current time
    const currentTime = ctx.currentTime - startTime;
    
    // Check if we've reached the end
    if (currentTime >= totalDuration) {
      log(`Reached end of playback (${currentTime.toFixed(2)}s >= ${totalDuration.toFixed(2)}s)`);
      stopPlayback();
      return;
    }
    
    // Update UI
    updateUI(currentTime);
    
    // Continue updates
    requestAnimationFrame(updatePlayback);
  };

  // Update UI with current time
  const updateUI = (time) => {
    // Update progress bar
    const percentage = totalDuration > 0 ? (time / totalDuration) * 100 : 0;
    E.fill.style.width = `${percentage}%`;
    
    // Update time display
    E.time.textContent = `${fmt(time)} / ${fmt(totalDuration)}`;
    
    // Update word highlighting
    updateWordHighlight(time);
  };

  // Update word highlighting
  const updateWordHighlight = (time) => {
    // Find the appropriate word based on time
    let wordIndex = -1;
    
    // First try to find the word by chunk
    const { chunk } = locateTimePosition(time);
    const chunkWords = wordElements.filter((_, i) => wordOffsets[i] === chunk);
    
    if (chunkWords.length) {
      // Find position within chunk
      let chunkStart = 0;
      for (let i = 0; i < chunk; i++) {
        if (buffers[i]) chunkStart += buffers[i].duration;
      }
      
      const chunkDuration = buffers[chunk]?.duration || 0;
      const relativePosition = (time - chunkStart) / chunkDuration;
      const indexInChunk = Math.floor(relativePosition * chunkWords.length);
      
      // Map back to global index
      if (indexInChunk >= 0 && indexInChunk < chunkWords.length) {
        wordIndex = parseInt(chunkWords[indexInChunk].dataset.index);
      }
    }
    
    // If no word found by chunk or it's invalid, use fallback
    if (wordIndex < 0 || wordIndex >= wordElements.length) {
      // Fallback to simple ratio
      wordIndex = Math.floor((time / totalDuration) * wordElements.length);
      wordIndex = Math.min(wordIndex, wordElements.length - 1);
    }
    
    // Only update if it's a different word
    if (wordIndex !== currentWordIndex) {
      // Remove highlight from previous word
      if (currentWordIndex >= 0 && currentWordIndex < wordElements.length) {
        wordElements[currentWordIndex].classList.remove('active');
      }
      
      // Add highlight to current word
      if (wordIndex >= 0 && wordIndex < wordElements.length) {
        const wordEl = wordElements[wordIndex];
        wordEl.classList.add('active');
        
        // Ensure word is visible
        const container = E.textBox;
        const wordTop = wordEl.offsetTop;
        const wordBottom = wordTop + wordEl.offsetHeight;
        const containerTop = container.scrollTop;
        const containerBottom = containerTop + container.offsetHeight;
        
        if (wordTop < containerTop + 30) {
          container.scrollTop = wordTop - 30;
        } else if (wordBottom > containerBottom - 30) {
          container.scrollTop = wordBottom - container.offsetHeight + 30;
        }
      }
      
      currentWordIndex = wordIndex;
    }
  };

  // Progress bar click handler
  E.prog.onclick = e => {
    if (!totalDuration) return;
    
    const rect = E.prog.getBoundingClientRect();
    const ratio = (e.clientX - rect.left) / rect.width;
    const targetTime = ratio * totalDuration;
    
    log(`Progress bar clicked at ${ratio.toFixed(2)} (${targetTime.toFixed(2)}s)`);
    seekToTime(targetTime);
  };

  // Playback control buttons
  E.play.onclick = () => {
    if (paused) {
      resumePlayback();
    } else {
      startPlayback(0, 0, 0);
    }
  };
  
  E.pause.onclick = pausePlayback;
  E.stop.onclick = stopPlayback;

  // Create download link
  const createDownloadLink = () => {
    log('Creating download link');
    
    if (!audioBlobs.length) {
      log('No audio blobs to download', null, 'error');
      status('No audio available for download', true);
      return;
    }
    
    try {
      log(`Creating combined blob from ${audioBlobs.length} chunks`);
      
      // Create a single blob from all chunks
      const combinedBlob = new Blob(audioBlobs, { type: 'audio/mp3' });
      
      log(`Combined blob created: ${(combinedBlob.size / 1024 / 1024).toFixed(2)} MB`);
      
      // Create download link
      const url = URL.createObjectURL(combinedBlob);
      
      // Trigger download
      const a = document.createElement('a');
      const fileName = 'speech_' + new Date().toISOString().replace(/[:.]/g, '-') + '.mp3';
      a.href = url;
      a.download = fileName;
      
      log(`Triggering download: ${fileName}`);
      document.body.appendChild(a);
      a.click();
      
      // Clean up
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log('Download cleanup complete');
      }, 100);
      
      status('Download started', false);
    } catch (err) {
      log('Error creating download', err, 'error');
      status('Failed to create download: ' + err.message, true);
    }
  };
  
  // Download button
  E.download.onclick = createDownloadLink;

  // Generate speech
  E.gen.onclick = async () => {
    if (!API) return status('Load voices first', true);
    if (!E.voice.value) return status('Select a voice', true);
    
    try {
      // Initialize audio context and ensure it's running
      await initAudioContext();
      
      const text = E.txt.value.trim();
      if (!text) return status('Enter text', true);
      
      // Reset state
      stopPlayback();
      buffers = [];
      audioBlobs = [];
      audioSources = [];
      totalDuration = 0;
      loadedDuration = 0;
      loadingComplete = false;
      E.download.disabled = true;
      
      // Split text into chunks
      const chunks = splitText(text);
      if (!chunks.length) return status('Failed to split text', true);
      
      totalChunks = chunks.length;
      chunksReceived = 0;
      
      // Prepare UI
      status(`Processing ${chunks.length} chunk(s)...`);
      prepareTextDisplay(text, chunks);
      E.gen.disabled = true;
      
      // Initialize buffers array
      buffers = new Array(chunks.length);
      audioBlobs = new Array(chunks.length);
      
      // Create request body template
      const createRequest = chunk => ({
        input: { text: chunk },
        voice: {
          languageCode: E.voice.selectedOptions[0].dataset.l,
          name: E.voice.value
        },
        audioConfig: {
          audioEncoding: 'MP3',
          pitch: +E.pit.value,
          speakingRate: +E.rat.value
        }
      });
      
      // Process chunks
      // Start processing all chunks in parallel
      const chunkPromises = chunks.map(async (chunk, index) => {
        try {
          log(`Generating chunk ${index + 1}/${chunks.length} (${chunk.length} chars)`);
          
          const response = await fetchJSON(`${SY}?key=${API}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(createRequest(chunk))
          });
          
          if (!response.audioContent) {
            throw new Error(`No audio content in response for chunk ${index + 1}`);
          }
          
          log(`Received audio content for chunk ${index + 1}`);
          
          // Convert base64 to ArrayBuffer
          const audioData = atob(response.audioContent);
          const arrayBuffer = new Uint8Array(audioData.length);
          for (let i = 0; i < audioData.length; i++) {
            arrayBuffer[i] = audioData.charCodeAt(i);
          }
          
          // Store the audio blob for downloading (prevent detached buffer issue)
          const blob = new Blob([arrayBuffer], { type: 'audio/mp3' });
          audioBlobs[index] = blob;
          
          log(`Created blob for chunk ${index + 1}: ${(blob.size / 1024).toFixed(2)} KB`);
          
          // Create a copy of the array buffer for decoding
          // This is important to prevent the "detached ArrayBuffer" issue
          const bufferCopy = arrayBuffer.slice(0).buffer;
          
          // Decode audio
          try {
            const audioBuffer = await decodeBuffer(bufferCopy);
            
            // Store the decoded buffer
            buffers[index] = audioBuffer;
            
            // Update durations
            loadedDuration += audioBuffer.duration;
            totalDuration += audioBuffer.duration;
            
            log(`Chunk ${index + 1} decoded: ${audioBuffer.duration.toFixed(2)}s`);
            
            // Update word elements to show they're ready
            wordElements.forEach(word => {
              if (+word.dataset.chunk === index) {
                word.classList.remove('loading');
              }
            });
            
            // Update progress
            chunksReceived++;
            
            // Autoplay first chunk when it's ready
            if (index === 0 && !playing && !paused) {
              startPlayback(0, 0, 0);
            }
            
            return index;
          } catch (decodeError) {
            log(`Error decoding chunk ${index + 1}`, decodeError, 'error');
            throw new Error(`Failed to decode audio for chunk ${index + 1}: ${decodeError.message}`);
          }
        } catch (error) {
          log(`Error processing chunk ${index + 1}`, error, 'error');
          status(`Chunk ${index + 1} failed: ${error.message}`, true);
          return null;
        }
      });
      
      // Wait for all chunks to complete
      await Promise.all(chunkPromises);
      
      // Check if all chunks were processed successfully
      const success = chunksReceived === totalChunks;
      loadingComplete = true;
      
      if (success) {
        log('All chunks processed successfully', { totalDuration });
        status(`All chunks processed. Duration: ${fmt(totalDuration)}`, false);
        E.download.disabled = false;
      } else {
        log(`Some chunks failed (${chunksReceived}/${totalChunks})`, null, 'warn');
        status(`Completed ${chunksReceived}/${totalChunks} chunks`, true);
      }
    } catch (e) {
      log('Generation failed', e, 'error');
      status(`Generation failed: ${e.message}`, true);
    } finally {
      E.gen.disabled = false;
    }
  };
  
  // Add keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Don't trigger shortcuts when typing in inputs
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // Space - Play/Pause
    if (e.code === 'Space') {
      e.preventDefault();
      if (playing) E.pause.click();
      else if (paused || loadingComplete) E.play.click();
    }
    
    // Escape - Stop
    if (e.code === 'Escape' && (playing || paused)) {
      e.preventDefault();
      E.stop.click();
    }
    
    // G - Generate
    if (e.code === 'KeyG' && !E.gen.disabled) {
      e.preventDefault();
      E.gen.click();
    }
    
    // D - Download
    if (e.code === 'KeyD' && !E.download.disabled) {
      e.preventDefault();
      E.download.click();
    }
  });
  
  // Log initial state
  log('Application initialized', {
    version: '1.1.0',
    date: '2025-04-25',
    debugEnabled: debugEnabled
  });
});
</script>
    <!-- Paste right before the closing </body> tag -->
<script src="voice-visualizer.js"></script>
</body>

</html>
