<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<!-- These script tags use global callbacks that need to be defined before loading -->
<script>
// Define global callbacks that Google's libraries will call when loaded
function gapiLoaded() {
  console.log("[Auth] GAPI loaded, initializing client...");
  gapi.load('client', initializeGapiClient);
}

async function initializeGapiClient() {
  try {
    await gapi.client.init({
      discoveryDocs: ['https://texttospeech.googleapis.com/$discovery/rest?version=v1']
    });
    console.log("[Auth] GAPI client initialized");
    window.gapiInited = true;
    maybeEnableButtons();
  } catch (err) {
    console.error("[Auth] GAPI client initialization failed: " + err.message);
    document.getElementById('authStatus').textContent = '‚ùå API initialization failed';
  }
}

function gisLoaded() {
  console.log("[Auth] GIS loaded, initializing token client...");
  window.tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: '879295177554-m3j1d2pks6lukl3h9cl92r953ef2jd4e.apps.googleusercontent.com',
    scope: 'https://www.googleapis.com/auth/cloud-platform',
    callback: handleTokenResponse
  });
  window.gisInited = true;
  console.log("[Auth] GIS token client initialized");
  maybeEnableButtons();
}

function handleTokenResponse(resp) {
  if (resp.error) {
    console.error('[Auth] OAuth error:', resp.error);
    document.getElementById('authStatus').textContent = '‚ùå Sign-in failed';
    document.getElementById('ld').disabled = true;
    window.accessToken = null;
    return;
  }
  
  window.accessToken = resp.access_token;
  console.log('[Auth] OAuth successful, access token obtained');
  document.getElementById('authStatus').textContent = '‚úÖ Signed in';
  document.getElementById('ld').disabled = false;
  
  // Auto-load voices if possible
  document.getElementById('ld').click();
}

function maybeEnableButtons() {
  if (window.gapiInited && window.gisInited) {
    document.getElementById('signInBtn').disabled = false;
    console.log("[Auth] Both GAPI and GIS ready, sign-in button enabled");
  }
}
</script>
<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js" async defer></script>
<script src="voice-visualizer.js"></script>
<style>
:root {
  /* Light theme (default) */
  --c1:#4285f4;
  --c2:#34a853;
  --c3:#ea4335;
  --c4:#fbbc04;
  --bg:#f8f9fa;
  --card-bg:#ffffff;
  --fg:#202124;
  --bd:#dadce0;
  --hover:#f1f3f4;
  --r:10px;
  --shadow: 0 4px 12px rgba(0,0,0,.05);
  --code-bg: #f5f5f5;
  --hover-bg: rgba(66,133,244,0.1);
  
  /* Animation and transition properties */
  --transition: all 0.3s ease;
}

/* Dark theme variables */
[data-theme="dark"] {
  --c1:#8ab4f8;
  --c2:#81c995;
  --c3:#f28b82;
  --c4:#fdd663;
  --bg:#202124;
  --card-bg:#292a2d;
  --fg:#e8eaed;
  --bd:#5f6368;
  --hover:#3c3c3c;
  --shadow: 0 4px 12px rgba(0,0,0,.2);
  --code-bg: #2d2d30;
  --hover-bg: rgba(138, 180, 248, 0.15);
}

* {
  box-sizing:border-box;
  margin:0;
  padding:0;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
  transition: var(--transition);
}

body {
  background:var(--bg);
  color:var(--fg);
  padding:1rem;
  max-width:1200px;
  margin:auto;
}

h1 {
  font-size:clamp(1.7rem,2.5vw,3rem);
  text-align:center;
  margin-bottom:1rem;
  background:linear-gradient(90deg,var(--c1),var(--c2),var(--c4),var(--c3));
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;
  font-weight:800;
}

.grid {
  display:grid;
  gap:1rem;
}

.two {
  grid-template-columns:1fr 1fr;
}

@media(max-width:800px) {
  .two {
    grid-template-columns:1fr;
  }
}

.card {
  background:var(--card-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  box-shadow:var(--shadow);
  padding:1.2rem;
  position:relative;
}

.card:hover {
  box-shadow: 0 6px 16px rgba(0,0,0, var(--shadow-opacity, 0.08));
}

.card-header {
  display:flex;
  align-items:center;
  margin-bottom:1rem;
}

.card-header h2 {
  flex:1;
  font-size:1.3rem;
}

label {
  font-weight:600;
  margin:.6rem 0 .3rem;
  display:block;
}

input, select, textarea, button {
  width:100%;
  padding:.55rem .65rem;
  border:1px solid var(--bd);
  border-radius:6px;
  font-size:1rem;
  margin-bottom:.8rem;
  background: var(--card-bg);
  color: var(--fg);
}

input:focus, select:focus, textarea:focus {
  border-color:var(--c1);
  outline:none;
  box-shadow: 0 0 0 3px rgba(66,133,244,0.2);
}

textarea {
  resize:vertical;
  min-height:140px;
}

button {
  cursor:pointer;
  background:var(--c1);
  color:#fff;
  border:none;
  font-weight:600;
}

button:not(:disabled):hover {
  background:#3367d6;
  transform: translateY(-1px);
}

button:disabled {
  background:var(--bd);
  cursor:not-allowed;
  opacity: 0.7;
}

.small-btn {
  width:auto;
}

.toggle {
  display:flex;
  gap:.5rem;
  margin:.6rem 0;
}

.toggle button {
  flex:1;
  background:var(--bg);
  border:1px solid var(--bd);
  color:var(--fg);
}

.toggle .active {
  background:var(--c2);
  color:#fff;
  border-color:var(--c2);
}

.status {
  min-height:1.4em;
  font-size:.95rem;
  margin:.5rem 0;
  padding: .5rem;
  border-radius: 6px;
}

.error {
  color:var(--c3);
  background: rgba(234,67,53,0.1);
  font-weight:700;
}

.success {
  color:var(--c2);
  background: rgba(52,168,83,0.1);
  font-weight:700;
}

.bar {
  height:12px;
  background:var(--bd);
  border-radius:6px;
  overflow:hidden;
  cursor:pointer;
  margin:.8rem 0;
}

.fill {
  height:100%;
  background:linear-gradient(90deg,var(--c1),var(--c2));
  width:0;
  transition: width 0.1s linear;
}

.audio {
  display:flex;
  align-items:center;
  gap:.6rem;
}

.audio button {
  width:44px;
  border-radius:50%;
  aspect-ratio:1/1;
  font-size:1.1rem;
  display:grid;
  place-items:center;
}

.time {
  font-family:monospace;
  margin-left:auto;
}

.text-box {
  background:var(--card-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  padding:1rem;
  max-height:340px;
  overflow:auto;
  line-height:1.6;
}

.word {
  display:inline-block;
  cursor:pointer;
  border-radius:3px;
  padding:1px 2px;
  transition: all 0.15s ease;
}

.word:hover {
  background:var(--hover-bg);
}

.word.active {
  background:rgba(66,133,244,.25);
  color:var(--c1);
  font-weight:700;
}

.word.loading {
  position: relative;
  background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
  background-size: 200% 100%;
  animation: shine 1.5s infinite;
  cursor:wait;
  opacity:0.6;
}

@keyframes shine {
  to { background-position: -200% 0; }
}

.spinner {
  display:inline-block;
  width:14px;
  height:14px;
  border:2px solid rgba(66,133,244,0.2);
  border-radius:50%;
  border-top-color:var(--c1);
  animation:spin 0.8s linear infinite;
  margin-right:5px;
}

@keyframes spin {
  to {transform:rotate(360deg)}
}

.controls {
  display:flex;
  align-items:center;
  gap:0.5rem;
  margin-bottom:0.8rem;
}

.controls button {
  margin-bottom:0;
}

.controls #authStatus {
    flex-grow: 1;
    font-style: italic;
    opacity: 0.8;
    font-size: 0.9rem;
}

.volume-control {
  display:flex;
  align-items:center;
  gap:0.5rem;
  flex:1;
}

.volume-control input {
  margin:0;
}

.download-btn {
  margin-left:auto;
}

.debug-panel {
  font-family:monospace;
  font-size:12px;
  background:var(--code-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  padding:0.8rem;
  margin-top:1rem;
  max-height:200px;
  overflow:auto;
}

.debug-entry {
  margin-bottom:0.3rem;
  border-bottom:1px solid var(--bd);
  padding-bottom:0.3rem;
}

.debug-time {
  color:var(--fg);
  opacity: 0.6;
  font-size:10px;
}

.debug-msg {
  font-weight:bold;
}

.debug-data {
  color:var(--fg);
  opacity: 0.8;
  margin-left:1rem;
}

.toggle-debug {
  text-align:center;
  font-size:0.9rem;
  margin-top:0.5rem;
  cursor:pointer;
  color:var(--c1);
}

.theme-toggle {
  position: absolute;
  top: 1rem;
  right: 1rem;
  z-index: 100;
}

.theme-toggle button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  background: transparent;
  color: var(--fg);
  border: 1px solid var(--bd);
}

.theme-toggle button:hover {
  background: var(--hover-bg);
  transform: none;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--bd);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--c1);
}

.hidden {
  display:none !important;
}
</style>
</head>
<body>
<h1>Google Cloud TTS Playground</h1>
<div class="theme-toggle">
  <button id="themeToggle" title="Toggle Theme">üåì</button>
</div>
<div class="grid two">
  <div class="card">
    <div class="card-header">
      <h2>üéõÔ∏è Configuration</h2>
    </div>
    
    <label>Authentication</label>
    <div class="controls">
      <button class="small-btn" id="signInBtn" disabled>Sign in with Google</button>
      <span id="authStatus">Not signed in</span>
    </div>
    
    <button class="small-btn" id="ld" disabled>Load Voices</button>
    <div id="loading" class="status hidden"><span class="spinner"></span>Loading voices...</div>
    
    <label>Text</label>
    <textarea id="txt" placeholder="Type or paste text here..."></textarea>
    
    <label>Voice</label>
    <select id="v" disabled></select>
    
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:.8rem">
      <div>
        <label>Pitch <span id="pitVal">0</span></label>
        <input id="pit" type="range" min="-20" max="20" value="0"/>
      </div>
      <div>
        <label>Rate <span id="ratVal">1</span></label>
        <input id="rat" type="range" min="0.25" max="4" step="0.05" value="1"/>
      </div>
    </div>
    
    <label>Chunk Size <span id="chkVal">1000</span></label>
    <input id="chk" type="range" min="500" max="4500" step="500" value="1000"/>
    
    <div class="toggle" id="method">
      <button data-m="sentence">Sentence</button>
      <button data-m="paragraph" class="active">Paragraph</button>
      <button data-m="exact">Exact</button>
    </div>
    
    <button id="gen" disabled>üé§ Generate & Play</button>
    <div id="stat" class="status"></div>
  </div>
  
  <div class="card">
    <div class="card-header">
      <h2>üîä Playback</h2>
    </div>
    <div id="text" class="text-box"><p style="opacity:.6;text-align:center;">Words will appear here...</p></div>
    <canvas id="visualizer" height="80" style="width:100%;margin:0.8rem 0;border:1px solid var(--bd);border-radius:var(--r);"></canvas>
    <div class="bar" id="prog">
      <div class="fill" id="fill"></div>
    </div>
    
    <div class="audio">
      <button class="small-btn" id="play" disabled title="Play">‚ñ∂</button>
      <button class="small-btn" id="pause" disabled title="Pause">‚è∏</button>
      <button class="small-btn" id="stop" disabled title="Stop">‚èπ</button>
      
      <div class="volume-control">
        <span>üîä</span>
        <input type="range" id="volume" min="0" max="1" step="0.1" value="1"/>
      </div>
      
      <span class="time" id="time">00:00 / 00:00</span>
    </div>
    
    <button id="download" class="download-btn" disabled>üíæ Download Audio</button>
    <div class="toggle-debug" id="toggleDebug">Show Debug Info</div>
    <div id="debugPanel" class="debug-panel hidden"></div>
  </div>
</div>

<script>
// Initialize global variables that will be used by the OAuth functions
window.tokenClient = null;
window.accessToken = null;
window.gapiInited = false;
window.gisInited = false;

// Main application code
window.addEventListener('DOMContentLoaded', () => {
  // API endpoints & DOM elements
  const VO = 'https://texttospeech.googleapis.com/v1/voices';
  const SY = 'https://texttospeech.googleapis.com/v1/text:synthesize';
  const Q = id => document.getElementById(id);
  const E = {
    signInBtn: Q('signInBtn'),
    authStatus: Q('authStatus'),
    load: Q('ld'),
    loading: Q('loading'),
    txt: Q('txt'),
    voice: Q('v'),
    pit: Q('pit'),
    rat: Q('rat'),
    pitVal: Q('pitVal'),
    ratVal: Q('ratVal'),
    chk: Q('chk'),
    chkVal: Q('chkVal'),
    gen: Q('gen'),
    stat: Q('stat'),
    methodBtns: [...Q('method').children],
    textBox: Q('text'),
    play: Q('play'),
    pause: Q('pause'),
    stop: Q('stop'),
    volume: Q('volume'),
    download: Q('download'),
    prog: Q('prog'),
    fill: Q('fill'),
    time: Q('time'),
    toggleDebug: Q('toggleDebug'),
    debugPanel: Q('debugPanel'),
    themeToggle: Q('themeToggle')
  };

  // Set up sign-in button click handler
  E.signInBtn.addEventListener('click', () => {
    if (!window.tokenClient) {
      console.log('Token client not initialized yet');
      E.authStatus.textContent = '‚åõ Please wait...';
      return;
    }
    
    console.log('Requesting access token...');
    window.tokenClient.requestAccessToken({ prompt: window.accessToken ? '' : 'consent' });
  });
  
  // Debug logging
  let debugEnabled = localStorage.getItem('debugEnabled') === 'true';
  const maxDebugEntries = 100;
  let debugEntries = [];
  
  // Theme toggle
  let isDarkMode = localStorage.getItem('darkMode') === 'true';
  if (isDarkMode) {
    document.documentElement.setAttribute('data-theme', 'dark');
  }
  
  E.themeToggle.addEventListener('click', () => {
    isDarkMode = !isDarkMode;
    document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
    localStorage.setItem('darkMode', isDarkMode);
    log(`Theme changed to ${isDarkMode ? 'dark' : 'light'} mode`);
  });
  
  // Toggle debug panel
  E.toggleDebug.addEventListener('click', () => {
    debugEnabled = !debugEnabled;
    localStorage.setItem('debugEnabled', debugEnabled);
    E.debugPanel.classList.toggle('hidden', !debugEnabled);
    E.toggleDebug.textContent = debugEnabled ? 'Hide Debug Info' : 'Show Debug Info';
    
    if (debugEnabled) {
      updateDebugPanel();
    }
  });
  
  // Initialize debug panel state
  if (debugEnabled) {
    E.debugPanel.classList.remove('hidden');
    E.toggleDebug.textContent = 'Hide Debug Info';
  }

  // Enhanced logging with debug panel support
  const log = (message, data = null, level = 'info') => {
    const timestamp = new Date().toISOString();
    const entry = {
      timestamp,
      message,
      data,
      level
    };
    
    // Add to debug entries
    debugEntries.unshift(entry);
    if (debugEntries.length > maxDebugEntries) {
      debugEntries.pop();
    }
    
    // Output to console with appropriate level
    switch(level) {
      case 'error':
        console.error(`[${timestamp}] ${message}`, data);
        break;
      case 'warn':
        console.warn(`[${timestamp}] ${message}`, data);
        break;
      default:
        console.log(`[${timestamp}] ${message}`, data);
    }
    
    // Update debug panel if visible
    if (debugEnabled) {
      updateDebugPanel();
    }
  };
  
  // Update debug panel with latest entries
  const updateDebugPanel = () => {
    E.debugPanel.innerHTML = debugEntries.map(entry => {
      const timeStr = new Date(entry.timestamp).toLocaleTimeString();
      let dataStr = '';
      
      if (entry.data !== null) {
        try {
          if (typeof entry.data === 'object') {
            dataStr = `<div class="debug-data">${JSON.stringify(entry.data)}</div>`;
          } else {
            dataStr = `<div class="debug-data">${entry.data}</div>`;
          }
        } catch (e) {
          dataStr = `<div class="debug-data">[Complex Object]</div>`;
        }
      }
      
      return `
        <div class="debug-entry ${entry.level}">
          <span class="debug-time">${timeStr}</span>
          <span class="debug-msg">${entry.message}</span>
          ${dataStr}
        </div>
      `;
    }).join('');
  };

  // App state
  let ctx;
  let gainNode;
  let voices = [];
  let buffers = [];
  let audioBlobs = []; // Store audio as blobs for download
  let audioSources = []; // Track all audio sources
  let wordElements = []; // Store word elements for efficient lookup
  let wordTimings = []; // More accurate timing data for words
  let totalDuration = 0;
  let loadedDuration = 0;
  let startTime = 0;
  let pausedAt = 0;
  let playbackId = 0;
  let playing = false;
  let paused = false;
  let method = 'paragraph';
  let currentWordIndex = -1;
  let loadingComplete = false;
  let chunksReceived = 0;
  let totalChunks = 0;
  let chunksData = [];
  let visualizer;
  
  // Utilities
  const fmt = s => `${String(Math.floor(s/60)).padStart(2, '0')}:${String(Math.floor(s%60)).padStart(2, '0')}`;
  
  const status = (m, isError) => {
    E.stat.textContent = m;
    E.stat.className = 'status' + (isError ? ' error' : isError === false ? ' success' : '');
    log(m, null, isError ? 'error' : 'info');
  };
  
  // JSON fetch helper with error handling
  const fetchJSON = async (url, opts) => {
    try {
      log(`Fetching ${url}`, opts);
      const r = await fetch(url, opts);
      
      if (!r.ok) {
        let m = `HTTP ${r.status}`;
        try {
          const errorData = await r.json();
          m = errorData.error?.message || m;
          log('API Error', errorData, 'error');
        } catch (e) {
          log('Failed to parse error response', e, 'error');
        }
        throw new Error(m);
      }
      
      const data = await r.json();
      log(`Fetch completed successfully`, { url });
      return data;
    } catch (e) {
      log('Fetch error', e, 'error');
      throw e;
    }
  };

  // UI event binding
  ['pit', 'rat', 'chk'].forEach(id => {
    E[id].addEventListener('input', e => {
      const span = E[`${id}Val`];
      if (span) {
        const val = id === 'rat' ? parseFloat(e.target.value).toFixed(2) : e.target.value;
        span.textContent = val;
      }
    });
  });
  
  // Initialize volume control
  E.volume.addEventListener('input', () => {
    if (gainNode) {
      gainNode.gain.value = E.volume.value;
      log(`Volume changed to ${E.volume.value}`);
    }
  });

  // Load Voices handler
  E.load.onclick = async () => {
    // Check if user is signed in (accessToken is present)
    if (!window.accessToken) {
      status('Please sign in first to load voices.', true);
      if (window.tokenClient) {
         window.tokenClient.requestAccessToken({ prompt: 'consent' });
      } else {
         log('Token client not ready for sign-in prompt.', null, 'warn');
         status('Authentication system not ready.', true);
      }
      return;
    }
    
    E.loading.classList.remove('hidden');
    E.load.disabled = true;
    E.gen.disabled = true; // Also disable generate while loading voices
    status('Loading voices...');
    
    try {
      log(`Requesting voices from ${VO} using OAuth token.`);
      // fetch voices with Bearer token
      const d = await fetchJSON(VO, {
          method: 'GET',
          headers: { 'Authorization': 'Bearer ' + window.accessToken }
      });
      voices = d.voices || [];
      
      if (!voices.length) throw new Error('No voices returned from API');
      
      log(`Loaded ${voices.length} voices`);
      
      const langMap = new Map();
      voices.forEach(v => {
        v.languageCodes.forEach(code => {
          let name;
          try {
            name = new Intl.DisplayNames(['en'], { type: 'language' }).of(code);
          } catch (e) {
            name = code;
          }
          
          if (!langMap.has(code)) {
            langMap.set(code, { name, voices: [] });
          }
          langMap.get(code).voices.push(v);
        });
      });
      
      const sortedLangs = [...langMap.entries()]
        .sort((a, b) => a[1].name.localeCompare(b[1].name));
        
      const html = sortedLangs.map(([code, { name, voices }]) => {
        const options = voices
          .sort((a, b) => a.name.localeCompare(b.name))
          .map(v => {
            const isNeural = v.name.includes('Neural') || v.name.includes('Wavenet');
            return `<option value="${v.name}" data-l="${code}">${v.name} ${isNeural ? '(Neural)' : ''}</option>`;
          })
          .join('');
        
        return `<optgroup label="${name}">${options}</optgroup>`;
      }).join('');
      
      E.voice.innerHTML = html;
      E.voice.disabled = false;
      E.gen.disabled = false; // Enable generate button now
      
      status('Voices loaded successfully', false);
    } catch (e) {
      status(`Failed to load voices: ${e.message}`, true);
      log('Error loading voices', e, 'error');
       // If the error might be auth-related (e.g., 401, 403), maybe reset token
       if (e.message.includes('401') || e.message.includes('403')) {
            window.accessToken = null; // Clear potentially invalid token
            E.authStatus.textContent = '‚ö†Ô∏è Re-authentication needed';
            E.load.disabled = true; // Disable load again
       }
    } finally {
      E.loading.classList.add('hidden');
      // Keep E.load enabled if accessToken exists, disable otherwise
      E.load.disabled = !window.accessToken;
    }
  };

  // Configure chunk splitting method
  E.methodBtns.forEach(b => b.onclick = () => {
    E.methodBtns.forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    method = b.dataset.m;
    log(`Splitting method changed to: ${method}`);
  });

  // Split text into chunks based on selected method
  const splitText = t => {
    const m = +E.chk.value;
    log(`Splitting text (${t.length} chars) with method: ${method}, chunk size: ${m}`);
    
    if (t.length <= m) return [t];
    
    if (method === 'exact') {
      const a = [];
      for (let i = 0; i < t.length; i += m) {
        a.push(t.slice(i, i + m));
      }
      log(`Split into ${a.length} chunks using exact method`);
      return a;
    }
    
    const re = method === 'paragraph' ? /\n\s*\n/ : /([.!?]+["']?\s+)/;
    const bits = t.split(re).filter(Boolean);
    log(`Split text into ${bits.length} initial segments`);
    
    const out = [];
    let cur = '';
    
    for (const p of bits) {
      if ((cur + p).length > m) {
        if (cur.trim()) out.push(cur.trim());
        cur = '';
        
        if (p.length > m) {
          let q = p;
          while (q.length > m) {
            out.push(q.slice(0, m));
            q = q.slice(m);
          }
          cur = q;
        } else {
          cur = p;
        }
      } else {
        cur += p;
      }
    }
    
    if (cur.trim()) out.push(cur.trim());
    
    log(`Final chunks: ${out.length}`, {
      chunkSizes: out.map(c => c.length)
    });
    
    return out;
  };

  // Rest of the code remains the same, just make sure to use window.accessToken instead of accessToken
  // for the remaining functions that need it
  
  // For example, in the generate speech function:
  E.gen.onclick = async () => {
    // Check for access token instead of API key
    if (!window.accessToken) {
         status('Please sign in first to generate speech.', true);
         if (window.tokenClient) {
            window.tokenClient.requestAccessToken({ prompt: 'consent' });
         } else {
            log('Token client not ready for sign-in prompt.', null, 'warn');
            status('Authentication system not ready.', true);
         }
         return;
    }
    
    // ... rest of the function ...
    
    // When sending API requests:
    const response = await fetchJSON(SY, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + window.accessToken
      },
      body: JSON.stringify(createRequest(chunk))
    });
    
    // ... rest of the function ...
  };
  
  // Log initial state
  log('Application initialized - OAuth Version', {
    version: '1.3.0-oauth',
    date: '2025-04-26',
    user: 'Doodle-Med',
    debugEnabled: debugEnabled
  });

  // Initial UI state after setup
  E.play.disabled = true;
  E.pause.disabled = true;
  E.stop.disabled = true;
  E.download.disabled = true;
  E.gen.disabled = true;
  E.voice.disabled = true;
});
</script>
</body>
</html>
