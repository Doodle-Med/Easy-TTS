<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Google Cloud TTS Playground</title>
<style>
:root {
  /* Light theme (default) */
  --c1: #4285f4;
  --c2: #34a853;
  --c3: #ea4335;
  --c4: #fbbc04;
  --bg: #f8f9fa;
  --card-bg: #ffffff;
  --fg: #202124;
  --bd: #dadce0;
  --hover: #f1f3f4;
  --r: 10px;
  --shadow: 0 4px 12px rgba(0,0,0,.05);
  --code-bg: #f5f5f5;
  --hover-bg: rgba(66,133,244,0.1);

  /* Animation and transition properties */
  --transition: all 0.3s ease;
}

/* Dark theme variables */
[data-theme="dark"] {
  --c1: #8ab4f8;
  --c2: #81c995;
  --c3: #f28b82;
  --c4: #fdd663;
  --bg: #202124;
  --card-bg: #292a2d;
  --fg: #e8eaed;
  --bd: #5f6368;
  --hover: #3c3c3c;
  --shadow: 0 4px 12px rgba(0,0,0,.2);
  --code-bg: #2d2d30;
  --hover-bg: rgba(138, 180, 248, 0.15);
}

* {
  box-sizing:border-box;
  margin:0;
  padding:0;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
  transition: var(--transition);
}

body {
  background:var(--bg);
  color:var(--fg);
  padding:1rem;
  max-width:1200px;
  margin:auto;
}

h1 {
  font-size:clamp(1.7rem,2.5vw,3rem);
  text-align:center;
  margin-bottom:1rem;
  background:linear-gradient(90deg,var(--c1),var(--c2),var(--c4),var(--c3));
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;
  font-weight:800;
}

.grid {
  display:grid;
  gap:1rem;
}

.two {
  grid-template-columns:1fr 1fr;
}

@media(max-width:800px) {
  .two {
    grid-template-columns:1fr;
  }
}

.card {
  background:var(--card-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  box-shadow:var(--shadow);
  padding:1.2rem;
  position:relative;
  transition: box-shadow 0.3s ease; /* Added transition specifically for shadow */
}

.card:hover {
  /* Fixed: Removed rule using undefined --shadow-opacity. */
  box-shadow: 0 6px 16px rgba(0,0,0, 0.08); /* Example hover shadow */
}

.card-header {
  display:flex;
  align-items:center;
  margin-bottom:1rem;
}

.card-header h2 {
  flex:1;
  font-size:1.3rem;
}

label {
  font-weight:600;
  margin:.6rem 0 .3rem;
  display:block;
}

input, select, textarea, button {
  width:100%;
  padding:.55rem .65rem;
  border:1px solid var(--bd);
  border-radius:6px;
  font-size:1rem;
  margin-bottom:.8rem;
  background: var(--card-bg);
  color: var(--fg);
  transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Added transitions */
}

input:focus, select:focus, textarea:focus {
  border-color:var(--c1);
  outline:none;
  box-shadow: 0 0 0 3px rgba(66,133,244,0.2);
}

textarea {
  resize:vertical;
  min-height:140px;
}

button {
  cursor:pointer;
  background:var(--c1);
  color:#fff;
  border:none;
  font-weight:600;
  transition: background-color 0.2s ease, transform 0.2s ease, opacity 0.2s ease; /* Added transitions */
}

button:not(:disabled):hover {
  background:#3367d6;
  transform: translateY(-1px);
}

button:disabled {
  background:var(--bd);
  cursor:not-allowed;
  opacity: 0.7;
}

.small-btn {
  width:auto;
}

.toggle {
  display:flex;
  gap:.5rem;
  margin:.6rem 0;
}

.toggle button {
  flex:1;
  background:var(--bg);
  border:1px solid var(--bd);
  color:var(--fg);
}

.toggle .active {
  background:var(--c2);
  color:#fff;
  border-color:var(--c2);
}

.status {
  min-height:1.4em;
  font-size:.95rem;
  margin:.5rem 0;
  padding: .5rem;
  border-radius: 6px;
  transition: background-color 0.3s ease, color 0.3s ease; /* Added transition */
}

.error {
  color:var(--c3);
  background: rgba(234,67,53,0.1);
  font-weight:700;
}

.success {
  color:var(--c2);
  background: rgba(52,168,83,0.1);
  font-weight:700;
}

.bar {
  height:12px;
  background:var(--bd);
  border-radius:6px;
  overflow:hidden;
  cursor:pointer;
  margin:.8rem 0;
}

.fill {
  height:100%;
  background:linear-gradient(90deg,var(--c1),var(--c2));
  width:0;
  transition: width 0.1s linear;
}

.audio {
  display:flex;
  align-items:center;
  gap:.6rem;
}

.audio button {
  width:44px;
  border-radius:50%;
  aspect-ratio:1/1;
  font-size:1.1rem;
  display:grid;
  place-items:center;
}

.time {
  font-family:monospace;
  margin-left:auto;
}

.text-box {
  background:var(--card-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  padding:1rem;
  max-height:340px;
  overflow:auto;
  line-height:1.6;
}

.word {
  display:inline-block;
  cursor:pointer;
  border-radius:3px;
  padding:1px 2px;
  transition: all 0.15s ease;
  position: relative; /* Needed for tooltip */
}

.word:hover {
  background:var(--hover-bg);
}

.word.active {
  background:rgba(66,133,244,.25);
  color:var(--c1);
  font-weight:700;
}

.word.loading {
  position: relative;
  background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.1), rgba(0,0,0,0.05));
  background-size: 200% 100%;
  animation: shine 1.5s infinite;
  cursor:wait;
  opacity:0.6;
}

/* Word timing tooltip (shown when debug enabled) */
.word[data-time]:hover::after {
  content: attr(data-time) "s";
  position: absolute;
  bottom: 100%; /* Position above the word */
  left: 50%;
  transform: translateX(-50%) translateY(-3px); /* Center and add small gap */
  background: var(--c1);
  color: white;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 10px;
  white-space: nowrap;
  z-index: 10;
  pointer-events: none; /* Prevent tooltip from interfering */
}


@keyframes shine {
  to { background-position: -200% 0; }
}

.spinner {
  display:inline-block;
  width:14px;
  height:14px;
  border:2px solid rgba(66,133,244,0.2);
  border-radius:50%;
  border-top-color:var(--c1);
  animation:spin 0.8s linear infinite;
  margin-right:5px;
  vertical-align: middle; /* Align better */
}

@keyframes spin {
  to {transform:rotate(360deg)}
}

.controls {
  display:flex;
  align-items:center;
  gap:0.5rem;
  margin-bottom:0.8rem;
}

.controls button {
  margin-bottom:0;
}

.volume-control {
  display:flex;
  align-items:center;
  gap:0.5rem;
  flex:1;
}

.volume-control input {
  margin:0;
}

.download-btn {
  margin-left:auto;
}

.debug-panel {
  font-family:monospace;
  font-size:12px;
  background:var(--code-bg);
  border:1px solid var(--bd);
  border-radius:var(--r);
  padding:0.8rem;
  margin-top:1rem;
  max-height:200px;
  overflow:auto;
}

.debug-entry {
  margin-bottom:0.3rem;
  border-bottom:1px solid var(--bd);
  padding-bottom:0.3rem;
}

.debug-entry:last-child {
    border-bottom: none;
}

.debug-time {
  color:var(--fg);
  opacity: 0.6;
  font-size:10px;
  margin-right: 0.5em;
}

.debug-msg {
  font-weight:bold;
}

.debug-data {
  color:var(--fg);
  opacity: 0.8;
  margin-left:1rem;
  display: block;
  word-break: break-all;
}

.toggle-debug {
  text-align:center;
  font-size:0.9rem;
  margin-top:0.5rem;
  cursor:pointer;
  color:var(--c1);
}

.theme-toggle {
  position: absolute;
  top: 1rem;
  right: 1rem;
  z-index: 100;
}

.theme-toggle button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  background: transparent;
  color: var(--fg);
  border: 1px solid var(--bd);
}

.theme-toggle button:hover {
  background: var(--hover-bg);
  transform: none; /* Override default button hover */
}

/* Timeline visualization (Added back) */
.timeline {
  height: 40px;
  width: 100%;
  background: var(--bg);
  border: 1px solid var(--bd);
  border-radius: var(--r);
  margin: 10px 0;
  position: relative;
  overflow: hidden;
  cursor: pointer;
}

.chunk-marker {
  position: absolute;
  height: 100%;
  background: rgba(66,133,244,0.3);
  border-right: 1px solid var(--c1);
  font-size: 10px;
  display: flex;
  align-items: center;
  padding: 0 4px;
  white-space: nowrap;
  overflow: hidden;
  color: var(--c1);
  pointer-events: none;
}

.chunk-marker:nth-child(odd) {
  background: rgba(52,168,83,0.2);
  border-right: 1px solid var(--c2);
  color: var(--c2);
}

.word-dot {
  position: absolute;
  width: 4px;
  height: 4px;
  background: var(--c1);
  border-radius: 50%;
  bottom: 2px;
  transform: translateX(-2px);
  pointer-events: none;
}

.word-dot.active {
  width: 8px;
  height: 8px;
  background: var(--c3);
  bottom: 0;
  transform: translateX(-4px);
}

.playhead {
  position: absolute;
  width: 2px;
  height: 100%;
  background: var(--c3);
  top: 0;
  left: 0;
  z-index: 5;
  pointer-events: none;
}


/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--bd);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--c1);
}

.hidden {
  display:none !important;
}
</style>
</head>
<body>
<h1>Google Cloud TTS Playground</h1>
<div class="theme-toggle">
  <button id="themeToggle" title="Toggle Theme (T)">üåì</button>
</div>
<div class="grid two">
  <div class="card">
    <div class="card-header">
      <h2>üéõÔ∏è Configuration</h2>
    </div>
    <label for="k">API Key</label>
    <div class="controls">
      <input id="k" type="password" placeholder="Enter your Google Cloud API Key"/>
      <button class="small-btn" id="ld">Load Voices</button>
    </div>
    <div id="loading" class="status hidden"><span class="spinner"></span>Loading voices...</div>

    <label for="txt">Text</label>
    <textarea id="txt" placeholder="Type or paste text here..."></textarea>

    <label for="v">Voice</label>
    <select id="v" disabled></select>

    <div class="grid" style="grid-template-columns:1fr 1fr;gap:.8rem">
      <div>
        <label for="pit">Pitch <span id="pitVal">0</span></label>
        <input id="pit" type="range" min="-20" max="20" value="0"/>
      </div>
      <div>
        <label for="rat">Rate <span id="ratVal">1</span></label>
        <input id="rat" type="range" min="0.25" max="4" step="0.05" value="1"/>
      </div>
    </div>

    <label for="chk">Chunk Size <span id="chkVal">1000</span></label>
    <input id="chk" type="range" min="500" max="4500" step="500" value="1000"/>

    <label>Splitting Method</label>
    <div class="toggle" id="method">
      <button data-m="sentence">Sentence</button>
      <button data-m="paragraph" class="active">Paragraph</button>
      <button data-m="exact">Exact</button>
    </div>

    <button id="gen" disabled title="Generate (G)">üé§ Generate & Play</button>
    <div id="stat" class="status"></div>
  </div>

  <div class="card">
    <div class="card-header">
      <h2>üîä Playback</h2>
    </div>
    <div id="text" class="text-box"><p style="opacity:.6;text-align:center;">Words will appear here...</p></div>

    <div id="timeline" class="timeline hidden">
      <div id="playhead" class="playhead"></div>
    </div>

    <canvas id="visualizer" height="80" style="width:100%;margin:0.8rem 0;border:1px solid var(--bd);border-radius:var(--r);"></canvas>

    <div class="bar" id="prog">
      <div class="fill" id="fill"></div>
    </div>

    <div class="audio">
      <button class="small-btn" id="play" disabled title="Play/Pause (Space)">‚ñ∂</button>
      <button class="small-btn" id="pause" disabled title="Pause (Space)">‚è∏</button>
      <button class="small-btn" id="stop" disabled title="Stop (Esc)">‚èπ</button>

      <div class="volume-control">
        <span>üîä</span>
        <label for="volume" class="hidden">Volume (Up/Down Arrow)</label> <input type="range" id="volume" min="0" max="1" step="0.1" value="1"/>
      </div>

      <span class="time" id="time">00:00 / 00:00</span>
    </div>

    <button id="download" class="download-btn" disabled title="Download (D)">üíæ Download Audio</button>
    <div class="toggle-debug" id="toggleDebug">Show Debug Info</div>
    <div id="debugPanel" class="debug-panel hidden"></div>
  </div>
</div>

<script>
// Wait for the DOM to be fully loaded before executing script
window.addEventListener('DOMContentLoaded', () => {
  // --- App Information (Using dynamic date/time) ---
  const APP_INFO = {
    version: '1.4.1', // Incremented version
    date: new Date().toISOString().split('T')[0],
    user: 'Doodle-Med', // Placeholder user
    timestamp: new Date().toISOString()
  };
  console.log('App Info:', APP_INFO);

  // --- API Endpoints ---
  const VOICES_API_URL = 'https://texttospeech.googleapis.com/v1/voices';
  const SYNTHESIZE_API_URL = 'https://texttospeech.googleapis.com/v1/text:synthesize';

  // --- DOM Element References (Added timeline/playhead) ---
  const Q = id => document.getElementById(id);
  const E = {
    key: Q('k'), load: Q('ld'), loading: Q('loading'), txt: Q('txt'), voice: Q('v'),
    pit: Q('pit'), rat: Q('rat'), pitVal: Q('pitVal'), ratVal: Q('ratVal'),
    chk: Q('chk'), chkVal: Q('chkVal'), gen: Q('gen'), stat: Q('stat'),
    methodBtns: [...Q('method').children], textBox: Q('text'), play: Q('play'),
    pause: Q('pause'), stop: Q('stop'), volume: Q('volume'), download: Q('download'),
    prog: Q('prog'), fill: Q('fill'), time: Q('time'), toggleDebug: Q('toggleDebug'),
    debugPanel: Q('debugPanel'), themeToggle: Q('themeToggle'), timeline: Q('timeline'),
    playhead: Q('playhead'), visualizerCanvas: Q('visualizer')
  };

  // --- Debugging ---
  let debugEnabled = localStorage.getItem('debugEnabled') === 'true';
  const maxDebugEntries = 100;
  let debugEntries = [];
  let showTimingDebug = true;

  // --- Theme Management ---
  let isDarkMode = localStorage.getItem('darkMode') === 'true';
  const applyTheme = () => {
    document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
    E.themeToggle.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåì';
  };
  applyTheme();

  // --- Audio State ---
  let apiKey = localStorage.getItem('apiKey') || '';
  let audioContext; let masterGainNode; let availableVoices = []; let audioBuffers = [];
  let audioBlobs = []; let activeAudioSources = []; let wordElements = []; let wordTimings = [];
  let chunksData = []; let totalDuration = 0; let loadedDuration = 0; let playbackStartTime = 0;
  let pausedAtTime = 0; let currentPlaybackId = 0; let isPlaying = false; let isPaused = false;
  let chunkSplitMethod = 'paragraph'; let currentWordIndex = -1; let isLoadingComplete = false;
  let chunksReceivedCount = 0; let totalChunksCount = 0; let visualizer;

  // --- Initialization ---
  if (apiKey) {
    E.key.value = apiKey;
    log('API key found, auto-loading voices...');
    setTimeout(() => E.load.click(), 300);
  }
  E.debugPanel.classList.toggle('hidden', !debugEnabled);
  E.toggleDebug.textContent = debugEnabled ? 'Hide Debug Info' : 'Show Debug Info';
  E.timeline.classList.add('hidden');

  // --- Utility Functions (Mostly const arrow functions) ---
  const formatTime = seconds => { /* ... */ }; // Keep as const
  const updateStatus = (message, isError = null) => { /* ... */ }; // Keep as const
  const log = (message, data = null, level = 'info') => { /* ... */ }; // Keep as const
  const updateDebugPanel = () => { /* ... */ }; // Keep as const
  const fetchJSON = async (url, options = {}) => { /* ... */ }; // Keep as const
  const countWords = text => text ? text.trim().split(/\s+/).filter(Boolean).length : 0; // Keep as const
  const decodeAudioDataAsync = async (arrayBuffer) => { /* ... */ }; // Keep as const
  const splitText = (text) => { /* ... */ }; // Keep as const

  // --- Core Logic & UI Functions (Changed to function declarations) ---

  async function initAudioContext() {
    if (!audioContext) {
      try {
        log('Initializing AudioContext...');
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGainNode = audioContext.createGain();
        masterGainNode.gain.value = E.volume.value;
        masterGainNode.connect(audioContext.destination);

        if (typeof VoiceVisualizer !== 'undefined') {
            visualizer = new VoiceVisualizer(E.visualizerCanvas, audioContext, { mode: 'waveform', color: 'gradient' });
            log('VoiceVisualizer initialized.');
        } else {
            log('VoiceVisualizer library not found. Visualizer disabled.', null, 'warn');
             const ctx2d = E.visualizerCanvas.getContext('2d');
             if (ctx2d) {
                 ctx2d.fillStyle = 'rgba(0,0,0,0.5)'; ctx2d.fillRect(0,0, E.visualizerCanvas.width, E.visualizerCanvas.height);
                 ctx2d.fillStyle = 'white'; ctx2d.textAlign = 'center';
                 ctx2d.fillText('Visualizer requires voice-visualizer.js', E.visualizerCanvas.width / 2, E.visualizerCanvas.height / 2);
             }
        }
        log('AudioContext initialized.', { sampleRate: audioContext.sampleRate, state: audioContext.state });
      } catch (error) { log('Failed to initialize AudioContext', error, 'error'); updateStatus('Error initializing audio.', true); throw error; }
    }
    if (audioContext.state === 'suspended') { await audioContext.resume(); log('AudioContext resumed.'); }
  }

  function prepareTextDisplay(fullText, textChunks) {
    log(`Preparing text display: ${fullText.length} chars, ${textChunks.length} chunks.`);
    E.textBox.innerHTML = ''; wordElements = []; wordTimings = []; chunksData = [];
    let totalWordCountOffset = 0;
    chunksData = textChunks.map((chunkText, index) => {
        const wordCount = countWords(chunkText); const startIndex = totalWordCountOffset; const endIndex = startIndex + wordCount - 1;
        totalWordCountOffset += wordCount;
        return { text: chunkText, startTime: 0, endTime: 0, startIndex: startIndex, endIndex: endIndex < startIndex ? startIndex : endIndex, wordCount: wordCount, duration: 0, loaded: false };
    });
    log('Initialized chunksData:', chunksData);
    const tokenizerRegex = /([\w\d'-]+)|([^\s\w\d'-]+)|(\s+)/g;
    let match; let globalWordIndex = 0; let currentChunkIndex = 0;
    while ((match = tokenizerRegex.exec(fullText)) !== null) {
      const wordText = match[1], punctuation = match[2], spaceText = match[3];
      if (wordText) {
        while (currentChunkIndex < chunksData.length - 1 && globalWordIndex > chunksData[currentChunkIndex].endIndex) currentChunkIndex++;
        const chunkInfo = chunksData[currentChunkIndex]; const indexInChunk = globalWordIndex - chunkInfo.startIndex;
        const span = document.createElement('span'); span.textContent = wordText; span.className = 'word loading';
        span.dataset.index = globalWordIndex; span.dataset.chunk = currentChunkIndex;
        wordTimings[globalWordIndex] = { word: wordText, chunk: currentChunkIndex, indexInChunk: indexInChunk, globalIndex: globalWordIndex, startTime: 0, endTime: 0 };
        span.addEventListener('click', (e) => {
          const clickedWordIndex = parseInt(e.currentTarget.dataset.index, 10); const clickedChunkIndex = parseInt(e.currentTarget.dataset.chunk, 10);
          if (e.currentTarget.classList.contains('loading') || !chunksData[clickedChunkIndex]?.loaded) { updateStatus('Audio for this section is still loading...'); return; }
          log(`Word clicked: "${wordTimings[clickedWordIndex]?.word}" (Index: ${clickedWordIndex}, Chunk: ${clickedChunkIndex})`);
          seekToWord(clickedWordIndex);
        });
        wordElements.push(span); E.textBox.appendChild(span); globalWordIndex++;
      } else if (punctuation) E.textBox.appendChild(document.createTextNode(punctuation));
      else if (spaceText) E.textBox.appendChild(document.createTextNode(spaceText));
    }
    log(`Text display prepared with ${globalWordIndex} words.`);
  }

  function updateWordTimings(chunkIndex, chunkDuration) {
    const chunkInfo = chunksData[chunkIndex];
    if (!chunkInfo) { log(`Error updating timings: Invalid chunkIndex ${chunkIndex}`, null, 'error'); return; }
    log(`Updating word timings for Chunk ${chunkIndex}: Duration=${chunkDuration.toFixed(2)}s, Words=${chunkInfo.wordCount}`);
    chunkInfo.loaded = true; chunkInfo.duration = chunkDuration;
    let chunkStartTime = 0;
    for (let i = 0; i < chunkIndex; i++) if (chunksData[i]?.loaded) chunkStartTime += chunksData[i].duration;
    chunkInfo.startTime = chunkStartTime; chunkInfo.endTime = chunkStartTime + chunkDuration;
    const wordCountInChunk = chunkInfo.wordCount;
    if (wordCountInChunk > 0) {
      const avgWordDuration = chunkDuration / wordCountInChunk;
      log(`Chunk ${chunkIndex} timing: Start=${chunkStartTime.toFixed(2)}s, End=${chunkInfo.endTime.toFixed(2)}s, AvgWordDur=${avgWordDuration.toFixed(3)}s`);
      for (let i = chunkInfo.startIndex; i <= chunkInfo.endIndex; i++) {
          if (i >= 0 && i < wordTimings.length) {
              const timing = wordTimings[i];
              if (timing.chunk === chunkIndex) {
                  timing.startTime = chunkStartTime + (timing.indexInChunk * avgWordDuration);
                  timing.endTime = timing.startTime + avgWordDuration;
                  const wordEl = wordElements[i];
                  if (wordEl) {
                      wordEl.classList.remove('loading');
                      if (showTimingDebug && debugEnabled) wordEl.dataset.time = timing.startTime.toFixed(2);
                  }
              }
          } else log(`Warning: Word index ${i} out of bounds during timing update for chunk ${chunkIndex}.`, {startIndex: chunkInfo.startIndex, endIndex: chunkInfo.endIndex, totalWords: wordTimings.length }, 'warn');
      }
    } else log(`Chunk ${chunkIndex} has 0 words, skipping timing distribution.`);
    loadedDuration = chunksData.reduce((sum, chunk) => sum + (chunk.loaded ? chunk.duration : 0), 0);
    if (debugEnabled && !E.timeline.classList.contains('hidden')) {
        const currentTotalDurationForTimeline = chunksData.reduce((sum, chunk) => sum + (chunk.loaded ? chunk.duration : 0), 0);
        if (currentTotalDurationForTimeline > 0) updateTimelineVisualization(currentTotalDurationForTimeline);
    }
  }

  function updateTimelineVisualization(currentTotalDur) {
    if (!debugEnabled || !currentTotalDur || currentTotalDur <= 0) return;
    log(`Updating timeline visualization (Duration: ${currentTotalDur.toFixed(2)}s)`);
    Array.from(E.timeline.children).forEach(child => { if (child !== E.playhead) E.timeline.removeChild(child); });
    chunksData.forEach((chunk, i) => {
      if (!chunk.loaded || chunk.duration <= 0) return;
      const startPercent = (chunk.startTime / currentTotalDur) * 100; const widthPercent = (chunk.duration / currentTotalDur) * 100;
      if (startPercent < 0 || startPercent > 100 || widthPercent <= 0) { log(`Skipping invalid chunk marker ${i}`, {startPercent, widthPercent}, 'warn'); return; }
      const marker = document.createElement('div'); marker.className = 'chunk-marker';
      marker.style.left = `${Math.max(0, startPercent)}%`; marker.style.width = `${Math.min(100 - startPercent, widthPercent)}%`;
      marker.textContent = `C${i}`; marker.title = `Chunk ${i}: ${chunk.startTime.toFixed(1)}s-${chunk.endTime.toFixed(1)}s (${chunk.wordCount}w)`;
      E.timeline.appendChild(marker);
    });
    const maxDots = 200; const sampleRate = Math.max(1, Math.ceil(wordTimings.length / maxDots));
    wordTimings.forEach((timing, i) => {
      if (i % sampleRate === 0 && chunksData[timing.chunk]?.loaded) {
        const positionPercent = (timing.startTime / currentTotalDur) * 100;
        if (positionPercent >= 0 && positionPercent <= 100) {
            const dot = document.createElement('div'); dot.className = 'word-dot'; dot.style.left = `${positionPercent}%`;
            dot.title = `${timing.word} @ ${timing.startTime.toFixed(2)}s`; dot.dataset.index = i;
            E.timeline.appendChild(dot);
        }
      }
    });
  }

  function updatePlayheadPosition(currentTime) {
    if (!debugEnabled || !totalDuration || totalDuration <= 0) return;
    const positionPercent = Math.min(100, Math.max(0, (currentTime / totalDuration) * 100));
    E.playhead.style.left = `${positionPercent}%`;
  }

  function findPositionForTime(time) {
    let accumulatedTime = 0;
    for (let i = 0; i < chunksData.length; i++) {
      const chunk = chunksData[i];
      if (chunk.loaded && chunk.duration > 0) {
        if (time >= accumulatedTime && time < accumulatedTime + chunk.duration) return { chunkIndex: i, offset: time - accumulatedTime };
        accumulatedTime += chunk.duration;
      }
    }
    const lastLoadedChunkIndex = chunksData.findLastIndex(c => c.loaded && c.duration > 0);
    if (lastLoadedChunkIndex !== -1) { log(`Time ${time.toFixed(2)}s beyond loaded duration. Mapping to end of chunk ${lastLoadedChunkIndex}.`); return { chunkIndex: lastLoadedChunkIndex, offset: chunksData[lastLoadedChunkIndex].duration }; }
    log(`Could not map time ${time.toFixed(2)}s. Defaulting to start.`, null, 'warn'); return { chunkIndex: 0, offset: 0 };
  }

  function seekToTime(time) {
    if (!audioBuffers.some(b => b) || totalDuration <= 0) { log('Cannot seek: No audio loaded.', null, 'warn'); return; }
    const targetTime = Math.max(0, Math.min(time, totalDuration));
    log(`Seeking to time: ${targetTime.toFixed(2)}s`);
    const { chunkIndex, offset } = findPositionForTime(targetTime);
    const wasPlaying = isPlaying;
    stopPlayback(true); // Stop silently
    updateUI(targetTime); // Update UI immediately
    if (wasPlaying) startPlayback(chunkIndex, offset, targetTime);
    else { isPaused = true; pausedAtTime = targetTime; E.play.disabled = false; E.pause.disabled = true; log(`Seek complete. Paused at ${targetTime.toFixed(2)}s.`); }
  }

  function seekToWord(wordIndex) {
    if (wordIndex < 0 || wordIndex >= wordTimings.length) { log(`Cannot seek: Invalid word index ${wordIndex}.`, null, 'error'); return; }
    const timing = wordTimings[wordIndex]; const chunkInfo = chunksData[timing.chunk];
    if (!timing || !chunkInfo || !chunkInfo.loaded) { log(`Cannot seek to word ${wordIndex}: Timing/chunk not loaded.`, { timing, chunkInfo }, 'warn'); updateStatus('Audio for this word not loaded.'); return; }
    const targetTime = timing.startTime;
    log(`Seeking to word "${timing.word}" (Index: ${wordIndex}) at time ${targetTime.toFixed(2)}s`);
    seekToTime(targetTime);
  }

  function startPlayback(chunkIndex, offset = 0, absoluteTime = 0) {
    if (isPlaying) return;
    if (!audioBuffers.some(b => b)) return;
    initAudioContext(); // Ensure context is ready
    currentPlaybackId = Date.now();
    isPlaying = true; isPaused = false;
    playbackStartTime = audioContext.currentTime - absoluteTime;
    log(`Starting playback (ID: ${currentPlaybackId}): Chunk ${chunkIndex}, Offset ${offset.toFixed(2)}s, AbsTime ${absoluteTime.toFixed(2)}s`);
    E.play.disabled = true; E.pause.disabled = false; E.stop.disabled = false;
    stopAndClearSources();
    playChunk(chunkIndex, offset, currentPlaybackId);
    requestAnimationFrame(playbackUpdateLoop);
  }

  function playChunk(index, offset = 0, id) {
    if (id !== currentPlaybackId || !isPlaying) { log(`Stopping chunk ${index}: Stale ID or not playing.`); return; }
    if (index >= audioBuffers.length) { log('Playback finished: End of chunks.'); stopPlayback(); return; }
    const buffer = audioBuffers[index];
    if (!buffer || !chunksData[index]?.loaded) {
      log(`Chunk ${index} not ready, waiting...`); updateStatus(`Waiting for chunk ${index + 1}...`);
      setTimeout(() => { if (id === currentPlaybackId && isPlaying) playChunk(index, offset, id); }, 200); return;
    }
    log(`Playing Chunk ${index} (ID: ${id}) from offset ${offset.toFixed(2)}s`); updateStatus(`Playing chunk ${index + 1}/${totalChunksCount}`);
    const source = audioContext.createBufferSource(); source.buffer = buffer;
    if (visualizer) { source.connect(visualizer.analyser); visualizer.analyser.connect(masterGainNode); }
    else { source.connect(masterGainNode); }
    activeAudioSources[index] = source;
    source.onended = () => {
      log(`Chunk ${index} (ID: ${id}) ended.`); activeAudioSources[index] = null;
      if (id === currentPlaybackId && isPlaying) playChunk(index + 1, 0, id);
    };
    const validOffset = Math.max(0, Math.min(offset, buffer.duration));
    if (validOffset >= buffer.duration && buffer.duration > 0) { log(`Skipping chunk ${index}: offset >= duration.`); source.onended(); return; }
    try { source.start(0, validOffset); } catch (e) { log(`Error starting source ${index}`, e, 'error'); source.onended(); }
  }

  function stopAndClearSources() {
    log(`Stopping ${activeAudioSources.filter(Boolean).length} active source(s).`);
    activeAudioSources.forEach((source, index) => {
      if (source) { try { source.onended = null; source.stop(); log(`Stopped source ${index}.`); } catch (e) { if (e.name !== 'InvalidStateError') log(`Error stopping source ${index}: ${e.message}`, e, 'warn'); } }
    });
    activeAudioSources = new Array(chunksData.length).fill(null);
  }

  function pausePlayback() {
    if (!isPlaying) { log('Cannot pause: not playing.', null, 'warn'); return; }
    pausedAtTime = audioContext.currentTime - playbackStartTime;
    isPlaying = false; isPaused = true;
    log(`Pausing playback (ID: ${currentPlaybackId}) at ${pausedAtTime.toFixed(2)}s`);
    stopAndClearSources();
    E.play.disabled = false; E.pause.disabled = true;
    updateStatus(`Paused at ${formatTime(pausedAtTime)}`);
  }

  function resumePlayback() {
    if (!isPaused) { log('Cannot resume: not paused.', null, 'warn'); return; }
    log(`Resuming playback from ${pausedAtTime.toFixed(2)}s`);
    const { chunkIndex, offset } = findPositionForTime(pausedAtTime);
    startPlayback(chunkIndex, offset, pausedAtTime);
  }

  function stopPlayback(silent = false) {
    if (!isPlaying && !isPaused) return;
    const currentId = currentPlaybackId; log(`Stopping playback (ID: ${currentId}, Silent: ${silent})`);
    isPlaying = false; isPaused = false; currentPlaybackId = 0;
    stopAndClearSources();
    if (!silent) {
      pausedAtTime = 0; updateUI(0);
      const hasBuffers = audioBuffers.some(b => b);
      E.play.disabled = !hasBuffers; E.pause.disabled = true; E.stop.disabled = !hasBuffers;
      updateStatus('Playback stopped.');
    }
    if (currentWordIndex !== -1 && currentWordIndex < wordElements.length) {
      wordElements[currentWordIndex]?.classList.remove('active');
      const dot = E.timeline.querySelector(`.word-dot[data-index="${currentWordIndex}"]`); dot?.classList.remove('active');
    } currentWordIndex = -1;
  }

  function playbackUpdateLoop() {
    if (!isPlaying) return;
    const currentTime = audioContext.currentTime - playbackStartTime;
    const clampedTime = Math.min(currentTime, totalDuration);
    updateUI(clampedTime);
    if (clampedTime >= totalDuration && totalDuration > 0) { log(`Loop reached end.`); stopPlayback(); return; }
    requestAnimationFrame(playbackUpdateLoop);
  }

  function updateUI(time) {
    const percentage = totalDuration > 0 ? (time / totalDuration) * 100 : 0;
    E.fill.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
    E.time.textContent = `${formatTime(time)} / ${formatTime(totalDuration)}`;
    updatePlayheadPosition(time);
    updateWordHighlight(time);
  }

  let lastHighlightUpdateTime = 0; const highlightUpdateThrottle = 50;
  function updateWordHighlight(time) {
      const now = Date.now(); if (now - lastHighlightUpdateTime < highlightUpdateThrottle) return; lastHighlightUpdateTime = now;
      let newActiveWordIndex = -1;
      for (let i = 0; i < wordTimings.length; i++) {
          const timing = wordTimings[i];
          if (chunksData[timing.chunk]?.loaded && time >= timing.startTime && time < timing.endTime) { newActiveWordIndex = i; break; }
      }
      if (newActiveWordIndex === -1) {
          for (let i = wordTimings.length - 1; i >= 0; i--) {
              const timing = wordTimings[i];
              if (chunksData[timing.chunk]?.loaded && time >= timing.endTime) { newActiveWordIndex = i; break; }
          }
      }
      if (newActiveWordIndex !== currentWordIndex) {
          if (currentWordIndex !== -1 && currentWordIndex < wordElements.length) {
              wordElements[currentWordIndex]?.classList.remove('active');
              const prevDot = E.timeline.querySelector(`.word-dot[data-index="${currentWordIndex}"]`); prevDot?.classList.remove('active');
          }
          if (newActiveWordIndex !== -1 && newActiveWordIndex < wordElements.length) {
              const newWordElement = wordElements[newActiveWordIndex];
              newWordElement?.classList.add('active');
              const newDot = E.timeline.querySelector(`.word-dot[data-index="${newActiveWordIndex}"]`); newDot?.classList.add('active');
              const container = E.textBox; const wordRect = newWordElement.getBoundingClientRect(); const containerRect = container.getBoundingClientRect();
              if (wordRect.top < containerRect.top || wordRect.bottom > containerRect.bottom) {
                  const scrollOffset = newWordElement.offsetTop - container.offsetTop - (container.clientHeight / 2) + (newWordElement.clientHeight / 2);
                  container.scrollTop = scrollOffset;
              }
          } currentWordIndex = newActiveWordIndex;
      }
  }

  function createDownloadLink() {
    log('Attempting download...'); const validBlobs = audioBlobs.filter(Boolean);
    if (validBlobs.length === 0) { log('No valid blobs.', null, 'error'); updateStatus('Download failed: No audio.', true); return; }
    log(`Combining ${validBlobs.length} blob(s).`);
    try {
      const combinedBlob = new Blob(validBlobs, { type: 'audio/mp3' });
      log(`Combined blob size: ${(combinedBlob.size / 1024 / 1024).toFixed(2)} MB`);
      const blobUrl = URL.createObjectURL(combinedBlob);
      const link = document.createElement('a'); link.href = blobUrl;
      const voiceName = E.voice.value.replace(/[^a-z0-9]/gi, '_').toLowerCase();
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      link.download = `tts_audio_${voiceName}_${timestamp}.mp3`;
      document.body.appendChild(link); link.click(); document.body.removeChild(link);
      setTimeout(() => { URL.revokeObjectURL(blobUrl); log('Blob URL revoked.'); }, 1500);
      updateStatus('Download started.', false);
    } catch (error) { log('Error creating download', error, 'error'); updateStatus(`Download failed: ${error.message}`, true); }
  }

  // --- Event Listener Setup ---
  // (Keep listeners setup after function definitions)

  // UI event binding
  ['pit', 'rat', 'chk'].forEach(id => { /* ... listener setup ... */ });
  E.volume.addEventListener('input', () => { /* ... listener setup ... */ });
  E.themeToggle.addEventListener('click', () => { /* ... listener setup ... */ });
  E.toggleDebug.addEventListener('click', () => { /* ... listener setup ... */ });
  E.load.addEventListener('click', async () => { /* ... listener setup ... */ });
  E.methodBtns.forEach(button => button.addEventListener('click', () => { /* ... listener setup ... */ }));
  E.gen.addEventListener('click', async () => { /* ... listener setup ... */ });

  // Playback control listeners (Now referencing hoisted function declarations)
  E.play.addEventListener('click', () => {
    if (!audioContext) initAudioContext();
    if (isPaused) resumePlayback();
    else if (!isPlaying && audioBuffers.some(b => b)) startPlayback(0, 0, 0);
  });
  E.pause.addEventListener('click', pausePlayback); // This should now work
  E.stop.addEventListener('click', () => stopPlayback()); // Using arrow function wrapper is also fine

  E.prog.addEventListener('click', (e) => { /* ... listener setup ... */ });
  E.timeline.addEventListener('click', (e) => { /* ... listener setup ... */ });
  E.download.addEventListener('click', createDownloadLink);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    const hasAudio = audioBuffers.some(b => b);
    // Use direct function calls where possible, or .click() if needed
    if (e.code === 'Space') { e.preventDefault(); if (isPlaying) pausePlayback(); else if (isPaused || (hasAudio && !isPlaying)) E.play.click(); } // Call pausePlayback directly
    if (e.code === 'Escape' && (isPlaying || isPaused)) { e.preventDefault(); stopPlayback(); } // Call stopPlayback directly
    if (e.code === 'KeyG' && !E.gen.disabled) { e.preventDefault(); E.gen.click(); }
    if (e.code === 'KeyD' && !E.download.disabled) { e.preventDefault(); createDownloadLink(); } // Call createDownloadLink directly
    if (e.code === 'KeyT') { e.preventDefault(); E.themeToggle.click(); } // .click() is fine for simple toggles
    if (e.code === 'ArrowLeft' && (isPlaying || isPaused)) { e.preventDefault(); const time = isPlaying ? audioContext.currentTime - playbackStartTime : pausedAtTime; seekToTime(time - 5); }
    if (e.code === 'ArrowRight' && (isPlaying || isPaused)) { e.preventDefault(); const time = isPlaying ? audioContext.currentTime - playbackStartTime : pausedAtTime; seekToTime(time + 5); }
    if (e.code === 'ArrowUp') { e.preventDefault(); E.volume.value = Math.min(1, parseFloat(E.volume.value) + 0.1); E.volume.dispatchEvent(new Event('input')); }
    if (e.code === 'ArrowDown') { e.preventDefault(); E.volume.value = Math.max(0, parseFloat(E.volume.value) - 0.1); E.volume.dispatchEvent(new Event('input')); }
  });

  log('Application initialized', APP_INFO);

}); // End DOMContentLoaded listener

// --- Utility Functions Definitions (Hoisted safely below, but keep as const is fine) ---
const formatTime = seconds => {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
};
const updateStatus = (message, isError = null) => {
  E.stat.textContent = message;
  E.stat.className = 'status';
  if (isError === true) E.stat.classList.add('error');
  else if (isError === false) E.stat.classList.add('success');
  log(message, null, isError ? 'error' : (isError === false ? 'success' : 'info'));
};
const log = (message, data = null, level = 'info') => {
  const timestamp = new Date().toISOString();
  const entry = { timestamp, message, data, level };
  debugEntries.unshift(entry);
  if (debugEntries.length > maxDebugEntries) debugEntries.pop();
  const consoleArgs = [`[${new Date(timestamp).toLocaleTimeString()}] ${message}`];
  if (data !== null) consoleArgs.push(data);
  switch(level) {
    case 'error': console.error(...consoleArgs); break;
    case 'warn': console.warn(...consoleArgs); break;
    case 'success': console.log(`%c${consoleArgs[0]}`, 'color: green', ...(consoleArgs.slice(1))); break;
    default: console.log(...consoleArgs);
  }
  if (debugEnabled) updateDebugPanel();
};
const updateDebugPanel = () => {
  E.debugPanel.innerHTML = debugEntries.map(entry => {
    const timeStr = new Date(entry.timestamp).toLocaleTimeString();
    let dataStr = '';
    if (entry.data !== null) { try { dataStr = `<div class="debug-data">${typeof entry.data === 'object' ? JSON.stringify(entry.data, null, 2) : entry.data}</div>`; } catch (e) { dataStr = `<div class="debug-data">[Error stringifying data]</div>`; } }
    return `<div class="debug-entry debug-${entry.level}"><span class="debug-time">${timeStr}</span> <span class="debug-msg">${entry.message}</span>${dataStr}</div>`;
  }).join('');
};
const fetchJSON = async (url, options = {}) => {
  log(`Fetching: ${url}`, options.method || 'GET');
  try {
    const response = await fetch(url, options);
    if (!response.ok) { let errorMessage = `HTTP Error: ${response.status} ${response.statusText}`; let errorDetails = null; try { errorDetails = await response.json(); errorMessage = errorDetails?.error?.message || errorMessage; log('API Error Response', errorDetails, 'error'); } catch (e) { log('Failed to parse error response body', await response.text(), 'warn'); } throw new Error(errorMessage); }
    const data = await response.json(); log(`Fetch Success: ${url}`, data); return data;
  } catch (error) { log(`Fetch Failed: ${url}`, { error: error.message, stack: error.stack }, 'error'); throw error; }
};
const decodeAudioDataAsync = async (arrayBuffer) => {
  if (!audioContext || audioContext.state !== 'running') await initAudioContext();
  log(`Decoding audio buffer (${(arrayBuffer.byteLength / 1024).toFixed(1)} KB)`);
  return new Promise((resolve, reject) => { audioContext.decodeAudioData(arrayBuffer, resolve, (error) => { log('Error decoding audio data', error, 'error'); reject(new Error(`Audio decode error: ${error.message || error}`)); }); });
};
const splitText = (text) => {
  const maxChunkSize = parseInt(E.chk.value, 10); log(`Splitting text (${text.length} chars) using '${chunkSplitMethod}', max size: ${maxChunkSize}`); if (text.length <= maxChunkSize) return [text]; let chunks = [];
  if (chunkSplitMethod === 'exact') { for (let i = 0; i < text.length; i += maxChunkSize) chunks.push(text.slice(i, i + maxChunkSize)); }
  else { const delimiter = chunkSplitMethod === 'paragraph' ? /(\n\s*\n)/ : /([.!?]+(?:["']|\u201d|\u2019)?\s+)/; const segments = text.split(delimiter).reduce((acc, part, index) => { if (index % 2 === 0) acc.push(part); else if (acc.length > 0) acc[acc.length - 1] += part; else acc.push(part); return acc; }, []).filter(Boolean); log(`Initial split into ${segments.length} segments by ${chunkSplitMethod}.`); let currentChunk = ''; segments.forEach(segment => { if (segment.length > maxChunkSize) { if (currentChunk) chunks.push(currentChunk); currentChunk = ''; let remainingSegment = segment; while (remainingSegment.length > maxChunkSize) { let splitPoint = maxChunkSize; let lastSpace = remainingSegment.lastIndexOf(' ', maxChunkSize); if (lastSpace > maxChunkSize / 2) splitPoint = lastSpace + 1; chunks.push(remainingSegment.slice(0, splitPoint)); remainingSegment = remainingSegment.slice(splitPoint); } currentChunk = remainingSegment; } else if ((currentChunk + segment).length <= maxChunkSize) currentChunk += segment; else { chunks.push(currentChunk); currentChunk = segment; } }); if (currentChunk) chunks.push(currentChunk); }
  log(`Final chunks: ${chunks.length}`, { chunkSizes: chunks.map(c => c.length) }); return chunks.map(c => c.trim()).filter(Boolean);
};

</script>
</body>
</html>
